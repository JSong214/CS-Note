## Event Loop(事件循环)

### **执行流程**

1. JS会先执行从上到下**执行Script中的代码**。( **Script本身，就被浏览器当作第一个“宏任务”** )
2. **清空微任务**：主代码（Script）执行完，立即检查微任务队列，把刚才积攒的微任务**全部**执行完。
3. **渲染（Rendering）**：浏览器判断是否需要更新页面 UI。
4. **下一个宏任务**：从宏任务队列里取**一个**（比如 `setTimeout` 的回调），执行它。
5. **再清空微任务**：每执行完一个宏任务，都要立刻去查微任务队列。
6. 循环...

**记法：** 宏任务是按“个”执行的，微任务是按“队”清空的。



### 宏任务与微任务的分类

#### **微任务 (Microtasks):**

- **`Promise.then / .catch / .finally`**
- `MutationObserver` (监听 DOM 变化)
- `queueMicrotask` (专门创建微任务的 API)



#### **宏任务 (Macrotasks):**

- 整体代码 `Script`
- `setTimeout` / `setInterval`
- I/O 操作, UI 渲染



### 补充知识点：

#### Promise 的哪一部分是异步？

**Promise 构造函数内部的代码是同步的，只有 `.then()` 或 `.catch()` 里的代码才是微任务。**

```js
new Promise((resolve) => {
    console.log("1. 我是同步执行的！"); // 这里立即执行，不进队列
    resolve();
}).then(() => {
    console.log("2. 我才是微任务"); // 这里进微任务队列
});

console.log("3. 我也是同步的");
```

**输出顺序：** 1 -> 3 -> 2。



#### 入队时机（并不是“遇到”就立刻入队）

**Web API** 可能不会里立刻将异步函数放入队列中。

当你执行 `setTimeout(fn, 1000)` 时，并不是立刻把 `fn` 放到宏任务队列里。

1. **主线程**通知**浏览器定时器模块**：“帮我计时 1 秒”。
2. **1 秒后**，定时器模块才把 `fn` 推入**宏任务队列**。
3. 如果主线程还在忙（比如有个死循环），即使 1 秒到了，`fn` 进了队列，也得排队等着。这就是为什么 `setTimeout` 经常不准的原因。