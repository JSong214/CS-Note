---
date: 2025-06-12
tags:
  - JavaScript
aliases:
  - 调用栈
  - 宏任务
  - 微任务
---
## 事件循环 (Event Loop) 

### 基本模型

- **调用栈 (Call Stack)**
  - **后进先出** (LIFO) 的数据结构
  - 同步代码按顺序入栈执行
  - 函数执行时入栈，执行完出栈


- **宏任务队列 (Macro Task Queue)**
  - 存放宏任务
    - **`setTimeout()` 和 `setInterval()`**
      - 定时器的回调函数。
    - **I/O 操作**：
      - 文件读写、网络请求（如 `fetch` 的完成回调）、用户交互事件（如 `click`、`keydown`）等异步 I/O 操作的回调函数。
    - **DOM 事件回调**
      - 例如 `addEventListener` 绑定的事件（点击、滚动等）触发后的处理函数。
    - **UI Rendering（隐式）**
      - 浏览器渲染流程本身可视为一个宏任务（但不由开发者直接控制）。
      - 但实际上，浏览器会在执行完微任务队列后，在下一个宏任务之前进行渲染（但渲染并不在任务队列中，而是由浏览器根据情况决定）

  - **关键特性：**
    - **每次事件循环只执行一个宏任务**


- **微任务队列 (Micro Task Queue)**
  - 存放宏任务：
    - **`Promise` 回调**
      - `.then()`、`.catch()` 和 `.finally()` 中的回调函数
      - `async/await` 中的异步操作（本质是基于 Promise）
        ```js
        Promise.resolve().then(() => {
          console.log('微任务执行');
        });
        ```

    - **`queueMicrotask()` API**
      - 专门用于将任务加入微任务队列的方法
        ```js
        queueMicrotask(() => {
          console.log('queueMicrotask 添加的任务');
        });
        ```

  - **关键特性：**
    - **执行时机**：在当前宏任务执行结束后、下一个宏任务开始前**立即执行**
    - **队列处理**：必须**清空整个微任务队列后才会执行下一个宏任务**
    - **优先级**：微任务**优先级高于宏任务**



### 执行顺序规则
1. 执行全局同步代码（视为初始宏任务）
2. 遇到**宏任务**放入宏任务队列
3. 遇到**微任务**放入微任务队列
4. 同步代码执行完毕后，清空**所有微任务**
5. 执行**一个**宏任务
6. 重复步骤 4-5（事件循环）

> 📌 **关键原则**：**微任务优先级 > 宏任务**，且每执行完一个宏任务后必须清空微任务队列



### 异步解决方案：

- [[回调函数]] (Callbacks)

- **[[Promise]]**

- **[[Async & Await|Async]]/Await**
