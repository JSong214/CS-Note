---
date: 2025-06-12
tags:
  - JavaScript
aliases:
  - 原型链
---
## 核心概念

### 原型（Prototype）

- **函数原型**：每个函数都有一个 **`prototype`** 属性（箭头函数除外）
- **对象原型**：每个对象都有一个 `[[Prototype]]` 内部属性（可通过 **`__proto__`** 访问）
- 原型对象包含**共享属性和方法**

###  原型链
- 对象访问属性时的查找机制：`对象自身 → 原型对象 → 原型的原型 → ... → null`
- 形成链式结构，终点是 `Object.prototype`（其 `__proto__` 为 `null`）



## 关键关系图示

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image%2F%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg)



## 核心机制详解

### 构造函数、原型与实例关系

```js
function Person(name) {
  this.name = name;
}

// 原型方法
Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

const john = new Person('John');

// 关系验证
console.log(john.__proto__ === Person.prototype); // true
console.log(Person.prototype.constructor === Person); // true
console.log(Object.getPrototypeOf(john) === Person.prototype); // true
```



###  原型链继承

```js
function Person(name) {
  this.name = name;
}

// 原型方法
Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

function Student(name, major) {
  Person.call(this, name); // 继承属性
  this.major = major;
}

// 设置原型链
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student; // 修复构造函数指向

// 子类方法
Student.prototype.study = function() {
  console.log(`${this.name} is studying ${this.major}`);
};

const alice = new Student('Alice', 'Computer Science');
alice.sayHello(); // 继承自Person
alice.study();    // 自身方法
```