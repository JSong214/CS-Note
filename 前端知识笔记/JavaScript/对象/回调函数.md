---
date: 2025-06-13
tags:
  - JavaScript
aliases:
  - Callbacks
---
**定义：** 
- **回调函数（Callback）** 是将函数作为参数传递给另一个函数，并在特定操作完成后执行的模式。
- 它是处理异步操作（如定时器、网络请求、文件读写等）的基础机制，但由于嵌套过深容易导致 **"回调地狱"（Callback Hell）**。

### 回调函数的核心理解

```js
// 基本示例：模拟异步操作
function fetchData(callback) {
    setTimeout(() => {
        const data = { id: 1, name: "Alice" };
        callback(data); // 操作完成后调用回调函数
    }, 1000);
}

// 使用回调函数
fetchData(function(result) {
    console.log("Received:", result); // 1秒后输出数据
});
```

**关键点：**
- **异步控制**：回调函数延迟执行，不阻塞主线程。
- **约定规范**：错误优先（Error-first）是常见模式：
  ```js
  fs.readFile("file.txt", (err, data) => {
    if (err) throw err;
    console.log(data);
  });
  ```
- **函数是第一类对象**：函数可作为参数传递，灵活性强。



### 回调地狱（Callback Hell）问题

当多个异步操作**依赖前序结果**时，会形成深层嵌套：

```js
getUser(userId, (user) => {
    getOrders(user.id, (orders) => {
        getProduct(orders[0].id, (product) => {
            calculatePrice(product, (price) => {
                console.log("最终价格:", price); // 嵌套过深！
            });
        });
    });
});
```

**主要问题：**
1. **金字塔结构**：代码向右无限延伸，难以阅读
2. **错误处理复杂**：需在每个层级处理错误
3. **维护困难**：添加/删除操作易出错
4. **变量污染**：外层变量可能被内层误修改



### 解决方案：跳出回调地狱

#### 方案 1：[[Async & Await|Async]]/Await（推荐）

```js
async function fetchPrice() {
    try {
        const user = await getUser(userId);
        const orders = await getOrders(user.id);
        const product = await getProduct(orders[0].id);
        const price = await calculatePrice(product);
        console.log("最终价格:", price);
    } catch (err) {
        console.error("失败:", err);
    }
}
```

**优点**：代码形似同步，可读性最佳

#### 方案 2：[[Promise]] 链式调用（推荐）

```js
getUser(userId)
  .then(user => getOrders(user.id))
  .then(orders => getProduct(orders[0].id))
  .then(product => calculatePrice(product))
  .then(price => console.log("最终价格:", price))
  .catch(err => console.error("失败:", err)); // 统一错误处理
```

**优点**：链式结构、集中错误处理

#### 方案 3：命名函数解耦（Flattening）

```js
function handlePrice(price) {
    console.log("最终价格:", price);
}

function handleProduct(orders) {
    getProduct(orders[0].id, handlePrice);
}

function handleOrders(user) {
    getOrders(user.id, handleProduct);
}

// 主调用链
getUser(userId, handleOrders);
```

**优点**：减少嵌套，逻辑清晰
**缺点**：需预先定义函数，作用域分离



### 回调函数的合理使用场景

- **简单异步操作**：单次事件（如点击事件）
- **轻量级库/工具**：避免引入 Promise 的开销
- **遵循传统规范的 API**：Node.js 核心模块（如 `fs.readFile`）

