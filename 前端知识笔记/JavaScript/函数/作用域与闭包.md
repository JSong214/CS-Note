---
date: 2025-06-12
tags:
  - JavaScript
aliases:
  - 作用域
  - 闭包
---
### **作用域 (Scope)**

**作用：** 作用域决定了变量、函数和[[对象核心概念|对象]]在代码中的**可访问性**（可见性）和**生命周期**。

#### **作用域的类型：**
- **全局作用域：**
  - 在任何函数或代码块之外声明的变量拥有全局作用域。
  - 全局变量可以在脚本的任何地方被访问和修改。
  - `window` 对象（浏览器中）或 `global` 对象（Node.js 中）的属性就是全局变量。
- **函数作用域：**
  - 在**函数内部声明的变量**（使用  `let`, `const`）拥有函数作用域。
  - 只能在声明它们的函数内部及其嵌套的函数中访问。
  - 函数执行完毕后，其内部作用域的变量通常会被销毁（除非形成闭包）。
- **块级作用域：**
  - 由 `{}` 花括号界定的代码块形成的作用域（如 `if`, `for`, `while`, `switch` 语句以及单独的 `{}`）。
  - **`let` 和 `const`** 声明的变量具有块级作用域。
  - 变量只能在声明它的块及其嵌套块中访问。

#### **词法作用域：**
- JavaScript 采用 **词法作用域**，也称为 **静态作用域**。
- **核心规则：** 函数的作用域在**函数定义时**就确定了，而不是在函数调用时。
- 函数在定义时，会“记住”它**当时所处的作用域链**。
- 这意味着，函数内部可以访问它自身作用域、外层（父级）作用域、以及全局作用域中的变量。

#### **作用域链：**
- 当在某个作用域内访问一个变量时，JavaScript 引擎会**首先在当前作用域查找**。
- 如果没找到，它会沿着定义时的作用域链（词法作用域的层级）**逐级向外层作用域**查找。
- 一直查找到全局作用域。


### **闭包 (Closure)**

**定义：**闭包允许函数访问并记住其声明时所处的作用域中的变量，即使该函数在其原始作用域之外执行。

#### **形成闭包的关键条件：**
- **函数嵌套**：存在一个外部函数（outer function）和一个内部函数（inner function）。
- **内部函数引用外部变量**：内部函数使用了外部函数作用域中的变量。
- **内部函数被外部引用**：内部函数通过返回值、事件回调、变量传递等方式被导出到外部作用域。

#### **闭包的核心作用：**
- **维持变量存活：** 闭包使得外部函数执行完毕后，其**内部作用域不会被垃圾回收机制（GC）销毁**，因为内部函数持有对外部作用域变量的引用。这些变量对于内部函数来说仍然是“存活”且可访问的。
- **创建私有状态/数据封装：** 利用闭包可以模拟私有变量。外部函数内的变量只能通过内部函数（闭包）来访问和修改，外部无法直接访问。

**实例：**
```js
function createCounter() {
  let count = 0;
  return function() {
    count++; // 访问外层count（词法作用域保留）
    return count;
  };
}
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2（count状态被保留）
```
