---
date: 2025-06-17
tags:
  - Vue
---
## 响应式系统

它是一个能**自动追踪数据变化**，并**高效更新用户界面（UI）**的机制。当你修改了 JavaScript 中的数据，依赖这些数据的视图部分会自动重新渲染，无需手动操作 DOM。

### 核心原理：

- **依赖收集**
  - **做什么？** 当组件渲染（render）时，它会读取（"get"）其需要的数据。在这个读取的瞬间，Vue 会记录下来：“哦，这个组件的渲染依赖于这个数据”。
  - **好比：** 你订阅了某个博主的频道。当博主发布新视频时，平台知道要通知你。在这里，组件就是“你”，数据就是“博主”，渲染函数读取数据的过程就是“订阅”。

- **派发更新**
  - **做什么？** 当某个数据被修改（"set"）时，Vue 会查找所有订阅（依赖）了这个数据的地方。
  - **好比：** 博主发布了新视频，平台（Vue）就会遍历它的订阅者列表，并向每一个订阅者（组件）发送通知，告诉他们“快来看新内容！”。组件收到通知后，就会重新运行其渲染函数，从而更新视图。



### 实现方式的演进：Vue 2 vs Vue 3

#### Vue 2: `Object.defineProperty`

Vue 2 使用 `Object.defineProperty` API 来劫持对象属性的 `getter` 和 `setter`。

- 工作流程：
  1. 初始化时，Vue 会遍历 `data` 对象中的所有属性。
  2. 对每个属性，使用 `Object.defineProperty` 将其转换为带有 `get` 和 `set` 的访问器属性。
  3. **`get` 阶段：** 当组件渲染读取属性时，触发 `get` 函数，此时进行**依赖收集**。
  4. **`set` 阶段：** 当你修改属性值时，触发 `set` 函数，此时进行**派发更新**。


#### Vue 3: [[Proxy]] + Reflect

Vue 3 采用了更现代、更强大的 **`Proxy` 对象**来实现响应式。

- **工作流程**

  **`Proxy` 直接在目标对象上创建了一个代理。**所有对代理对象的操作（包括读取、设置、删除属性，甚至遍历）都会被 `Proxy` 的处理器（handler）拦截。

  1. **代理整个对象：** `Proxy` 不是劫持单个属性，而是直接代理整个对象。
  2. **`get` 处理器：** 当通过代理对象读取任何属性时，触发 `get` 处理器，进行**依赖收集**。
  3. **`set` 处理器：** 当通过代理对象修改任何属性时，触发 `set` 处理器，进行**派发更新**。
  4. **`deleteProperty` 处理器：** 删除属性时也会被拦截，同样可以派发更新。

- **核心优势** ：
  - **全面拦截:** `Proxy` 可以拦截多达 13 种不同的操作，远超 `Object.defineProperty` 的 `get/set`。
  - **无需初始化劫持:** `Proxy` 是懒代理，只有在访问代理对象时才开始工作，性能更好。
  - **天然支持动态属性:** 直接通过 `proxy.newProp = value` 添加新属性是完全响应式的，无需 `this.$set`。
  - **天然支持数组:** 所有数组操作，包括通过索引修改和修改 `.length`，都能被 `Proxy` 拦截。
  - **`Reflect` 的作用:** 在 `Proxy` 的处理器中，通常使用 `Reflect` 对象上的同名方法来完成对源对象的默认操作（如 `Reflect.get()`, `Reflect.set()`）。这能确保正确地处理 `this` 指向等问题，是最佳实践。



### Vue 3 核心响应式 API

在 Vue 3 的组合式 API (Composition API) 中，你需要手动创建响应式状态。

- **`reactive()`**

  - **用途:** 用于将一个**对象**（或数组）变成深度响应式的代理对象。
  - **特点:**
    - 返回的是一个 `Proxy` 对象。
    - 修改这个代理对象会触发更新。
    - **注意点:** 如果你直接解构 `reactive` 对象，或者将它的属性赋给一个局部变量，会丢失其响应性。
      ```js
      let { count } = reactive({ count: 1 }); 
      count++	// 无效
      ```
  - **示例：**
    ```js
    const state = reactive({ count: 0, name: 'Vue' })
    ```


- **`ref()`**

  - **用途:** 接受一个内部值（可以是任意类型，包括**基本类型**如数字、字符串，也可以是对象），并返回一个响应式的、可变的 ref 对象。
  - **特点:**
    - 返回的对象有一个唯一的属性 `.value`，你需要**通过 `.value` 来访问或修改内部值**。
    - `ref` 解决了基本类型值无法被 `reactive` 代理的问题。
    - 在模板中（template）使用 ref 时，Vue 会自动“解包”（unwrap），你不需要写 `.value`。
  - **示例：**
    ```js
    const count = ref(0); 
    console.log(count.value); 
    count.value++;	// 通过 .value 来访问或修改内部值。
    ```


- `watch()` & `watchEffect()`
  - `watch()`:
    - **懒执行** (lazy)：只有在被侦听的数据源发生变化时才会执行回调。
    - **明确指定依赖源：** 你需要显式地告诉它要侦听哪个响应式数据。
    - 可以访问到变化前后的值。
  - `watchEffect()`:
    - **立即执行**：在创建时会立即执行一次，然后在其依赖项变化时重新运行。
    - **自动追踪依赖：** 它会自动收集其执行期间所有被读取的响应式数据作为依赖。