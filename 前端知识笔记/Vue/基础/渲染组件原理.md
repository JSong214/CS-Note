---
date: 2025-06-26
tags:
  - Vue
---
## Vue 渲染原理

**核心知识点**

我们可以将 Vue 的整个渲染过程想象成一个流水线，它接收你的“设计图”（模板），最终生产出用户在浏览器中看到的真实“产品”（DOM 元素）。

这个流水线主要分为三个核心阶段：

1. **编译 (Compile)**：将开发者编写的模板字符串转换成 JavaScript 可以执行的 **渲染函数 (Render Function)**。
2. **渲染 (Render)**：执行渲染函数，生成一个描述页面结构的 **虚拟 DOM (Virtual DOM) 树**。
3. **更新 (Patch)**：将虚拟 DOM 树与上一次的旧树进行比较（Diff），计算出最小的更新范围，然后将这些变更应用到真实的 DOM 上。


### 阶段一：编译 (Compile) - 模板的“翻译官”

浏览器不认识`<template>`中的 `v-if`, `v-for`, `@click` 这些东西。**编译阶段的工作就是把它们翻译成 JS 能懂的代码。**

**这个阶段通常在构建时 (Build Time) 完成**（例如，使用 Vite 或 Vue CLI），而不是在浏览器运行时。


**编译过程三部曲：**

1. **解析 (Parse)**
   - **输入**：模板字符串 (`<div id="app">{{ message }}</div>`)。
   - **工作**：通过大量的正则表达式和状态机，像词法分析一样，逐字符解析模板，生成一个 **AST (Abstract Syntax Tree, 抽象语法树)**。
   - **输出**：一个用 JavaScript 对象来描述模板结构和节点信息的树形结构。这个 AST 精确地描述了每个节点的类型（元素、文本、注释）、标签名、属性、指令 (`v-if` 等) 和子节点。
2. **优化 (Optimize)**
   - **输入**：AST。
   - **工作**：遍历 AST，寻找其中的 **静态节点 (Static Nodes)** 并进行标记。
   - **输出**：一个经过优化的 AST。
   - **【重要知识点】静态节点优化**
     - 什么是静态节点？
       - 指的是那些在**渲染过程中永远不会发生变化的部分**。
       - 例如，没有使用任何指令、没有绑定任何动态数据、纯粹的 HTML 标签和文本，如 `<div><p>这是一个不会改变的段落</p></div>`。
     - 为什么要做优化？
       -  Vue 在后续进行 `Diff` 对比时，可以直接跳过这些被标记为静态的节点，从而大大减少了比较的开销，提升了更新性能。
       - 在重新渲染时，这些静态节点对应的 VNode 和 DOM 都可以被复用。
3. **生成 (Generate)**
   - **输入**：优化后的 AST。
   - **工作**：将 AST 转换成 **渲染函数 (Render Function)** 的代码字符串。
   - **输出**：类似这样的代码字符串：`"return function render() { with(this){return _c('div', {attrs:{"id":"app"}},[_v(_s(message))])} }"`。最终，这个字符串会被 `new Function(code)` 转换成一个可执行的函数。

**小结：** 编译阶段的核心产出物就是 **`Render Function`**。



### 阶段二：渲染 (Render) - 生成虚拟 DOM (VNode)

当组件需要被渲染时（首次挂载或数据更新后），就会执行上一阶段生成的 `render` 函数。

**【重要知识点】虚拟 DOM (Virtual DOM / VNode)**

**`render` 函数**执行后并不会直接创建真实的 DOM，而是会**返回**一个 **虚拟 DOM (Virtual DOM) 树**。

- **什么是虚拟 DOM？**

  - 它本质上是一个轻量级的 JavaScript 对象，用来描述真实 DOM 的结构、属性和内容。每个 VNode (Virtual Node) 对应一个 DOM 元素。

  - 一个简单的 VNode 可能长这样：

    ```js
    {
      type: 'div', // 节点类型
      props: { 'id': 'app' }, // 节点的属性
      children: [ // 子节点，同样是 VNode
        { type: '#text', children: 'Hello Vue' }
      ]
    }
    ```

- **为什么要使用虚拟 DOM？**

  1. **性能卓越**：直接操作真实 DOM 是非常昂贵的浏览器操作，因为它会引起浏览器的 **重排 (Reflow)** 和 **重绘 (Repaint)**。VNode大大减少了昂贵的 DOM 操作次数。
  2. **跨平台能力**：VDOM 是对真实渲染环境的一种抽象。有了这层抽象，Vue 的渲染器 (Renderer) 就可以将 VNode 渲染到不同的平台，不仅仅是 Web 浏览器。
  3. **提升开发体验**：它使得我们可以用声明式的方式来编写 UI (`<template>`)，而无需关心底层的 DOM 操作细节，只需要关心数据状态 (`state`)，Vue 会自动根据数据变化来高效地更新视图。


`render` 函数的核心是 `h()` 函数（在 Vue 3 中是 `createVNode()` 的别名，来源于 Hyperscript - "生成 HTML 的脚本"）。模板中的 `<div id="app">{{ message }}</div>` 经过编译后，其 `render` 函数本质上就是在调用：

```js
import { createVNode, createTextVNode } from 'vue'

function render() {
  return createVNode('div', { id: 'app' }, [
    createTextVNode(this.message) // this.message 是响应式数据
  ])
}
```



### 阶段三：更新 (Patch) - 响应式驱动的视图更新

这是 Vue 响应式系统的核心体现。

1. **首次渲染 (Mounting)**

   - 组件首次加载时，执行 `render` 函数生成第一个 VNode 树。
   - `patch` 函数接收这个 VNode 树，遍历它，并根据每个 VNode 的描述 (`type`, `props` 等) 创建出对应的真实 DOM 元素 (`document.createElement`)，然后插入到指定的挂载点 (例如 `#app` 对应的元素)。


2. **数据更新与重新渲染 (Updating)**

   这是最关键的流程。

   - **触发更新**：当组件中依赖的响应式数据（如 `ref` 或 `reactive` 对象中的属性）发生变化时。
   - **依赖追踪**：Vue 3 使用 **`Proxy`** (Vue 2 使用 `Object.defineProperty`) 来**实现响应式**。当一个组件的 `render` 函数执行时，它会 "访问" 到它所依赖的数据。此时，响应式系统会建立一个 "依赖关系"：**「哪个组件的渲染」依赖于「哪个数据」**。
   - **重新渲染**：当数据被修改时，响应式系统会精确地找到所有依赖这个数据的组件，并通知它们进行更新，也就是重新执行它们的 `render` 函数。
   - **生成新 VNode**：重新执行 `render` 函数会生成一个新的 VNode 树。
   - **Diff & Patch**：现在我们有了一个新的 VNode 树和一个旧的 VNode 树（上次渲染时生成的）。接下来就是 `patch` 过程的核心——**Diff 算法**。



##### 【重要知识点】Diff 算法

Diff 算法的目标是高效地找出新旧两个 VNode 树之间的差异。Vue 的 Diff 算法遵循两个核心策略以降低复杂度：

1. **只比较同层级的节点**：它不会跨层级比较。例如，它不会拿第一层的 `div` 去和第三层的 `p` 比较。如果一个父节点被替换了，那么它的所有子节点都将被销毁并重新创建，而不是试图去复用。
2. **双端比较 (Two-Ended/Double-Ended Diff)**：在比较同级的一组子节点时 (例如 `v-for` 生成的列表)，Vue 3 采用了一种非常高效的双端比较算法。它同时从新旧两个列表的 **头部和尾部** 开始进行比较，通过四次指针移动和比较（**头对头、尾对尾、头对尾、尾对头**），快速找出可复用的节点、需要移动的节点、新增的节点和被删除的节点。


##### 【重要知识点】`key` 的作用

在 `v-for` 循环中，`key` 属性至关重要。

- **`key` 的用途**：**`key` 是 VNode 的唯一标识。**Diff 算法使用 `key` 来识别新旧列表中的 VNode 是否是同一个。
- **没有 `key` 的情况**：Vue 会采用 "就地复用" 的策略。例如，一个列表 `[A, B, C]` 变成 `[B, A, C]`，Vue 会把 A 的 DOM 内容更新成 B，B 的 DOM 更新成 A，C 不变。如果 A 和 B 是复杂的组件或带有 `input` 元素，这种方式会导致状态错乱。
- **有 `key` 的情况**：Vue 会根据 `key` 建立一个 `key` 到 VNode 的映射。当发现列表顺序变化时，它会准确地知道哪个 `key` 对应的节点移动到了新的位置，然后只执行 **移动 DOM 节点** 的操作，而不是销毁重建或内容替换。这对于性能和组件状态的保持都至关重要。


**最终 `patch` 的结果**：Diff 算法计算出差异后，会生成一个 "补丁" (patch) 列表，其中包含了所有需要执行的真实 DOM 操作，如：

- `CREATE`：创建新节点。
- `UPDATE`：更新节点属性或文本。
- `MOVE`：移动节点位置。
- `REMOVE`：删除节点。

最后，渲染器会统一执行这些 DOM 操作，完成视图的更新。

