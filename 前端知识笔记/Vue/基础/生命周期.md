---
date: 2025-06-18
tags:
  - Vue
---
## 组件生命周期

### 核心概念

**创建** -> **挂载 (显示在页面上)** -> **更新 (数据变化)** -> **销毁 (从页面移除)** 

![生命周期](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%94%B9).png)

### 选项式 vs 组合式

#### 对比概览

- **选项式API (Options API)**: 
  - Vue 2以来的传统方式。生命周期钩子被定义为组件选项对象中的顶级属性，例如`created()`、`mounted()`等。
  - 在这种模式下，`this`上下文被自动绑定为组件实例，使得访问`data`、`props`和`methods`非常直观和方便 。
  ```js
<template>
  <div>
    <h3>生命周期演示 (选项式API)</h3>
    <p>消息: {{ message }}</p>
    <button @click="message = '已更新!'">更新消息</button>
  </div>
</template>

<script>
export default {
  name: 'LifecycleDemoOptions',
  data() {
    console.log('选项式API: data()');
    return { message: '初始值' };
  },
  beforeCreate() {
    console.log('选项式API: beforeCreate() - 实例即将创建');
  },
  created() {
    console.log('选项式API: created() - 实例已创建');
  },
  beforeMount() {
    console.log('选项式API: beforeMount() - 挂载即将开始');
  },
  mounted() {
    console.log('选项式API: mounted() - 挂载完成');
  },
  beforeUpdate() {
    console.log('选项式API: beforeUpdate() - 更新即将开始');
  },
  updated() {
    console.log('选项式API: updated() - 更新完成');
  },
  beforeUnmount() {
    console.log('选项式API: beforeUnmount() - 卸载即将开始');
  },
  unmounted() {
    console.log('选项式API: unmounted() - 卸载完成');
  }
}
</script>
```

- **组合式API (Composition API)**: 
  - Vue 3引入的全新API。生命周期钩子不再是选项，而是需要从`vue`包中显式**导入的函数**，例如 **`onMounted`**、**`onUpdated`** 等，并且**必须在`setup`函数的作用域内同步调用 **。
  - 这种方式极大地提升了代码的组织能力和逻辑复用性，特别是在处理复杂组件时，可以将相关逻辑（如数据获取、其加载状态、以及最终的数据）聚合在一起，而不是分散在 `data`、`methods`和`mounted`等不同选项中 。
```js
  <template>
  <div>
    <h3>生命周期演示 (组合式API)</h3>
    <p>消息: {{ message }}</p>
    <button @click="message = '已更新!'">更新消息</button>
  </div>
</template>

<script setup>
import { ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from 'vue';

console.log('组合式API: setup() - 开始执行');

const message = ref('初始值');

onBeforeMount(() => {
  console.log('组合式API: onBeforeMount() - 挂载即将开始');
});

onMounted(() => {
  console.log('组合式API: onMounted() - 挂载完成');
});

onBeforeUpdate(() => {
  console.log('组合式API: onBeforeUpdate() - 更新即将开始');
});

onUpdated(() => {
  console.log('组合式API: onUpdated() - 更新完成');
});

onBeforeUnmount(() => {
  console.log('组合式API: onBeforeUnmount() - 卸载即将开始');
});

onUnmounted(() => {
  console.log('组合式API: onUnmounted() - 卸载完成');
});

console.log('组合式API: setup() - 执行完毕');
</script>
```



#### `setup()`的核心角色

在组合式API中，**`setup()`函数是绝对的核心。**它在**组件实例被创建之前执行**，甚至**早于`beforeCreate`钩子** 。

- **`setup()`取代`beforeCreate`和`created`**，它完全覆盖了选项式API中`beforeCreate`和`created`两个钩子的功能。所有需要在组件创建时执行的初始化逻辑，比如**设置响应式状态、发起网络请求等**，现在都**直接在`setup()`函数内部完成** 。

- **`this`上下文的缺失**: 这是从选项式API迁移过来的开发者最需要注意的根本性转变。**在`setup()`函数执行期间**，组件实例尚未被完全创建，因此**函数内部无法通过`this`访问到组件实例** 。

- 所有需要引用的  `props`、`context`（包含`attrs`, `slots`, `emit`）都**通过`setup`的参数来获取**。

  ```js
  export default {
    props: {
      title: String
    },
    setup(props,context) {
      console.log(props.title)
        
      // 透传 Attributes（非响应式的对象，等价于 $attrs）
      console.log(context.attrs)
  
      // 插槽（非响应式的对象，等价于 $slots）
      console.log(context.slots)
  
      // 触发事件（函数，等价于 $emit）
      console.log(context.emit)
  
      // 暴露公共属性（函数）
      console.log(context.expose)
    }
  }
  ```

  



### 核心生命周期钩子

- `created` / `setup`
  - **核心:** 组件已创建，**数据 (`data`) 和方法 (`methods`) 可用**，但页面（DOM）还不存在。
  - **主要用途:** **发起 API 请求**，获取组件初始加载所需的数据。
- `mounted` (组合式 API: `onMounted`)
  - **核心:** 组件已成功**渲染到页面上**，可以安全地访问和操作 **DOM**。
  - 主要用途:
    - 初始化需要操作 DOM 的第三方库 (如：图表、地图)。
    - **通过 `$refs` 访问子组件或 DOM 元素**。
- `updated` (组合式 API: `onUpdated`)
  - **核心:** 组件的**数据变化**导致页面 **DOM 更新完成之后**触发。
  - **主要用途:** 执行依赖于新 DOM 结构的操作。
  -  **警告:** **绝对不要**在此钩子内修改数据，否则会造成无限循环更新！
- `unmounted` (组合式 API: `onUnmounted`)
  - **核心:** 组件被**销毁之后**触发。
  - **主要用途:** **执行清理工作**，防止内存泄漏。
    - 清除定时器 (`setInterval`, `setTimeout`)。
    - 移除手动添加的事件监听 (`window.removeEventListener`)。



#### 关键区别：`created` vs `mounted`

- **`created`**: 适合**请求数据**，因为此时数据层已经准备好了。
- **`mounted`**: 适合**操作 DOM**，因为此时页面已经真实存在了。


#### 关键辨析：`updated` vs. `watch` 和 `nextTick()`

- `updated`: 它在组件因*任何*响应式数据变化而完成DOM更新后触发。无法从中得知是哪个具体的数据项导致了更新。
- **`watch` (或 `watchEffect`)**: 精确地侦听一个或多个*特定*的响应式数据源。当且仅当被侦听的数据变化时，它才会触发回调，并提供新值和旧值。
- **`nextTick()`**: 这是一个“**定时工具**”。它并不直接响应数据变化，而是将一个回调函数推迟到下一次DOM更新循环结束之后执行。

##### **决策框架**：

- 当需要响应**特定数据**变化时，**首选`watch`**。
- 当需要在方法中修改数据后，立即访问**更新后的DOM**时，**使用`nextTick()`**。
- 仅当需要响应**任何**导致DOM更新的变化，且无法用`watch`精确定位时，才**考虑`updated`**。