---
date: 2025-06-18
tags:
  - Vue
aliases: []
---
### 父子组件通信

#### `Props`：父组件向子组件传递数据

这是最直接的数据传递方式，**数据流是单向的，从父组件流向子组件。**

- **核心思想**: 父组件通过属性绑定的方式将数据传递给子组件，子组件通过 `defineProps` 宏来接收。
- **详细解释 (重要知识点)**:
  - **单向数据流** ：父组件的更新会流向子组件，但子组件**不应该**直接修改 `props` 的值。
  - **如何修改父组件数据**：**触发一个事件** (`emit`) 通知父组件去修改，遵循“谁的数据谁负责”的原则。
  - **Props 校验：**在定义 `props` 时，强烈建议进行类型校验、设置默认值和必填项。这极大地提高了组件的健壮性和可维护性。


**代码示例：**

父组件 (`Parent.vue`)

```vue
<script setup>
import { ref } from 'vue';
import Child from './Child.vue';

const messageToChild = ref('你好，子组件！');
const userInfo = ref({ name: 'Alice', age: 25 });
</script>

<template>
  <Child :message="messageToChild" :user-info="userInfo" />
</template>
```

子组件 (`Child.vue`)

```vue
<script setup>
// 基础用法
// const props = defineProps(['message', 'userInfo']);

// 推荐：带有类型校验的用法
const props = defineProps({
  message: {
    type: String, // 类型
    required: true, // 是否必填
  },
  userInfo: {
    type: Object,
    // 对象或数组的默认值必须从一个工厂函数返回
    default: () => ({ name: 'Guest', age: 18 }),
  },
});
</script>

<template>
  <p>{{ message }}</p>
  <p>用户: {{ userInfo.name }}, 年龄: {{ userInfo.age }}</p>
</template>
```



#### `emits`：子组件向父组件传递消息（触发事件）

- **核心思想**: 子组件通过 `defineEmits` 宏声明它可以触发的事件，并使用 `emit` 函数来触发这些事件，同时可以携带参数。**父组件通过 `@` 或 `v-on` 来监听这些事件。**
- **详细解释 (重要知识点)**:
  - **事件声明**: 在 Vue 3 的 `<script setup>` 中，使用 `defineEmits` 宏来声明组件会触发哪些事件。
  - **事件载荷 (Payload)**: `emit` 函数的第二个及以后的参数可以作为事件的载荷传递给父组件的监听函数。
  - **事件命名**: 推荐使用 `kebab-case` (短横线分隔) 命名事件，例如 `update-name`。


**代码示例：**

子组件 (`Child.vue`)

```vue
<script setup>
// 声明组件可以触发的事件
const emit = defineEmits(['response', 'update-user-info']);

function sendDataToParent() {
  // 触发事件，并附带数据
  emit('response', '嗨，父组件，我收到消息了！');
}

function updateInfo() {
  emit('update-user-info', { name: 'Bob', age: 30 });
}
</script>

<template>
  <button @click="sendDataToParent">回复父组件</button>
  <button @click="updateInfo">更新用户信息</button>
</template>
```

父组件 (`Parent.vue`)

```vue
<script setup>
import { ref } from 'vue';
import Child from './Child.vue';

const childResponse = ref('');
const userInfo = ref({ name: 'Alice', age: 25 });

function handleResponse(message) {
  childResponse.value = message;
}

function handleUpdate(newUserInfo) {
  userInfo.value = newUserInfo;
}
</script>

<template>
  <Child @response="handleResponse" @update-user-info="handleUpdate" />
  <p>来自子组件的回复: {{ childResponse }}</p>
  <p>更新后的用户信息: {{ userInfo.name }}</p>
</template>
```



#### `v-model`：双向绑定语法糖

- **核心思想**: `v-model` 是 `props` 和 `emits` 组合使用的语法糖，简化了父子组件间双向绑定的代码。
- **详细解释 (重要知识点)**:
  - 在子组件使用`defineModel()`获取props。
  - `defineModel()` 返回的值是一个 ref，它的 `.value` 和父组件的 `v-model` 的值同步
  - 当它被子组件变更了，会触发父组件绑定的值一起更新。


**代码示例**:

父组件 (`Parent.vue`)

```vue
<script setup>
import { ref } from 'vue';
import CustomInput from './CustomInput.vue';

const searchText = ref('initial text');
</script>

<template>
  <CustomInput v-model="searchText" />
  <p>搜索内容: {{ searchText }}</p>
</template>
```

子组件 (`CustomInput.vue`)

```vue
<script setup>
const model= defineModel()	// 获取 prop

function update(event) {
  model.value = event.target.value	// 通过.value更改
}

</script>

<template>
  <input
    :value="model"
    @input="update"
  />
</template>
```



### 跨级组件通信

适用于祖先组件向其所有后代组件传递数据，无论层级有多深。

#### `provide` / `inject`

- **核心思想**:  祖先组件通过 `provide` 提供数据或方法，任何后代组件都可以通过 `inject` 来注入并使用这些数据或方法
- **详细解释 (重要知识点)**:
  - **响应式**: 为了让 `provide` 的数据具有响应性，你应该提供一个 `ref` 或 `reactive` 对象。当祖先组件的数据变化时，所有 `inject` 该数据的后代组件都会自动更新。
  - **非父子关系**: `provide / inject` 不限于父子关系，只要是祖先和后代关系即可。
  - **默认值**: `inject` 可以接受第二个参数作为默认值，以防祖先没有提供该数据。
  - **适用场景**: 非常适合提供全局性的配置，如主题（暗黑/明亮模式）、当前登录用户信息等。


**代码示例**:

祖先组件 (`Ancestor.vue`)

```vue
<script setup>
import { provide, ref } from 'vue';
import Descendant from './Descendant.vue';

const theme = ref('dark');
const changeTheme = () => {
  theme.value = theme.value === 'dark' ? 'light' : 'dark';
};

// 提供响应式数据和方法
provide('theme', theme);
provide('changeTheme', changeTheme);
</script>

<template>
  <Descendant />
</template>
```

后代组件 (`Descendant.vue`)

```vue
<script setup>
import { inject } from 'vue';

// 注入数据和方法，可以提供默认值
const theme = inject('theme', 'light');
const changeTheme = inject('changeTheme', () => {});
</script>

<template>
  <p>当前主题: {{ theme }}</p>
  <button @click="changeTheme">切换主题</button>
</template>
```



### 任意组件通信

适用于兄弟组件、或者两个完全没有直接关系的组件之间的通信。

#### 全局状态管理 ([[Pinia]] / Vuex) (重点)

- **核心思想**: 将共享的状态抽离到一个全局的、唯一的“仓库”（Store）中进行管理。任何组件都可以从中读取状态或触发行为来修改状态。这是构建中大型应用最推荐、最可靠的模式。
- **详细解释 (重要知识点)**:
  - **Pinia**: Vue 官方推荐的新一代状态管理库。
  - **核心概念**:
    - **State**: 驱动应用的数据源（单一数据源）。
    - **Getters**: 类似于 Store 的计算属性，可以对 State 进行派生。
    - **Actions**: 类似于组件的 `methods`，用于处理业务逻辑和修改 State。
  - **优点**:
    - **集中管理**: 状态变更可预测、可追踪。
    - **调试友好**: 配合 Vue Devtools，可以轻松地进行时间旅行调试。
    - **组件解耦**: 组件只需关心如何与 Store 交互，无需关心状态来自哪个组件。
- **适用场景**:
  - 多个视图共享同一个状态（如用户信息、购物车）。
  - 不同组件需要频繁、复杂地交互。
  - 应用规模较大，需要一个清晰的状态管理架构。



### 选择建议

- **首选** `Props` 和 `Emits` 进行父子通信。
- 当跨多层级时，**优先考虑** `Provide / Inject`。
- 当多个视图、兄弟或无关系组件共享状态时，**强烈推荐**使用 `Pinia`。