---
date: 2025-06-19
tags:
  - Vue
aliases:
  - 动态组件
  - 异步组件
---
### 动态组件

动态组件的核心作用是：**在同一个挂载点动态地切换不同的组件**。

#### 基础用法：`<component>` 元素

`<component>`有一个关键的特性 (attribute) `is`。`is` 的值可以是一个**已注册组件的名称**或一个**组件的选项对象**。

```vue
<script setup>
import { ref, shallowRef } from 'vue'
import ComponentA from './components/ComponentA.vue'
import ComponentB from './components/ComponentB.vue'
import ComponentC from './components/ComponentC.vue'

// 使用 ref 来存储当前要显示的组件
const currentComponent = ref(ComponentA)

const tabs = {
  ComponentA,
  ComponentB,
  ComponentC
}
</script>

<template>
  <div class="tabs">
    <button @click="currentComponent = tabs.ComponentA">组件A</button>
    <button @click="currentComponent = tabs.ComponentB">组件B</button>
    <button @click="currentComponent = tabs.ComponentC">组件C</button>
  </div>

  <component :is="currentComponent" />	<!-- 根据currentComponent的值决定渲染哪一个组件 -->
</template>
```

**详细解释：**

- 在上面的例子中，我们定义了 `currentComponent` 这个响应式变量。
- `<component :is="currentComponent">` 会根据 `currentComponent` 变量当前的值来决定渲染哪个组件。
- 当点击按钮时，`currentComponent` 的值会变为 `ComponentA`、`ComponentB` 或 `ComponentC` 的组件对象，Vue 就会自动将对应的组件渲染到 `<component>` 元素的位置。
- **常见应用场景**：Tab 切换、表单向导、根据用户权限显示不同内容等。


#### 保存组件状态：<[[KeepAlive]]>

```vue
<template>
  <div class="tabs">
    </div>

  <KeepAlive>
    <component :is="currentComponent" />
  </KeepAlive>
</template>
```

- **作用**：`<KeepAlive>` 会将其包裹的动态切换的组件缓存到内存中。





### 异步组件

**核心作用**：**将组件的加载推迟到需要渲染它的时候，从而优化性能**。这对于大型应用尤其重要，可以减小初始加载的 JavaScript 包体积（Bundle Size），实现**代码分割 (Code Splitting)**。

#### 基础用法：`defineAsyncComponent`

使用 `defineAsyncComponent` 函数来定义一个异步组件。它的最简用法是接收一个返回 Promise 的加载函数。

```vue
<script setup>
import { defineAsyncComponent } from 'vue'

// 当 AdminPage 组件实际需要被渲染时，才会执行 import() 函数去加载它的代码
    
const AdminPage = defineAsyncComponent(() => 
  import('./components/AdminPage.vue')
)

</script>

<template>
  <AdminPage v-if="isAdmin" />
</template>
```

**详细解释：**
- `import('./path/to/component.vue')` 是一个动态导入语法，它返回一个 Promise。
- `defineAsyncComponent` 接收这个加载器函数，并返回一个包装后的组件定义。
- 只有当 `AdminPage` 组件**第一次**需要被渲染时（例如，`v-if="isAdmin"` 变为 `true` 时），加载器函数才会被调用，相关的代码才会被网络请求加载。
- 加载完成后，Vue 会缓存这个组件定义，后续再次渲染时将直接使用缓存的版本，不会重复加载。
- **核心优势**：减少首屏加载时间。对于那些不总是需要立即显示的组件（如弹窗、特定路由下的页面、需要权限才能访问的模块等），使用异步组件是最佳实践。





#### 重要知识点：加载与错误状态处理

**问题**：网络可能很慢，或者加载组件时可能出错。在组件加载完成前，页面上可能会出现一块空白，用户体验不佳。如果加载失败，应用可能会崩溃。

**解决方案**：`defineAsyncComponent` 接受一个配置对象，允许你指定加载中和加载失败时显示的组件。

```vue
<script setup>
import { defineAsyncComponent } from 'vue'
import LoadingComponent from './components/LoadingComponent.vue'
import ErrorComponent from './components/ErrorComponent.vue'

const AdvancedAsyncComponent = defineAsyncComponent({
  // 加载器函数 (必须)
  loader: () => import('./components/MyAsyncComponent.vue'),

  // 加载异步组件时要使用的组件 (可选)
  loadingComponent: LoadingComponent,

  // 加载失败时要使用的组件 (可选)
  errorComponent: ErrorComponent,

  // 在显示 loadingComponent 之前的延迟，单位 ms (可选)
  // 如果组件加载很快，可以避免加载状态一闪而过
  delay: 200,

  // 如果提供了 timeout，并且加载组件的时间超过了设定值，
  // 将会显示 errorComponent。默认值：Infinity (可选)
  timeout: 3000,
  
})
</script>

<template>
  <AdvancedAsyncComponent />
</template>
```

**详细解释：**

- `loader`: 你的主组件加载逻辑。
- `loadingComponent`: 在 `loader` 完成前，会显示这个组件。这是提升用户体验的关键，让用户知道“正在加载中”。
- `errorComponent`: 如果 `loader` 返回的 Promise 被 reject (加载失败) 或超时，会显示这个组件，用于优雅地处理错误。
- `delay`: 一个非常实用的选项。如果组件在 200ms 内加载完成，`loadingComponent` 就根本不会出现，避免了屏幕闪烁。
- `timeout`: 为加载过程设置一个最长等待时间，防止用户因为网络问题无限等待。





### 动态组件与异步组件的结合使用

这两个概念可以完美地结合在一起，实现一个既灵活又高性能的组件架构。

**场景**：假设你有一个复杂的仪表盘，有多个标签页（总览、用户管理、设置），每个标签页都是一个庞大且复杂的组件。

```vue
<script setup>
import { ref, defineAsyncComponent } from 'vue'

// 使用异步方式定义所有可能用到的组件
const components = {
  Dashboard: defineAsyncComponent(() => import('./views/Dashboard.vue')),
  UserManagement: defineAsyncComponent(() => import('./views/UserManagement.vue')),
  Settings: defineAsyncComponent(() => import('./views/Settings.vue'))
}

const currentView = ref('Dashboard')
</script>

<template>
  <nav>
    <button @click="currentView = 'Dashboard'">总览</button>
    <button @click="currentView = 'UserManagement'">用户管理</button>
    <button @click="currentView = 'Settings'">设置</button>
  </nav>

  <main>
    <KeepAlive>
      <component :is="components[currentView]" />
    </KeepAlive>
  </main>
</template>
```

**这个组合的优势：**
1. **按需加载**：初始加载页面时，只有 `Dashboard` 组件的代码会被下载。只有当你点击“用户管理”时，`UserManagement.vue` 的代码才会被请求。
2. **状态保持**：当你从“用户管理”切换到“设置”，再切换回来时，由于 `<KeepAlive>` 的存在，“用户管理”页面中的筛选条件、分页状态等都会被保留。
3. **灵活性**：你可以轻松地增加新的标签页，只需在 `components` 对象中添加一个新的异步组件定义即可。

