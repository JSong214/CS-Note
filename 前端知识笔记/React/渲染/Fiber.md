---
date: 2025-06-27
tags:
  - React
---
### React Fiber 知识点梳理

#### 1. **【核心动机】为什么需要 Fiber？**

在 Fiber 出现之前，React 的协调（Reconciliation）算法，我们称之为 **Stack Reconciler（栈协调器）**，存在一个核心问题：

- **同步且不可中断**：一旦开始更新过程（调用`setState`后），React 会递归地遍历整个组件树，找出差异并更新 DOM。这个过程是同步执行的，一旦开始就无法停止。
    
- **导致主线程阻塞**：如果组件树非常庞大，或者某个组件的渲染逻辑很复杂，这个递归过程就会长时间占用浏览器的主线程。此时，浏览器将无法响应用户的任何交互（如点击、滚动、输入等），也无法执行动画，导致页面卡顿、掉帧，用户体验极差。
    

**Fiber 的诞生就是为了解决这个问题。** 它的核心目标是实现 **异步可中断的更新**，将一个庞大的更新任务拆解成许多微小的工作单元，然后根据优先级分散到浏览器的多个帧中去执行，从而不阻塞主线程。

---

#### 2. **【核心定义】什么是 Fiber？**

这个问题的答案有两个层面：

**层面一：作为一种数据结构 (Data Structure)**

Fiber **不是** 树，而是树中的一个 **节点**。一个 Fiber 就是一个普通的 JavaScript 对象，它包含了关于一个组件、一个 DOM 节点或其他元素的全部信息。它构成了一个链表结构的树，我们称之为“Fiber 树”。

与 `Virtual DOM` 节点相比，Fiber 节点承载了更多的信息，尤其是用于任务调度和状态管理的信息。

**重要属性详解：**

- `tag`: 标识 Fiber 节点的类型，如 `FunctionComponent`, `ClassComponent`, `HostComponent` (DOM 元素) 等。
    
- `key`: 我们在写列表时常用的 `key`，用于 diff 算法优化。
    
- `type`: 指向组件的构造函数（类组件）或函数本身（函数组件）。对于 DOM 元素，它是一个字符串（如 'div'）。
    
- `stateNode`: 指向该 Fiber 节点对应的真实 DOM 节点、类组件实例或 `null`。
    

---

**【重要】Fiber 树的链表结构：**

这是 Fiber 实现遍历和任务调度的关键。每个 Fiber 节点通过以下三个属性构建起整个树形结构：

- `return` (父节点): 指向其父 Fiber 节点。
    
- `child` (子节点): 指向其第一个子 Fiber 节点。
    
- `sibling` (兄弟节点): 指向其右侧的下一个兄弟 Fiber 节点。
    

**这种链表结构使得 React 可以随时“暂停”遍历，并从上次暂停的地方“恢复”继续遍历，而不再需要依赖函数调用栈的递归。**

```
      (return)
Parent --------> Child1 <-------> Child2
  ^               | (child)   (sibling)
  | (return)      |
  v               v
Grandchild1 <----> Grandchild2
```

---

**层面二：作为一种架构 (Architecture) / 协调算法 (Reconciler)**

Fiber 是 React 内部一套全新的核心算法，它实现了将渲染/协调任务拆分为可独立处理的工作单元（也就是每个 Fiber 节点）。这套架构使得 React 具备了以下能力：

- **增量渲染 (Incremental Rendering)**：将渲染任务拆分成小块，分步完成。
    
- **暂停、中止和复用工作**：可以根据更高优先级的任务（如用户输入）来暂停当前正在进行的渲染工作。
    
- **为不同类型更新分配优先级**：例如，用户输入事件的优先级高于数据请求回来的更新。
    
- **并发能力**：为 `Suspense`、`useTransition` 等新特性提供了底层支持。
    

---

#### 3. **【核心流程】Fiber 是如何工作的？**

Fiber 的工作流程被清晰地划分为两个阶段：**渲染阶段 (Render Phase)** 和 **提交阶段 (Commit Phase)**。这是 Fiber 最核心、最重要的知识点。

**阶段一：渲染/协调阶段 (Render / Reconciliation Phase)**

- **特性**：**异步、可中断**。
    
- **工作内容**：
    
    1. **构建 Work-In-Progress 树**：从根节点开始，遍历整个 Fiber 树。对于每个遍历到的 Fiber 节点，它会根据最新的 `props` 和 `state` 创建一个副本（我们称之为 `workInProgress` 树或“WIP 树”）。
        
    2. **执行 Diff 算法**：比较新的 WIP 节点和旧的（`current`）Fiber 节点，找出变化的类型（增、删、改）。
        
    3. **收集副作用 (Side Effects)**：将所有需要执行的 DOM 操作（或其他副作用）打上一个标记（`effectTag`），并将带有 `effectTag` 的 Fiber 节点收集到一个链表（`effect list`）中。
        
- **为什么可中断？**：这个阶段所做的一切都 **在内存中进行**，不涉及任何真实的 DOM 操作。因此，即使计算过程被中断，也不会导致用户看到渲染不完整的 UI。React 可以随时丢弃计算到一半的 WIP 树，然后在下一次从头开始。
    
- **调度器 (Scheduler)**：React 使用一个内置的调度器模块，通过 `requestIdleCallback` (现在主要用 MessageChannel) 的 polyfill 来检查当前浏览器帧是否还有剩余时间。如果有，就执行一小部分工作单元；如果没有，就把控制权交还给浏览器，等待下一帧的空闲时间。
    

**阶段二：提交阶段 (Commit Phase)**

- **特性**：**同步、不可中断**。
    
- **工作内容**：
    
    1. **遍历 Effect List**：在渲染阶段结束后，React 拥有了一个包含所有副作用的 `effect list`。提交阶段会一次性地、同步地遍历这个列表。
        
    2. **执行 DOM 操作**：根据每个 Fiber 节点的 `effectTag`，执行对应的 DOM 插入、更新或删除操作。
        
    3. **调用生命周期方法/Hooks**：
        
        - 执行如 `componentDidMount`, `componentDidUpdate` 等生命周期方法。
            
        - 执行 `useLayoutEffect` 的回调函数。（`useEffect` 的回调则是在此之后异步调度的）。
            
- **为什么不可中断？**：这个阶段涉及到真实的 DOM 修改。如果中断，用户将会看到一个更新不完整的、可能已经损坏的 UI，这是绝对要避免的。因此，一旦进入提交阶段，就必须一气呵成。
    

---

#### 4. **【重要机制】双缓冲技术 (Double Buffering)**

这是一个非常形象的比喻，用来解释 Fiber 如何在不影响当前 UI 的情况下准备下一次更新。

- **Current 树**：当前屏幕上显示的内容所对应的 Fiber 树。它是“旧”树。
    
- **Work-In-Progress (WIP) 树**：在内存中正在构建的、即将要渲染的 Fiber 树。它是“新”树。
    

React 维护着这两棵树。所有工作都在 WIP 树上进行（渲染阶段）。当 WIP 树构建完成，并且所有副作用都收集完毕后，在提交阶段，React 会 **一次性地** 将 WIP 树切换为 Current 树（通过修改一个指针 `current` 指向它）。

这个机制的好处是：

1. **平滑更新**：所有变更都在内存中准备好，然后一次性应用到 DOM，避免了 UI 闪烁。
    
2. **状态复用**：在下一次更新时，新的 WIP 树可以直接复用当前 Current 树的节点，而不是每次都重新创建，极大地提升了性能。每个 Fiber 节点上都有一个 `alternate` 属性，指向它在另一棵树中的对应节点，实现了两棵树之间的快速切换和复用。
    

---

### **知识点总结与笔记要点**

1. **背景 (Why)**：解决旧版 React 同步更新导致的 **主线程阻塞** 和 **页面卡顿** 问题。
    
2. **核心概念 (What)**：
    
    - **Fiber 是一个节点**：一个带有调度信息的 JS 对象，通过 `return`, `child`, `sibling` 形成链表树。
        
    - **Fiber 是一种架构**：实现了 **异步可中断** 更新的核心算法。
        
3. **两大阶段 (How)**：
    
    - **渲染阶段 (可中断)**：在内存中构建 `WIP` 树、`diff` 差异、收集 `effect`。**核心是找出“要做什么”**。
        
    - **提交阶段 (不可中断)**：遍历 `effect list`，一次性地更新 DOM、调用生命周期。**核心是“去执行”**。
        
4. **关键机制**：
    
    - **双缓冲 (Double Buffering)**：使用 `current` 树和 `workInProgress` 树，在内存中完成所有准备工作再上屏，实现平滑高效的更新。
        
    - **优先级调度**：内置 Scheduler，可以区分高低优先级任务（如用户输入 vs 数据获取），实现任务的暂停和恢复。
        
5. **带来的好处**：
    
    - **更好的用户体验**：应用响应更及时，动画更流畅。
        
    - **解锁新特性**：为 `Concurrent Mode`, `Suspense`, `useTransition` 等高级功能提供了底层支持。
        