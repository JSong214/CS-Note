---
date: 2025-06-27
tags:
  - React
---
**[[Fiber]] 本身不是对比算法，而是承载和调度“对比算法”的新架构。**

我们可以这样来理解它们之间的关系：

- **虚拟节点对比 (Diffing Algorithm)**：这是指 React **“找出差异”** 的那套逻辑规则。比如，比较两个节点的 `type` 是否相同，`key` 是否相同，遍历子节点等。这套核心比较逻辑在 Fiber 出现前后并没有颠覆性的改变。
    
- **Fiber**：这是指 React **“如何执行对比”** 的全新方式和底层机制。
    

让我为你详细拆解一下：

#### 1. 旧的模式：Stack Reconciler (栈协调器)

在 Fiber 出现之前，React 是这样工作的：

- **执行方式**：当 `setState` 被调用时，React 会启动一个 **同步的、递归的** 过程来执行 Diffing 算法。
    
- **过程**：它会像一个深度优先搜索的函数调用一样，从根节点开始，递归地遍历整个虚拟 DOM 树，找出所有差异，然后一次性更新到真实 DOM 上。
    
- **问题**：这个递归调用发生在单一的函数调用栈（Stack）中，因此是 **不可中断** 的。如果组件树很深很大，这个过程就会耗时很长，从而阻塞主线程。
    

**可以理解为：** Diffing 算法被封装在一个巨大的、必须一次性执行完的函数里。

#### 2. 新的模式：Fiber Reconciler (纤维协调器)

Fiber 架构下，工作方式完全不同了：

- **执行方式**：Diffing 的过程被拆解成了无数个微小的工作单元（Unit of Work）。**每一个 Fiber 节点就是一个工作单元**。
    
- **过程**：
    
    1. React 从根 Fiber 节点开始处理。
        
    2. 它处理完一个 Fiber 节点（即，将旧 Fiber 节点和新 JSX 元素进行对比，并生成新的子 Fiber 节点），然后并 **不会立即递归处理子节点**。
        
    3. 相反，它会检查浏览器当前帧是否还有剩余时间。
        
    4. **如果有时间**，它就继续处理下一个工作单元（比如第一个子节点）。
        
    5. **如果没时间，或者有更高优先级的任务（如用户输入）进来**，它就会暂停当前的工作，将控制权交还给浏览器。它会记住自己“工作到了哪里”。
        
    6. 等浏览器空闲下来后，再从上次暂停的地方恢复工作。
        
- **结果**：整个 Diffing 过程（也就是“渲染阶段”）变成了 **异步可中断** 的。
    

**可以理解为：** Diffing 算法的执行被“打碎”了。不再是一个大函数，而是变成了“处理一个节点，然后看看要不要歇一会儿，再处理下一个节点……”的循环。Fiber 节点本身就像一个书签，记录了工作的进度和上下文，使得“暂停”和“恢复”成为可能。

---

### 总结与类比

- **Diffing 算法是“要做的家务清单”**（比如：洗碗、扫地、拖地）。
    
- **旧的 Stack Reconciler 是“一个执着的人”**：他拿到清单后，会把自己锁在房间里，不吃不喝直到把所有家务做完才能出来。如果这时有人敲门，他也不会理睬。
    
- **新的 Fiber Reconciler 是“一个聪明的人”**：他拿到清单后，先去洗碗（处理一个 Fiber 节点）。洗完后，他会去门口看看有没有紧急的事（检查主线程是否有更高优先级的任务）。如果有，他就先去处理紧急的事；如果没有，他就回来继续扫地（处理下一个 Fiber 节点）。
    


**总结：**
**新旧虚拟节点的对比（Diffing）这个动作，是发生在 Fiber 的“渲染阶段”中的。Fiber 提供了一套机制，让这个对比过程可以被拆分、被中断、被调度，而不再是过去那种“一条道走到黑”的同步递归。**