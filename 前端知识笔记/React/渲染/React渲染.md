---
date: 2025-06-26
tags:
  - React
---
### **React 渲染流程知识点梳理**

React 的核心思想是**声明式编程**：你只需要告诉 React 你期望 UI 在特定状态下应该是什么样子，剩下的事情由 React 负责。这个“负责”的过程，就是它的渲染流程。其根本目标是**高效、可预测地更新用户界面**，并尽可能减少对真实 DOM 的直接操作（因为这很耗时）。

整个流程可以大致分为三个主要阶段：

1. **触发 (Trigger)**：启动渲染的信号。
2. **渲染 (Render)**：计算出 UI 的新状态，生成新的虚拟 DOM。
3. **提交 (Commit)**：将变化应用到真实 DOM 上。

下面我们来详细拆解每个阶段和其中的重要知识点。

------


### **第一阶段：触发更新 (Trigger)**

任何 UI 的变化都始于一个“触发”。在 React 中，常见的触发条件有：

1. **首次渲染 (Initial Render)**：
   - 这是应用的第一次渲染，通过 `ReactDOM.createRoot(rootElement).render(<App />)` 启动。React 会创建整个组件树的 DOM 节点。
2. **状态更新 (State Update)**：
   - 这是最常见的触发方式。当使用 `useState` 的 `set` 函数（如 `setCount(count + 1)`) 或 `useReducer` 的 `dispatch` 函数时，React 会安排一次新的渲染。
3. **Props 变更 (Props Change)**：
   - 当一个父组件重新渲染时，它可能会向其子组件传递新的 `props`。如果子组件接收到的 `props` 发生了变化，也会触发该子组件的重新渲染。
4. **Context 变更 (Context Change)**：
   - 当一个 `Provider` 的 `value` 发生变化时，所有消费（`useContext`）该 Context 的组件都会被触发重新渲染。

------


### **第二阶段：渲染阶段 (Render Phase)**

当更新被触发后，React 进入渲染阶段。**这个阶段的核心任务是“计算”出需要显示什么，但并不会真正修改 DOM**。

1. **执行组件代码**：
   - React 会从被触发更新的组件开始，向下遍历其子组件树。
   - 对于每个组件，React 会调用其函数本身（如果是函数组件）或 `render()` 方法（如果是类组件）。
   - 这些函数调用的返回值是一棵由 React 元素（Element）组成的树。
2. **生成新的虚拟 DOM (Virtual DOM)**：
   - 上一步返回的 React 元素树就是我们常说的**虚拟 DOM**。它是一个轻量级的、存在于内存中的 JavaScript 对象，用来描述 UI 的结构和状态。

> **重要提示**：在现代 React (v16+) 中，渲染阶段是**可以被中断的**。这是实现并发模式（Concurrent Mode）的关键。如果浏览器有更高优先级的任务（如用户输入），React 可以暂停当前的渲染工作，处理完紧急任务后再回来继续。

------


### **第三阶段：提交阶段 (Commit Phase)**

渲染阶段生成了新的虚拟 DOM 树，现在 React 需要将这些变化应用到真实的浏览器 DOM 上。这个阶段包含了两个核心步骤：协调和提交。

#### **1. 协调 (Reconciliation) - Diffing 算法**

在应用变更之前，React 需要知道具体哪里变了。这个过程就是“协调”，其核心是 **Diffing 算法**。

- React 会比较**本次渲染生成的新虚拟 DOM 树**和**上一次渲染的旧虚拟 DOM 树**（在 Fiber 架构中，这对应于比较 work-in-progress tree 和 current tree）。
- 通过对比，React 会生成一个“变更列表”，其中包含了所有需要对真实 DOM 进行的操作，例如：
  - `{ type: 'CREATE', domNode: ... }` (创建新 DOM 节点)
  - `{ type: 'UPDATE', domNode: ..., attributes: ... }` (更新 DOM 节点属性)
  - `{ type: 'DELETE', domNode: ... }` (删除 DOM 节点)

#### **2. 提交 (Commit)**

- React 拿到这个“变更列表”后，进入提交阶段。
- **这个阶段是同步且不可中断的**，以保证 UI 的一致性，避免用户看到更新了一半的奇怪界面。
- React 会一次性地、批量地执行所有 DOM 操作。
- DOM 更新完成后，会触发生命周期方法或 Hooks，主要是：
  - `useLayoutEffect` 的回调函数会**同步**执行。
  - `useEffect` 的回调函数会**异步**执行，不会阻塞浏览器渲染。

------

### **⭐⭐ 重要知识点详解 ⭐⭐**

#### **1. 虚拟 DOM (Virtual DOM)**

- **是什么？**
  - 一个用来描述真实 DOM 的 JavaScript 对象。它包含了元素的类型 (`div`, `span`)、属性 (`className`, `id`) 和子元素。
- **为什么需要它？**
  - **性能**：直接操作真实 DOM 非常昂贵，因为它会触发浏览器的重排（reflow）和重绘（repaint）。虚拟 DOM 将多次状态变更的计算和对比都放在内存中进行，最后只对真实 DOM 进行一次最小化的、批量的更新。
  - **跨平台**：虚拟 DOM 是一个抽象层，它不直接依赖于浏览器环境。这使得 React 可以被用于其他平台，比如移动端（React Native）。

#### **2. Reconciliation (协调) & Diffing 算法**

为了高效对比两棵树，React 的 Diffing 算法建立在两个简化的假设之上，使得算法复杂度从 O(n3) 优化到 O(n)：

1. **不同类型的元素会产生不同的树**：

   - 如果一个元素的类型从 `<div>` 变成了 `<span>`，React 不会去尝试对比它们的内容，而是直接销毁旧的 `<div>` 及其所有子节点，然后创建一个新的 `<span>`。

2. **开发者可以通过 `key` 属性来标识稳定的元素**：

   - 在渲染一个列表（如通过 `map` 遍历数组）时，`key` 属性至关重要。

   - **没有 `key` 的情况**：如果你在列表的开头插入一个新元素，React 会默认认为你修改了列表中的每一个元素，导致性能下降。

     ```
     // 之前: <li>A</li> <li>B</li>
     // 之后: <li>C</li> <li>A</li> <li>B</li>
     // React 的错误理解：将 A 改成 C，将 B 改成 A，并新增一个 B。
     ```

   - **有 `key` 的情况**：React 通过 `key` 来识别每个元素。它会知道 A 和 B 只是位置移动了，而 C 是一个新插入的元素。

     ```
     // 之前: <li key="a">A</li> <li key="b">B</li>
     // 之后: <li key="c">C</li> <li key="a">A</li> <li key="b">B</li>
     // React 的正确理解：仅需插入一个 key 为 "c" 的新 li。
     ```

   - **结论**：`key` 必须在兄弟节点之间是**唯一且稳定**的。**永远不要使用数组的索引 `index` 作为 `key`**，除非列表是完全静态的。

#### **3. [[Fiber]] 架构**

- **是什么？**
  - 自 React 16 起引入的新的协调引擎，是对核心算法的重写。
- **为什么需要它？**
  - 旧的协调算法（称为 Stack Reconciler）是递归的，一旦开始就不能停止，如果组件树很大，会长时间占用浏览器主线程，导致页面卡顿、掉帧。
- **Fiber 如何解决问题？**
  - **可中断、可恢复**：Fiber 将渲染工作拆分成一个个小的“工作单元”（即 Fiber 节点）。每完成一个单元，React 就可以检查是否有更高优先级的任务，并选择性地让出主线程。
  - **优先级调度**：可以为不同的更新分配不同的优先级（例如，用户输入 > 动画 > 数据请求）。
  - 它为并发模式、`Suspense` 等高级功能提供了基础。

------



### **总结：完整的渲染流程图**

1. **触发**
   - `setState()` / `dispatch()` / 新 `props` ...

   ↓

2. **渲染阶段 (可中断)**
   - React 从根组件开始，调用组件函数，计算新的 UI 状态。
   - 生成一份新的**虚拟 DOM** (React 元素树)。

   ↓

3. **协调阶段 (Diffing)**
   - React 对比**新旧两棵虚拟 DOM 树**。
   - 找出所有差异，生成一个**变更列表**。

   ↓

4. **提交阶段 (不可中断)**
   - React 将变更列表中的所有操作**一次性应用到真实 DOM**。
   - DOM 更新完成。

   ↓

5. **副作用 (Effects)**
   - 同步执行 `useLayoutEffect` 回调。
   - 异步执行 `useEffect` 回调。
