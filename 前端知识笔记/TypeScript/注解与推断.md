---
date: 2025-06-20
tags:
  - TypeScript
---
### 类型注解

**明确地告诉**TypeScript 某个变量、函数参数或返回值应该是什么类型。

- **语法：**
  - 使用**冒号 `:`** 后面跟上类型名称。

  - **变量注解**:
    ```ts
    let name: string = 'Alice';
    let age: number;
    age = 30;
    ```

  - **函数参数与返回值注解**:
    ```ts
    // 参数 'a' 和 'b' 必须是 number 类型
    // 这个函数的返回值也必须是 number 类型
    function add(a: number, b: number): number {
        return a + b;
    }
    ```
    **注意**：函数返回值的注解是写在参数列表 `()` 后面的。对于返回 `undefined` 的函数，通常使用 `void` 类型。

  - **对象注解**:
    ```ts
    let person: { name: string; age: number };
    
    person = {
        name: 'Bob',
        age: 42
    };
    ```



### 类型推断

**不明确指定**类型，TypeScript 编译器会根据上下文**自动分析并推断**出它应该是什么类型。

- **它是如何工作的？**
  - TypeScript 会在**变量初始化**、**函数返回值**等地方，根据等号右侧的值或 `return` 语句的表达式来自动推断类型。


- **主要的推断场景 (重要)**

  1. 基础类型推断

     这是最简单、最常见的推断。当你声明一个变量并立即用一个字面量（如字符串、数字、布尔值）初始化它时，TS 会自动推断其类型。

     ```ts
     let name = 'Alice'; // TS 推断 name 的类型为 string
     let age = 30;      // TS 推断 age 的类型为 number
     let isLoading = false; // TS 推断 isLoading 的类型为 boolean
     
     // name = 123; // 错误 ❌: Type 'number' is not assignable to type 'string'.
     ```

     **最佳实践**: 在这种情况下，`let name: string = 'Alice';` 是**冗余的**，应避免这样写。让推断发挥作用。

  2. 最佳通用类型推断

     当一个数组或变量由多种类型的值构成时，TypeScript 会尝试找到一个最合适的“通用类型”。

     ```ts
     // arr 被推断为 (string | number)[]
     let arr = [1, 'hello', 2]; 
     
     // 如果找不到最佳通用类型，会推断为联合类型
     let data = [1, 'text', null]; // TS 推断 data 的类型为 (string | number | null)[]
     ```

  3. 上下文类型推断

     这是一个非常强大且重要的概念。TypeScript 会利用一个表达式所在的“上下文”来推断其类型。这通常发生在处理**回调函数**或**事件处理**时。

     ```ts
     const numbers = [1, 2, 3];
     
     // 在 forEach 的回调函数中，我们没有给 'n' 加注解
     // 但 TS 知道 numbers 是一个 number[] 数组
     // 因此它根据上下文推断出 'n' 的类型是 number
     numbers.forEach(n => {
         console.log(n.toFixed(2)); // 可以安全地调用 number 的方法
     });
     
     // 另一个例子：事件处理
     window.onmousedown = function(mouseEvent) {
         // 同样，我们没有给 mouseEvent 加注解
         // 但 TS 知道 onmousedown 事件的回调参数是 MouseEvent 类型
         // 因此它推断出 mouseEvent 的类型是 MouseEvent
         console.log(mouseEvent.button); // 可以安全地访问 MouseEvent 的属性
     };
     ```

  4. 函数返回值的推断

     除非你显式注解，否则 TypeScript 会根据函数内部的 `return` 语句来推断返回类型。

     ```ts
     // TS 分析函数体，发现 a + b 的结果是 number
     // 因此推断出这个函数的返回类型是 number
     function add(a: number, b: number) { 
         return a + b;
     }
     ```


**最佳实践**: 对于一些简单的、私有的函数，依赖返回值推断是很好的。但对于**公共 API** 或**复杂的函数**，**推荐显式注解返回类型**。这样做有两大好处：
1. **代码更清晰**：调用者一眼就能看出函数返回什么。
2. **防止意外修改**：如果你不小心在函数中返回了错误类型的值，TypeScript 会立刻报错，而不是默默地改变了推断的返回类型，从而避免了潜在的 Bug。



### 最佳实践与总结

**黄金法则**：

**如果 TypeScript 能够准确、清晰地推断出类型，就让它推断。** **在编译器无法推断、推断不准确，或者为了代码清晰性和 API 稳定性需要明确定义时，使用类型注解。**

示例：何时注解，何时不注解

```ts
// ❌ 冗余的注解：TS 可以完美推断
let name: string = 'Bob'; 
let age: number = 30;
let isActive: boolean = true;

// ✅ 简洁的推断：让 TS 工作
let name = 'Bob';       // 推断为 string
let age = 30;          // 推断为 number
let isActive = true;   // 推断为 boolean

// ---

// ✅ 必要的注解：函数参数
function greet(person: string, date: Date): void {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

// ✅ 必要的注解：变量先声明后赋值
let apiResponse: { data: any[]; error: string | null };
async function fetchData() {
    const res = await fetch('/api/data');
    const json = await res.json();
    apiResponse = json;
}
```



