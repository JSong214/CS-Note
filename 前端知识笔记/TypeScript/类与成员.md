---
date: 2025-06-25
tags:
  - TypeScript
---
## 类([[Class]])与成员


### 1.访问修饰符 (Access Modifiers)

这是 TypeScript 相对于 JavaScript 在类方面最核心的增强之一。它控制着类成员（属性和方法）在不同位置的可访问性。

| 修饰符 | 关键字      | 描述                                                         |
| ------ | ----------- | ------------------------------------------------------------ |
| 公共   | `public`    | **（默认）** 任何地方都可以访问。类的内部、子类、类的实例都可以访问。 |
| 受保护 | `protected` | 只能在**当前类及其子类**的内部访问。类的实例无法访问。       |
| 私有   | `private`   | 只能在**当前类**的内部访问。子类和类的实例都无法访问。       |

**详细解释与示例:**

```ts
class Animal {
    public name: string; // public 是默认的，可以不写
    protected age: number;
    private weight: number;

    constructor(name: string, age: number, weight: number) {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }

    public makeSound(): void {
        console.log("Some generic sound");
        console.log(`Weight is ${this.weight}kg`); // 在类内部可以访问 private 成员
    }
}

class Dog extends Animal {
    constructor(name: string, age: number, weight: number) {
        super(name, age, weight);
    }

    public getAge(): void {
        // 在子类中可以访问 protected 成员 age
        console.log(`${this.name}'s age is ${this.age}`); 
    }

    public getWeight(): void {
        // 错误! 属性“weight”为私有属性，只能在类“Animal”中访问。
        // console.log(this.weight); 
    }
}

const myDog = new Dog("Buddy", 5, 15);
console.log(myDog.name);    // OK, name 是 public
myDog.makeSound();          // OK, makeSound 是 public
myDog.getAge();             // OK

// console.log(myDog.age);  // 错误! 属性“age”受保护，只能在类“Animal”及其子类中访问。
// console.log(myDog.weight); // 错误! 属性“weight”为私有属性。
```

**重点提示**:

- TypeScript 的 `private` 修饰符是**编译时**的检查，它在编译成 JavaScript 后，这些限制就不存在了。
- ES2022+ 引入了**运行时**的私有字段，使用 `#` 前缀（例如 `#weight`）。它与 TypeScript 的 `private` 不同，是真正的运行时私有。在 TypeScript 中你也可以使用 `#`。



### 2.`readonly` 修饰符

`readonly` 用于将一个属性设置为只读。只读属性必须在**声明时**或**构造函数 (`constructor`) 中**被初始化。之后就不能再被修改。

```ts
class Person {
    readonly id: number;
    name: string;

    constructor(id: number, name: string) {
        // 只读属性可以在构造函数中赋值
        this.id = id;
        this.name = name;
    }

    changeId() {
        // 错误! 无法分配到 "id" ，因为它是只读属性。
        // this.id = 9527; 
    }
}

const p = new Person(1001, "Alice");
p.name = "Bob"; // OK

// p.id = 1002; // 错误!
```

**重点提示**: `readonly` 提供了不变性（immutability）的保障，这在很多编程场景中非常有用，可以防止意外的修改。



### 3.存取器 (Getters & Setters)

存取器允许你像访问属性一样调用方法，这对于实现数据的封装和验证非常有用。

- `get`: 读取属性值时触发。必须有返回值。
- `set`: 设置属性值时触发。接收一个参数。

```ts
class Employee {
    private _fullName: string = "";

    // Getter
    get fullName(): string {
        console.log("Getter called");
        return this._fullName;
    }

    // Setter
    set fullName(newName: string) {
        console.log("Setter called");
        if (newName && newName.length > 2) {
            this._fullName = newName;
        } else {
            console.error("Name is too short!");
        }
    }
}

const emp = new Employee();
emp.fullName = "Li"; // Setter called, Name is too short!
emp.fullName = "Li Lei"; // Setter called
console.log(emp.fullName); // Getter called, "Li Lei"
```

**重点提示**: 使用存取器可以很好地控制对类内部数据的访问逻辑，对外暴露简单的属性接口，而内部实现可以很复杂。通常，存取器操作的是一个私有属性（如 `_fullName`）。





### 4.静态成员 (Static Members)

静态成员属于**类本身**，而不是类的实例。访问它们需要通过类名，而不是实例对象。`static` 关键字可以用于属性和方法。

```ts
class Circle {
    static PI: number = 3.14159;

    static calculateArea(radius: number): number {
        return this.PI * radius * radius;
    }
}

// 直接通过类名访问静态成员
console.log(Circle.PI); // 3.14159
console.log(Circle.calculateArea(5)); // 78.53975

const circleInstance = new Circle();
// console.log(circleInstance.PI); // 错误！静态成员不能在实例上访问
```

**重点提示**: 静态成员常用于定义工具方法或全局常量，比如 `Math.PI` 和 `Math.random()` 就是典型的例子。





### 5.抽象类 (Abstract Classes)

抽象类是作为其他派生类的基类使用的。它们**不能被直接实例化**。抽象类可以包含已经实现的成员，也可以包含**抽象成员**。

- `abstract` 关键字用于定义抽象类和抽象方法。
- 抽象方法只定义方法的签名，没有具体的实现。
- **派生类（子类）必须实现所有的抽象方法**。

```ts
abstract class Shape {
    // 抽象类可以有已实现的成员
    constructor(public color: string) {}

    // 抽象方法，没有方法体
    abstract getArea(): number;

    display(): void {
        console.log(`This is a ${this.color} shape.`);
    }
}

// const shape = new Shape("red"); // 错误! 无法创建抽象类的实例。

class Rectangle extends Shape {
    constructor(color: string, private width: number, private height: number) {
        super(color);
    }

    // 必须实现父类的抽象方法
    getArea(): number {
        return this.width * this.height;
    }
}

const rect = new Rectangle("blue", 10, 20);
rect.display(); // "This is a blue shape."
console.log(rect.getArea()); // 200
```

**重点提示**: 抽象类用于定义一种“契约”或“模板”，强制所有子类都遵循某种结构，同时又能提供一些公共的实现。它与接口（Interface）有相似之处，但抽象类可以包含具体实现。





### 6.类与接口 (`implements`)

接口（Interface）可以用来描述一个对象的“形状”。类可以使用 `implements` 关键字来实现一个或多个接口，这保证了该类至少拥有接口所定义的全部成员。

```ts
interface Loggable {
    log(message: string): void;
}

interface Serializable {
    serialize(): string;
}

// 一个类可以实现多个接口
class ConsoleLogger implements Loggable, Serializable {
    log(message: string): void {
        console.log(message);
    }
    
    serialize(): string {
        return JSON.stringify({ class: "ConsoleLogger" });
    }
}

const logger = new ConsoleLogger();
logger.log("Hello, TypeScript!");
```

**重点提示**:

- `extends` (继承): 从一个基类获取实现。一个类只能继承一个基类。
- `implements` (实现): 保证类符合接口的“形状”或“契约”。一个类可以实现多个接口。