---
date: 2025-06-20
tags:
  - TypeScript
aliases:
  - 元组
---
### 数组 (Array)

数组是 TypeScript 中最常用的数据结构之一，用于表示一个**类型统一**的列表。

#### 声明与创建

有两种等价的声明方式：

##### 方式一：类型 + 方括号（推荐，更简洁）

```ts
// 声明一个数字数组
let numbers: number[];

// 声明一个字符串数组
let names: string[];

// 创建并初始化
numbers = [1, 2, 3, 4, 5];
names = ["Alice", "Bob", "Charlie"];
```


##### 方式二：使用泛型 `Array<T>`

```ts
// 声明一个数字数组
let numbers: Array<number>;

// 声明一个布尔值数组
let flags: Array<boolean>;

// 创建并初始化
numbers = [10, 20, 30];
flags = [true, false, true];
```


#### 重要特性：类型纯净性

这是 TypeScript 数组与 JavaScript 数组最大的区别。**一旦声明了类型，数组内就只能包含该类型的元素**，否则 TypeScript 编译器会报错。

```ts
let scores: number[] = [100, 99, 98];

scores.push(97); // 正确

// scores.push("A+"); 
// 编译时会报错：Argument of type 'string' is not assignable to parameter of type 'number'.
```


#### 数组元素的类型推断

如果你在声明时直接初始化，TypeScript 会自动推断出数组的类型。

```ts
// TypeScript 会自动推断出 a 的类型是 number[]
let a = [1, 2, 3];

// a.push("hello"); // 同样会报错
```


#### 特殊情况：[[组合类型|联合类型]]数组

如果你需要一个数组可以包含多种类型的元素，可以使用**联合类型**。

```ts
// 这个数组的每个元素可以是 number 或 string
let mix: (number | string)[];

mix = [1, "hello", 2, "world"];
mix.push(3);
mix.push("!");

// mix.push(true); // 报错，因为 boolean 不在 (number | string) 中
```


#### 常用操作

数组的操作与 JavaScript 完全一致，常用的有：
- **访问元素**: `numbers[0]`
- **修改元素**: `names[1] = "Barbara"`
- **获取长度**: `numbers.length`
- **遍历**: `forEach`, `for...of`, `map`, `filter`, `reduce` 等。

```ts
let numbers: number[] = [1, 2, 3];

// 遍历
numbers.forEach(num => console.log(num * 2));

// map: 返回一个新数组
const doubledNumbers = numbers.map(num => num * 2); // [2, 4, 6]
```



### 元组 (Tuple)

元组可以被看作是一种结构更强的数组。它精确地定义了数组中**每个位置上元素的类型**，并且**长度是固定的**。

#### 声明与创建

元组的声明使用方括号包裹一系列类型。

```ts
// 声明一个元组，第一个元素是 string，第二个是 number
let person: [string, number];

// 初始化，必须严格按照类型顺序和数量
person = ["Alice", 30]; // 正确

// person = [30, "Alice"]; 
// 编译时报错：Type 'number' is not assignable to type 'string'.

// person = ["Alice"];
// 编译时报错：Type '[string]' is not assignable to type '[string, number]'. Source has 1 element(s) but target requires 2.
```


#### 重要特性：固定长度和类型对应

这是元组的核心价值所在。它常用于表示一组固定的、有结构的数据，例如：
- **函数返回值**：一个函数可能需要同时返回一个状态和结果。
- **键值对**：`["id", 12345]`
- **坐标**：`[10, 20]`

```ts
// 使用元组作为函数返回值
function fetchUser(): [string, number] {
  // ... 假设这里是API请求
  const name = "John Doe";
  const id = 123;
  return [name, id];
}

const [userName, userId] = fetchUser(); // 使用解构赋值，非常方便
console.log(userName); // "John Doe"
console.log(userId); // 123
```

#### 访问元素与类型安全

访问元组元素时，TypeScript 知道每个索引对应的确切类型。

```ts
let myTuple: [string, number, boolean] = ["hello", 10, true];

const str = myTuple[0]; // str 的类型被推断为 string
const num = myTuple[1]; // num 的类型被推断为 number

console.log(str.toUpperCase()); // 正确，string 有 toUpperCase 方法
// console.log(num.toUpperCase()); // 编译时报错，number 没有 toUpperCase 方法
```

**对比数组**: 如果是一个联合类型数组 `(string | number | boolean)[]`，访问 `arr[0]` 时，TypeScript 只知道它是三者之一，无法直接调用特定类型的方法。


#### 元组的“越界”问题（重要知识点）

这是一个元组中比较特殊的行为。虽然元组的长度是固定的，但 TypeScript **允许**你使用 `push`、`pop` 等方法向元组中添加或删除元素。

**但是**，添加的元素类型必须是元组中**已经声明过的联合类型**。

```ts
let myTuple: [string, number] = ["hello", 10];

myTuple.push(20); // 正确，因为 number 是元组类型 (string | number) 的一部分
myTuple.push("world"); // 正确，因为 string 也是

// myTuple.push(true); 
// 编译时报错：Argument of type 'boolean' is not assignable to parameter of type 'string | number'.
```

**为什么会这样？** 这是 TypeScript 设计上的一个权衡。在底层，元组就是 JavaScript 数组，而 `push` 是数组的原生方法。TypeScript 为了保持与 JavaScript 的兼容性，并没有完全禁止这个行为，但通过类型检查提供了保护。

**如何创建真正不可变的元组？** 使用 `readonly` 修饰符。这是最佳实践。



### 进阶与相关知识点

#### 只读修饰符 (`readonly`)

`readonly` 可以用于数组和元组，创建出不可变的数据结构。

**只读数组 (`readonly string[]`)**
- 数组本身不能被修改，任何会改变数组内容的方法（如 `push`, `pop`, `splice`）都会报错。
  ```ts
  const readOnlyNumbers: readonly number[] = [1, 2, 3];
  
  // readOnlyNumbers.push(4);      // 报错
  // readOnlyNumbers[0] = 0;       // 报错
  // readOnlyNumbers.length = 1;   // 报错
  
  // 但可以调用不改变原数组的方法
  const sliced = readOnlyNumbers.slice(1); // 正确
  ```



**只读元组 (`readonly [string, number]`)**
- 提供了最强的不可变性，不仅元素位置上的值不能修改，也不能使用 `push` 等方法。
  ```ts
  const readOnlyPerson: readonly [string, number] = ["Dave", 35];
  
  // readOnlyPerson[0] = "David"; // 报错
  // readOnlyPerson.push(100);    // 报错
  ```

  **强烈建议**：当你希望元组作为一种固定不变的数据结构时，总是使用 `readonly`。

  
#### 解构赋值

解构赋值与数组和元组的配合使用非常普遍，能让代码更具可读性。

```ts
// 数组解构
const colors = ["red", "green", "blue"];
const [firstColor, secondColor] = colors;
console.log(firstColor); // "red"

// 元组解构 (更有意义，因为每个位置的含义是固定的)
const product: [string, number, number] = ["Laptop", 1200, 5];
const [productName, price, stock] = product;
console.log(`Product: ${productName}, Price: $${price}, Stock: ${stock}`);
```





