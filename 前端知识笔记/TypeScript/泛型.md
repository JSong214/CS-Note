---
date: 2025-06-25
tags:
  - TypeScript
---
## 泛型 (Generics) 

**泛型（Generics）的概念**：泛型允许你创建能够**适用于多种类型**而非单一类型的组件（如函数、类、接口），同时保持完整的类型安全 。它使用一个**类型参数**（通常用 **`<T>`** 表示）作为占位符，这个占位符代表的实际类型将在组件被使用时确定。

### 泛型入门：泛型函数

1. 问题背景：为什么需要泛型？
   假设我们需要一个 `identity` 函数，它接收一个参数并返回该参数本身。
   - 有泛型的写法（类型不安全或不复用）：

     ```ts
     // 写法1：使用 any，丢失了类型信息，不安全
     function identity(arg: any): any {
         return arg;
     }
     // 调用时，返回值的类型也是 any，无法获得类型提示和保护
     let output = identity("myString"); // output 的类型是 any
     
     // 写法2：为每种类型创建函数，代码冗余，不复用
     function identityNumber(arg: number): number {
         return arg;
     }
     function identityString(arg: string): string {
         return arg;
     }
     ```

2. **泛型函数的解决方案**

   通过引入一个**类型变量**（通常用 `T` 表示，但任何合法标识符都可以），我们可以创建一个通用的 `identity` 函数。

   ```ts
   function identity<T>(arg: T): T {
       return arg;
   }
   ```

   **【重点解释】**
   - _**`<T>`**_：这是类型变量的声明。它告诉 TypeScript，我们正在定义一个名为 `T` 的类型占位符。
   - _**`arg: T`**_：我们将参数 `arg` 的类型设置为 `T`。
   - _**`: T`**_：我们指定函数的返回值类型也是 `T`。
   这样，`T` 就在函数内部建立了一个联系：**参数类型和返回值类型必须一致。**

3. 如何使用泛型函数
   有两种方式来调用它：

   - **方式一：显式指定类型**

     ```ts
     let output = identity<string>("myString"); // output 的类型是 string
     let numOutput = identity<number>(123);   // numOutput 的类型是 number
     ```

     在这里，我们明确告诉 TypeScript，本次调用的 `T` 就是 `string` 或 `number`。


   - **方式二：利用类型推断（更常见）**

     ```ts
     let output = identity("myString"); // TS 会自动推断 T 为 string
     let numOutput = identity(123);   // TS 会自动推断 T 为 number
     ```

     TypeScript 编译器会检查传入的参数 `arg` 的类型，并自动确定 `T` 的类型。这是最简洁、最常用的方式。




### 其他泛型结构

- **泛型接口/类型**：定义一个可以容纳任意类型内容的结构。
  ```ts
  // 定义一个泛型接口，用于描述通用的API响应结构
  interface ApiResponse<T> {
      code: number;
      message: string;
      data: T; // data 的类型是不确定的，由使用时指定
  }
  // 使用泛型接口
  interface User {
      id: number;
      name: string;
  }
  
  // userData 的类型是 ApiResponse<User>
  const userData: ApiResponse<User> = {
      code: 200,
      message: "Success",
      data: {
          id: 1,
          name: "Alice"
      }
  };
  ```

  
- **泛型类**：创建一个可以处理特定类型数据的类。
  ```ts
  class DataStore<T> {
      private data: T[] = [];
  
      addItem(item: T): void {
          this.data.push(item);
      }
  
      getItems(): T[] {
          return this.data;
      }
  }
  
  // 创建一个只能存储数字的实例
  const numberStore = new DataStore<number>();
  
  // 创建一个只能存储字符串的实例
  const stringStore = new DataStore<string>();
  ```



### 核心重点：泛型约束 (Generic Constraints)


1. **为什么要约束？**
   看下面的例子，它会报错：
   ```ts
   function logLength<T>(arg: T): T {
       // console.log(arg.length); // 错误: 类型“T”上不存在属性“length”。
       return arg;
   }
   ```
   错误的原因是：`T` 代表任意类型，它可能是 `number` 或 `boolean`，这些类型并没有 `.length` 属性。

2. 如何使用 **`extends`** 进行约束
   我们可以创建一个接口来描述约束条件，然后**使用 `extends` 关键字**来应用它。
   ```ts
   // 1. 定义一个描述约束的接口
   interface HasLength {
       length: number;
   }
   
   // 2. 使用 extends 关键字为泛型 T 添加约束
   function logLength<T extends HasLength>(arg: T): T {
       // 现在 TS 知道 arg 肯定有 .length 属性了
       console.log(arg.length);
       return arg;
   }
   
   // 3. 调用
   logLength("hello world"); // 正确，string 有 length 属性
   logLength([1, 2, 3]);   // 正确，array 有 length 属性
   // logLength(123);      // 错误！数字没有 length 属性
   // logLength({name: "test"}); // 错误！该对象没有 length 属性
   logLength({name: "test", length: 10}); // 正确！
   ```

   **【重点解释】** _**`<T extends HasLength>`**_ 这段代码的意思是：“`T` 不再是任意类型，它**必须是**一个符合 `HasLength` 接口的类型”。换句话说，传入的参数类型必须有一个 `length` 属性，且其类型为 `number`。



### 更多重要知识点

- **泛型默认类型 (Default Generic Type)**
  你可以为泛型参数指定一个默认类型，当用户没有指定类型时，它会自动生效。
  ```ts
  // 定义一个创建请求的函数，默认返回 Promise<any>
  function createRequest<T = any>(url: string): Promise<T> {
      return fetch(url).then(res => res.json());
  }
  
  interface User { name: string; }
  
  // 使用时，指定了类型
  const userPromise = createRequest<User>("/api/user"); // 返回 Promise<User>
  
  // 使用时，未指定类型，使用默认的 any
  const dataPromise = createRequest("/api/data"); // 返回 Promise<any>
  ```

  


### 总结与最佳实践

1. **首要目标**：通过泛型在**代码复用**和**类型安全**之间取得完美平衡。
2. **优先使用类型推断**：让 TypeScript 自动推断类型可以使代码更简洁。
3. **约束是泛型的灵魂**：当你的泛型组件需要访问参数的某些属性或方法时，**必须使用 `extends` 进行约束**。这是写出真正有用的泛型组件的关键。
4. **不要滥用泛型**：如果一个简单的联合类型 (`string | number`) 或者 `any`（在少数必要情况下）就能解决问题，就不需要引入泛型的复杂性。
5. 命名规范：
   - 单字母大写（如 `T`, `U`, `V`）是简单泛型的惯例。
   - 对于更复杂的场景，使用更具描述性的名称（如 `TData`, `TError`, `TResponse`）可以提高代码可读性。