---
date: 2025-06-25
tags:
  - TypeScript
---
## 类型收窄

**核心概念：什么是类型收窄 (Type Narrowing)？**

想象一下，你有一个变量，它的类型可能是多种情况之一（即一个**联合类型**），比如 `string | number`。

```ts
function processInput(input: string | number) {
  // 在这里，TypeScript 只知道 input 是 string 或 number
  // console.log(input.toUpperCase()); // ❌ 错误！因为 number 类型没有 toUpperCase 方法
}
```

在上面的例子中，TypeScript 无法确定 `input` 到底是 `string` 还是 `number`，所以它会采取最保守的策略，只允许你使用两种类型共有的属性和方法。为了在特定代码块中安全地调用特定类型的方法（如 `string` 的 `toUpperCase`），我们需要向 TypeScript 证明我们已经知道了变量的“真实”类型。


**类型收窄（Type Narrowing）** 就是这样一个过程：在代码的特定分支或块中，TypeScript 编译器通过逻辑分析，能够推断出变量比它声明时更具体的类型。简而言之，就是**将一个宽泛的类型范围“收窄”到一个更具体的类型**。


### 类型守卫

类型守卫是一些表达式，它们在运行时执行检查，并根据结果来保证变量在某个作用域内是特定的类型。

#### 1. `typeof` 类型守卫

这是最基础、最常见的类型守卫，用于判断一个值的**原始类型**。

- **适用场景**：主要用于检查 `string`, `number`, `bigint`, `boolean`, `symbol`, `undefined`, `object`, `function`。
- **详细解释**：当你在 `if` 语句中使用 `typeof` 进行判断时，TypeScript 会自动在 `if` 块内部将变量的类型收窄到你所判断的类型。

**示例代码：**

```ts
function printValue(value: string | number | boolean) {
  if (typeof value === "string") {
    // ✅ 在这个块里，TypeScript 知道 value 是 string 类型
    console.log(value.toUpperCase());
  } else if (typeof value === "number") {
    // ✅ 在这个块里，TypeScript 知道 value 是 number 类型
    console.log(value.toFixed(2));
  } else {
    // ✅ 在这个块里，TypeScript 知道 value 是 boolean 类型
    console.log(value ? "It's true" : "It's false");
  }
}

printValue("hello"); // HELLO
printValue(123.456); // 123.46
printValue(true);    // It's true
```

**注意**：`typeof null` 的结果是 `"object"`，这是一个历史遗留的 JavaScript Bug。因此，`typeof` 无法用来准确地从对象中区分 `null`。



#### 2. 真值收窄

这是一个非常符合 JavaScript 直觉的收窄方式。它通过检查一个值的“真假”来进行类型收窄。

- **适用场景**：用于排除 `null`, `undefined`, `0`, `""` (空字符串), `false`, `NaN` 等“假值”(falsy values)。
- **详细解释**：当你直接在条件判断（如 `if (value)`）中使用一个变量时，TypeScript 会认为你在判断它是否为“真值”(truthy)。如果判断通过，TypeScript 会从其类型中剔除所有可能的“假值”类型。

**示例代码：**

```ts
function greet(name: string | null | undefined) {
  if (name) {
    // ✅ 在这个块里，name 的类型被收窄为 string
    // 因为 null 和 undefined 都是 "falsy" 值，已经被排除了
    console.log(`Hello, ${name.toUpperCase()}!`);
  } else {
    console.log("Hello, guest!");
  }
}

greet("Alice"); // Hello, ALICE!
greet(null);    // Hello, guest!
```



#### 3. 等值收窄

通过使用 `===`, `!==`, `==`, `!=` 等相等性运算符来进行类型收窄。

- **适用场景**：与特定字面量值、`null` 或 `undefined` 进行比较。
- **详细解释**：当你将变量与某个具体的值进行比较时，TypeScript 会根据比较结果收窄类型。这对于处理字面量联合类型或检查 `null`/`undefined` 非常有用。

**示例代码：**

```ts
type Direction = "left" | "right" | "up" | "down";

function move(direction: Direction) {
  if (direction === "left") {
    // ✅ 类型收窄为 "left"
    console.log("Moving left...");
  }
}

function checkValue(value: string | undefined) {
  if (value !== undefined) {
    // ✅ 类型被收窄为 string，因为 undefined 的情况被排除了
    console.log(value.length);
  }
}
```




#### 4. `instanceof` 类型守卫

`instanceof` 用于检查一个实例是否属于某个类或其子类。

- **适用场景**：处理类的实例对象。
- **详细解释**：`instanceof` 检查一个对象的原型链上是否存在某个构造函数的 `prototype` 属性。在 `if` 块中，TypeScript 会将变量的类型收窄为该类的实例类型。

**示例代码：**

```ts
class Cat {
  mew() {
    console.log("Meow!");
  }
}

class Dog {
  bark() {
    console.log("Woof!");
  }
}

function makeSound(animal: Cat | Dog) {
  if (animal instanceof Cat) {
    // ✅ 在这个块里，animal 的类型被收窄为 Cat
    animal.mew();
  } else {
    // ✅ 在这个块里，animal 的类型被收窄为 Dog
    animal.bark();
  }
}

makeSound(new Cat()); // Meow!
makeSound(new Dog()); // Woof!
```



#### 5. `in` 操作符守卫

`in` 操作符用于检查一个对象上是否存在某个特定的属性。

- **适用场景**：区分具有不同属性的多个对象类型（通常是接口或类型别名）。
- **详细解释**：如果 `if` 条件判断某个属性 `in` 一个对象，那么在该块内部，TypeScript 会认为该对象拥有这个属性，并据此收窄其类型。

**示例代码：**

```ts
interface Fish {
  swim(): void;
}

interface Bird {
  fly(): void;
}

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    // ✅ 在这个块里，TypeScript 知道 animal 是 Fish 类型
    // 因为只有 Fish 类型有 swim 属性
    animal.swim();
  } else {
    // ✅ 在这个块里，TypeScript 知道 animal 是 Bird 类型
    animal.fly();
  }
}
```




#### 6. 自定义类型守卫 (User-Defined Type Guards)

当内置的类型守卫不能满足复杂的检查逻辑时，你可以创建自己的类型守卫函数。

- **核心语法**：`parameterName is Type`，这被称为**类型谓词 (Type Predicate)**。
- **详细解释：**
  1. 创建一个函数，它的返回类型是 `parameterName is Type`。
  2. `parameterName` 必须是当前函数签名里的一个参数名。
  3. `Type` 是你希望收窄到的目标类型。
  4. 函数体内部执行你的自定义逻辑，并返回一个 `boolean`。
  5. 当这个函数在 `if` 语句中被调用并返回 `true` 时，TypeScript 就会在 `if` 块内将该参数的类型收窄到 `Type`。

**示例代码：**

```ts
interface Fish {
  swim(): void;
}

interface Bird {
  fly(): void;
}

// 这就是自定义类型守卫函数
// 它的返回值 `pet is Fish` 是一个类型谓词
function isFish(pet: Fish | Bird): pet is Fish {
  // 我们通过检查 pet 是否能被强制转换为 Fish 并拥有 swim 属性
  // 来判断它是不是 Fish 类型
  return (pet as Fish).swim !== undefined;
}

function letPetMove(pet: Fish | Bird) {
  if (isFish(pet)) {
    // ✅ 因为 isFish(pet) 返回 true，TypeScript 在此块中
    // 将 pet 的类型收窄为 Fish
    pet.swim();
  } else {
    // ✅ 在 else 块中，TypeScript 知道 pet 是 Bird 类型
    pet.fly();
  }
}
```

