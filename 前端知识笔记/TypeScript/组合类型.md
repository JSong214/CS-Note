---
date: 2025-06-20
tags:
  - TypeScript
aliases:
  - 联合类型
  - 交叉类型
---
### 联合类型 (Union Types)

联合类型使用 **`|` (竖线) 操作符**，表示一个值可以是几种类型之一。它符合逻辑上的 **“或” (OR)** 关系。


#### **1.基础语法**

```ts
let myVar: string | number;

myVar = "Hello"; // OK
myVar = 123;     // OK

// myVar = true; // Error: Type 'boolean' is not assignable to type 'string | number'.
```

**核心思想**：变量 `myVar` 的类型“要么是 `string`，要么是 `number`”。


#### **2.联合类型的属性访问 (重要)**

**规则**：当一个值的类型是联合类型时，我们只能访问这个联合类型中 **所有成员都共有的** 属性或方法。

```ts
interface Bird {
  fly(): void;
  name: string;
}

interface Fish {
  swim(): void;
  name: string;
}

function move(pet: Bird | Fish) {
  console.log(`Pet name is: ${pet.name}`); // OK: 因为 Bird 和 Fish 都有 name 属性

  // pet.fly();  // Error: Property 'fly' does not exist on type 'Bird | Fish'.
               // Property 'fly' does not exist on type 'Fish'.

  // pet.swim(); // Error: Property 'swim' does not exist on type 'Bird | Fish'.
               // Property 'swim' does not exist on type 'Bird'.
}
```

在上面的 `move` 函数中，`pet` 参数可能是 `Bird`，也可能是 `Fish`。TypeScript 无法在编译时确定它到底是什么，所以：
- 访问 `pet.name` 是安全的，因为无论 `pet` 是鸟还是鱼，它都有 `name` 属性。
- 访问 `pet.fly()` 是不安全的，因为如果 `pet` 恰好是一条 `Fish`，它并没有 `fly` 方法，这在运行时会是 `undefined` 并导致错误。同理 `pet.swim()` 也不安全。



#### **3.[[类型收窄]] (重要)**

为了解决上面提到的属性访问限制，我们需要一种方法来“缩小”类型的范围，让 TypeScript 知道在某个代码块中，变量的具体类型是什么。这就是 **类型收窄**。



常用的类型收窄方法有：

- **`typeof` 类型守卫**
  主要用于原始类型 (`string`, `number`, `boolean`, `symbol`, `bigint`, `undefined`, `object`, `function`)

  ```ts
  function printId(id: number | string) {
    if (typeof id === "string") {
      // 在这个代码块里, id 的类型被收窄为 string
      console.log(id.toUpperCase());
    } else {
      // 在这个代码块里, id 的类型被收窄为 number
      console.log(id.toFixed(2));
    }
  }
  ```

- **`in` 操作符守卫**：用于检查对象是否拥有某个属性。

  ```ts
  function move(pet: Bird | Fish) {
    if ("fly" in pet) {
      // 在这个代码块里, pet 的类型被收窄为 Bird
      pet.fly();
    } else {
      // 在这个代码块里, pet 的类型被收窄为 Fish
      pet.swim();
    }
  }
  ```

- **`instanceof` 类型守卫**：用于检查一个实例是否属于某个类。

  ```ts
  class Dog { bark() {} }
  class Cat { meow() {} }
  
  function makeSound(animal: Dog | Cat) {
    if (animal instanceof Dog) {
      // animal 类型被收窄为 Dog
      animal.bark();
    } else {
      // animal 类型被收窄为 Cat
      animal.meow();
    }
  }
  ```

- **可辨识联合【高阶技巧】**

  这是最强大、最推荐的一种模式。它要求联合中的每个对象类型都有一个 **共同的、且值为[[字面量类型]]** 的属性，这个属性被称为“可辨识属性”或“标签”。

  ```ts
  interface Circle {
    kind: "circle"; // 可辨识属性
    radius: number;
  }
  
  interface Square {
    kind: "square"; // 可辨识属性
    sideLength: number;
  }
  
  type Shape = Circle | Square;
  
  function getArea(shape: Shape) {
    // 使用 switch 语句可以清晰地处理所有情况
    switch (shape.kind) {
      case "circle":
        // 在这里, shape 被收窄为 Circle
        return Math.PI * shape.radius ** 2;
      case "square":
        // 在这里, shape 被收窄为 Square
        return shape.sideLength ** 2;
      default:
        // default 分支可以处理未来的扩展性，并确保所有情况都被覆盖
        const _exhaustiveCheck: never = shape;
        return _exhaustiveCheck;
    }
  }
  ```

  **优点**：代码可读性高，类型安全，并且利用 `never` 类型可以做到穷尽性检查，当你给 `Shape` 增加新的类型时（比如 `Triangle`），TypeScript 会在 `default` 分支报错，提醒你还有未处理的 case。




### 交叉类型

交叉类型使用 **`&` 操作符**，表示一个值必须 **同时满足** 几种类型的所有要求。它符合逻辑上的 **“与” (AND)** 关系。

#### **1.基础语法**

交叉类型主要用于组合对象类型，将多个类型的成员合并到一个类型中。

```ts
interface Draggable {
  drag(): void;
}

interface Resizable {
  resize(): void;
}

// UIWidget 必须同时拥有 drag 和 resize 方法
type UIWidget = Draggable & Resizable;

let widget: UIWidget = {
  drag: () => console.log("Dragging..."),
  resize: () => console.log("Resizing..."),
};

widget.drag();
widget.resize();
```

**核心思想**：`UIWidget` 类型包含了 `Draggable` **和** `Resizable` 的所有属性。


#### **2.交叉类型的合并行为 (重要)**

- **对象类型的合并**：将所有类型的属性简单地合并在一起。

  ```ts
  interface Person {
    name: string;
    age: number;
  }
  
  interface Employee {
    employeeId: string;
    startDate: Date;
  }
  
  type TeamMember = Person & Employee;
  
  const member: TeamMember = {
    name: "Alice",
    age: 30,
    employeeId: "E123",
    startDate: new Date(),
  };
  ```

- **相同属性但类型不同**：如果合并的类型中存在同名但类型不同的属性，最终该属性的类型会成为这两种类型的交叉类型。

  ```ts
  interface A {
    prop: { a: number };
  }
  
  interface B {
    prop: { b: string };
  }
  
  type C = A & B;
  
  // 结果：C 的类型是 { prop: { a: number } & { b: string } }
  // 所以一个 C 类型的对象必须是这样的：
  const val: C = {
    prop: {
      a: 1,
      b: "hello"
    }
  };
  ```


#### **3.原始类型的交叉 (重要)**

将两个不同的原始类型（如 `string` 和 `number`）交叉，会得到一个不可能存在的类型，即 `never`。
**示例**：

```ts
type Impossible = string & number; // Impossible 的类型是 never

// let x: Impossible = "hello"; // Error
// let y: Impossible = 123;     // Error
// 没有任何值可以赋给 Impossible 类型的变量
```

这个特性在泛型和条件类型中非常有用，可以用来过滤掉不想要的类型。