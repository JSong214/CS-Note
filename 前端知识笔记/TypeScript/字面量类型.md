---
date: 2025-06-25
tags:
  - TypeScript
---
## 字面量类型

**核心定义**：字面量类型是比 `string`, `number` 更精确的类型，代表一个具体的值。

**主要用途**：与**联合类型 (`|`)** 结合，将变量的取值限制在一个明确的集合内。

- **示例：**

  ```ts
  // 使用 type 关键字创建类型别名，方便复用
  type Alignment = 'left' | 'right' | 'center';
  
  function setAlignment(align: Alignment) {
      // ...
  }
  
  setAlignment('left');
  setAlignment('center');
  
  // 优势体现：
  // setAlignment('middle'); // 编译时立即报错！
  // Argument of type '"middle"' is not assignable to parameter of type 'Alignment'.
  
  // 在IDE中输入 setAlignment('') 时，会自动提示 'left', 'right', 'center'
  ```



### 可辨识联合

这是字面量类型最强大、最常用的模式，也称为“标签联合(Tagged Unions)”或“代数数据类型”。它常用于描述一个“可能是这几种类型之一”的数据结构。

一个可辨识联合需要满足三个要素：

1. 所有成员都有一个**共同的、类型为字面量的属性**（通常命名为 `kind`, `type` 等），我们称之为**可辨识的属性**或**标签**。
2. 一个类型别名，将这些成员联合起来。
3. 通过检查这个“标签”属性，可以实现**[[类型收窄]] (Type Narrowing)**。



**【详细示例】**

假设我们要定义一个 `Shape` 类型，它可以是圆形或正方形。

```ts
// 1. 定义各个成员接口，它们都有一个共同的 `kind` 属性
interface Circle {
    kind: 'circle'; // 字面量类型 'circle' 作为标签
    radius: number;
}

interface Square {
    kind: 'square'; // 字面量类型 'square' 作为标签
    sideLength: number;
}

interface Rectangle {
    kind: 'rectangle';
    width: number;
    height: number;
}

// 2. 使用联合类型将它们组合成一个可辨识联合
type Shape = Circle | Square | Rectangle;

// 3. 使用类型守卫进行类型收窄
function getArea(shape: Shape): number {
    // 通过判断 shape.kind 的值，TypeScript 可以精确地推断出 shape 的具体类型
    switch (shape.kind) {
        case 'circle':
            // 在这个代码块中，ts 知道 shape 的类型是 Circle
            return Math.PI * shape.radius ** 2;

        case 'square':
            // 在这个代码块中，ts 知道 shape 的类型是 Square
            return shape.sideLength ** 2;
        
        case 'rectangle':
            // 在这个代码块中，ts 知道 shape 的类型是 Rectangle
            return shape.width * shape.height;

        // 【最佳实践】使用 never 类型进行穷尽性检查
        default:
            const _exhaustiveCheck: never = shape;
            // 如果未来我们给 Shape 添加了新的类型（如 Triangle），
            // 但忘记在这里添加 case，TypeScript 就会在这里报错，
            // 因为新类型无法赋值给 never。
            return _exhaustiveCheck;
    }
}

const myCircle: Circle = { kind: 'circle', radius: 10 };
console.log(getArea(myCircle)); // 正确

const mySquare: Square = { kind: 'square', sideLength: 5 };
console.log(getArea(mySquare)); // 正确
```

**可辨识联合的巨大优势**：

- **结构清晰**：非常适合用来建模状态机（如 `loading | success | error`）、网络请求结果等。
- **绝对的类型安全**：在 `switch` 的每个 `case` 中，你可以安全地访问该分支下独有的属性，而不会访问到其他分支的属性。
- **易于维护**：穷尽性检查 (`never`) 确保了你在增加新类型时，不会忘记处理所有相关的逻辑。



### `as const` (常量断言) 

有时，我们定义一个对象，希望TypeScript能将它的属性推断为字面量类型，而不是通用的 `string` 或 `number`。这时就需要 `as const`。

【对比示例】

没有 `as const`：

```ts
const requestConfig = {
    method: 'GET',
    headers: {
        'Content-Type': 'application/json'
    }
};
// TypeScript 推断出的类型是：
// const requestConfig: {
//     method: string; // 被推断为 string！
//     headers: {
//         'Content-Type': string; // 被推断为 string！
//     };
// }
```
这导致我们无法将 `requestConfig.method` 赋值给一个期望是 `'GET' | 'POST'` 的类型。


使用 `as const`：

```ts
const requestConfig = {
    method: 'GET',
    headers: {
        'Content-Type': 'application/json'
    }
} as const; // <--- 在对象末尾加上 as const

// TypeScript 推断出的类型是：
// const requestConfig: {
//     readonly method: "GET"; // 推断为字面量 "GET"
//     readonly headers: {
//         readonly "Content-Type": "application/json"; // 推断为字面量
//     };
// }
```

**`as const` 的作用：**
1. 将所有属性变为 `readonly`（只读）。
2. 将所有属性值尽可能地推断为最窄的**字面量类型**。
3. 对数组，会将其变为 `readonly` 元组。


**应用场景**：当你有一组固定的配置或常量，并希望基于这些常量创建类型时，`as const` 非常有用。

```ts
// 结合 keyof 和 typeof 使用
const METHODS = {
    GET: 'GET',
    POST: 'POST',
    PUT: 'PUT',
} as const;

// type Method = "GET" | "POST" | "PUT";
type Method = keyof typeof METHODS; 

function sendRequest(method: Method, url: string) {
    // ...
}

sendRequest('GET', '/api/users'); // 正确
// sendRequest('DELETE', '/api/users'); // 错误
```

