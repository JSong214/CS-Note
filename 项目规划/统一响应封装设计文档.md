# 统一响应封装设计文档

## 1. 设计目标

- 统一前后端交互的响应格式
- 清晰区分成功和失败响应
- 便于前端统一处理响应数据
- 支持国际化错误信息
- 提供良好的类型安全性

## 2. 响应结构设计

### 2.1 成功响应 - ResSuccess

```go
// ResSuccess 成功响应结构
type ResSuccess struct {
    Code    int         `json:"code"`              // 业务状态码，成功时为 200
    Message string      `json:"message"`           // 响应消息，默认 "success"
    Data    interface{} `json:"data,omitempty"`    // 响应数据，可为任意类型
}
```

**字段说明：**

- `Code`: 业务状态码，成功时统一为 `200`
- `Message`: 成功消息，可自定义，默认为 `"success"`
- `Data`: 实际返回的业务数据，可以是对象、数组、基本类型等

**使用示例：**

```go
// 返回单个对象
ResSuccess{
    Code:    200,
    Message: "success",
    Data: User{
        ID:   1,
        Name: "张三",
    },
}

// 返回列表数据
ResSuccess{
    Code:    200,
    Message: "success",
    Data: []Post{
        {ID: 1, Title: "文章1"},
        {ID: 2, Title: "文章2"},
    },
}

// 返回分页数据
ResSuccess{
    Code:    200,
    Message: "success",
    Data: map[string]interface{}{
        "list":     posts,
        "total":    100,
        "page":     1,
        "pageSize": 20,
    },
}

// 无数据返回（如删除成功）
ResSuccess{
    Code:    200,
    Message: "删除成功",
    Data:    nil,
}
```

### 2.2 错误响应 - ResError

```go
// ResError 错误响应结构
type ResError struct {
    Code    int         `json:"code"`              // 业务错误码
    Message string      `json:"message"`           // 错误消息
    Error   string      `json:"error,omitempty"`   // 详细错误信息（可选，仅开发环境）
    Details interface{} `json:"details,omitempty"` // 错误详情（可选，如表单验证错误）
}
```

**字段说明：**

- `Code`: 业务错误码，用于标识具体的错误类型
- `Message`: 面向用户的错误消息，应当友好且易于理解
- `Error`: 详细的错误信息，建议仅在开发环境返回，生产环境可省略
- `Details`: 错误详情，如表单验证错误时返回各字段的错误信息

**使用示例：**

```go
// 一般错误
ResError{
    Code:    40001,
    Message: "用户名或密码错误",
}

// 参数验证错误
ResError{
    Code:    40002,
    Message: "参数验证失败",
    Details: map[string]string{
        "email":    "邮箱格式不正确",
        "password": "密码长度至少为 8 位",
    },
}

// 资源未找到
ResError{
    Code:    40004,
    Message: "文章不存在",
}

// 权限错误
ResError{
    Code:    40003,
    Message: "无访问权限",
}

// 服务器错误（开发环境）
ResError{
    Code:    50000,
    Message: "服务器内部错误",
    Error:   "sql: no rows in result set",
}
```

## 3. 业务状态码规范

### 3.1 成功状态码

| 状态码 | 说明 |
| :----- | :--- |
| 200    | 成功 |

### 3.2 客户端错误状态码（4xxxx）

| 状态码 | 说明         | 使用场景                       |
| :----- | :----------- | :----------------------------- |
| 40000  | 请求错误     | 通用客户端错误                 |
| 40001  | 认证失败     | 用户名或密码错误、token 无效等 |
| 40002  | 参数验证失败 | 请求参数不符合要求             |
| 40003  | 权限不足     | 无权访问该资源                 |
| 40004  | 资源未找到   | 请求的资源不存在               |
| 40005  | 资源已存在   | 创建资源时发生冲突             |
| 40006  | 请求过于频繁 | 触发限流                       |
| 40007  | 会话过期     | 用户会话已过期，需重新登录     |

### 3.3 服务器错误状态码（5xxxx）

| 状态码 | 说明           | 使用场景             |
| :----- | :------------- | :------------------- |
| 50000  | 服务器内部错误 | 未预期的服务器错误   |
| 50001  | 数据库错误     | 数据库操作失败       |
| 50002  | 外部服务错误   | 调用第三方服务失败   |
| 50003  | 服务不可用     | 服务维护或暂时不可用 |

> **注意：** 这里的业务状态码与 HTTP 状态码是独立的。HTTP 状态码仍应正确设置（如 404、500 等），业务状态码用于更细粒度的错误分类。

## 4. 辅助函数

为了方便使用，建议提供以下辅助函数：

```go
// Success 返回成功响应
func Success(data interface{}) ResSuccess {
    return ResSuccess{
        Code:    200,
        Message: "success",
        Data:    data,
    }
}

// SuccessWithMessage 返回带自定义消息的成功响应
func SuccessWithMessage(message string, data interface{}) ResSuccess {
    return ResSuccess{
        Code:    200,
        Message: message,
        Data:    data,
    }
}

// Error 返回错误响应
func Error(code int, message string) ResError {
    return ResError{
        Code:    code,
        Message: message,
    }
}

// ErrorWithDetails 返回带详情的错误响应
func ErrorWithDetails(code int, message string, details interface{}) ResError {
    return ResError{
        Code:    code,
        Message: message,
        Details: details,
    }
}

// ErrorWithError 返回带底层错误的错误响应（开发环境）
func ErrorWithError(code int, message string, err error) ResError {
    return ResError{
        Code:    code,
        Message: message,
        Error:   err.Error(),
    }
}
```

## 5. Gin 中间件集成

建议在 Gin 中添加统一的响应处理中间件：

```go
// ResponseJSON 成功响应的辅助方法
func ResponseJSON(c *gin.Context, data interface{}) {
    c.JSON(http.StatusOK, Success(data))
}

// ResponseError 错误响应的辅助方法
func ResponseError(c *gin.Context, httpCode int, bizCode int, message string) {
    c.JSON(httpCode, Error(bizCode, message))
}

// ResponseValidationError 参数验证错误响应
func ResponseValidationError(c *gin.Context, details interface{}) {
    c.JSON(http.StatusBadRequest, ErrorWithDetails(40002, "参数验证失败", details))
}
```

**使用示例：**

```go
// 成功响应
func GetPost(c *gin.Context) {
    post := service.GetPostByID(id)
    ResponseJSON(c, post)
}

// 错误响应
func Login(c *gin.Context) {
    if !validCredentials {
        ResponseError(c, http.StatusUnauthorized, 40001, "用户名或密码错误")
        return
    }
    // ...
}
```

## 6. 前端 TypeScript 类型定义

为确保前后端类型一致，前端应定义对应的接口：

```typescript
// 成功响应类型
interface ResSuccess<T = any> {
  code: number;
  message: string;
  data?: T;
}

// 错误响应类型
interface ResError {
  code: number;
  message: string;
  error?: string;
  details?: any;
}

// 统一响应类型（联合类型）
type ApiResponse<T = any> = ResSuccess<T> | ResError;
```

## 7. 前端请求拦截器

在 Axios 或其他 HTTP 客户端中统一处理响应：

```typescript
import axios from 'axios';
import type { ResSuccess, ResError } from '@/types/response';

// 响应拦截器
axios.interceptors.response.use(
  (response) => {
    const res = response.data as ResSuccess | ResError;
    
    // 判断是否成功
    if (res.code === 200) {
      return (res as ResSuccess).data; // 直接返回 data 字段
    } else {
      // 错误处理
      const error = res as ResError;
      console.error(`[${error.code}] ${error.message}`);
      
      // 根据错误码进行不同处理
      switch (error.code) {
        case 40001:
        case 40007:
          // 认证失败或会话过期，跳转登录
          router.push('/login');
          break;
        case 40003:
          // 权限不足
          ElMessage.error('无访问权限');
          break;
        default:
          ElMessage.error(error.message);
      }
      
      return Promise.reject(error);
    }
  },
  (error) => {
    // HTTP 错误处理
    console.error('HTTP Error:', error);
    ElMessage.error('网络请求失败');
    return Promise.reject(error);
  }
);
```

## 8. 前端使用示例

```typescript
// 定义具体数据类型
interface Post {
  id: number;
  title: string;
  content: string;
}

interface PaginatedData<T> {
  list: T[];
  total: number;
  page: number;
  pageSize: number;
}

// API 调用
async function fetchPosts() {
  try {
    // 拦截器已经返回 data 字段，所以这里直接获取数据
    const data = await axios.get<ResSuccess<PaginatedData<Post>>>('/api/posts');
    console.log(data); // { list: [...], total: 100, page: 1, pageSize: 20 }
  } catch (error) {
    // 错误已在拦截器中处理
    console.error('获取文章列表失败', error);
  }
}

// 单个对象
async function fetchPost(id: number) {
  try {
    const post = await axios.get<ResSuccess<Post>>(`/api/posts/${id}`);
    console.log(post); // { id: 1, title: '...', content: '...' }
  } catch (error) {
    console.error('获取文章失败', error);
  }
}
```

## 9. 最佳实践

### 9.1 HTTP 状态码与业务状态码配合使用

```go
// 正确示例：HTTP 状态码和业务状态码配合
c.JSON(http.StatusOK, Success(data))           // 200 OK + code 200
c.JSON(http.StatusBadRequest, Error(40002, msg)) // 400 Bad Request + code 40002
c.JSON(http.StatusUnauthorized, Error(40001, msg)) // 401 Unauthorized + code 40001
c.JSON(http.StatusNotFound, Error(40004, msg))   // 404 Not Found + code 40004
c.JSON(http.StatusInternalServerError, Error(50000, msg)) // 500 + code 50000
```

### 9.2 避免在响应中暴露敏感信息

- 生产环境不要返回 `Error` 字段（详细错误信息）
- 不要返回数据库错误的具体堆栈
- 使用通用错误消息替代具体的技术细节

### 9.3 国际化支持

```go
// 使用 i18n 库返回多语言错误消息
func Error(c *gin.Context, code int, messageKey string) ResError {
    lang := c.GetHeader("Accept-Language")
    message := i18n.Translate(lang, messageKey)
    return ResError{
        Code:    code,
        Message: message,
    }
}
```

### 9.4 日志记录

```go
// 在返回错误响应前记录日志
func HandleError(c *gin.Context, httpCode int, bizCode int, message string, err error) {
    if err != nil {
        log.Error().
            Err(err).
            Int("httpCode", httpCode).
            Int("bizCode", bizCode).
            Str("path", c.Request.URL.Path).
            Msg(message)
    }
    
    c.JSON(httpCode, Error(bizCode, message))
}
```

## 10. 总结

这套统一响应封装方案具有以下优势：

- ✅ **类型安全**：Go 和 TypeScript 都有明确的类型定义
- ✅ **结构统一**：所有响应遵循相同的结构
- ✅ **易于维护**：集中管理错误码和消息
- ✅ **前端友好**：拦截器统一处理，业务代码更简洁
- ✅ **可扩展**：支持添加新的字段和错误类型
- ✅ **开发友好**：提供详细的错误信息辅助调试

建议在实施时：

1. 先定义好错误码常量文件
2. 在 `utils` 或 `response` 包中实现辅助函数
3. 在前端创建对应的类型定义文件
4. 配置 Axios 拦截器统一处理响应
5. 团队内部统一使用规范