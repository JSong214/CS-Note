## Lecture18 堆（Heaps）和优先队列（Priority Queues）



### **第一部分：什么是优先队列 (Priority Queue)？**

首先，我们来理解“优先队列”这个概念。



#### **1. 定义与直觉**

想象一下医院的急诊室。医生不会严格按照“先来后到”的顺序治疗病人，而是会根据病情的紧急程度来决定下一个应该治疗谁。病情最危重的病人拥有最高的“优先级”。

**优先队列（Priority Queue, PQ）就是这样一种抽象数据类型（ADT）。它和普通的队列（先进先出, FIFO）或栈（后进先出, LIFO）都不同，它其中的每个元素都有一个“优先级”。当你从优先队列中取出一个元素时，你总是能得到当前队列中优先级最高**的那个。



#### **2. 优先队列的应用场景**

- **操作系统任务调度**：优先级高的进程先被CPU执行。
- **网络路由**：路由器优先处理高优先级的网络数据包。
- **事件驱动模拟**：在模拟系统中，下一个要处理的事件是时间戳最小的那个。
- **图算法**：在 Dijkstra（最短路径）和 Prim（最小生成树）算法中，用于高效地找到下一个要访问的、权重最小的顶点。



#### **3. 核心 API (接口)**

一个准的（最大）优先队列通常支持以下操作：

- `void insert(item)`：向队列中添加一个新元素。
- `item peekMax()`：查看并返回队列中优先级最高的元素，但不删除它。
- `item deleteMax()`：删除并返回队列中优先级最高的元素。
- `boolean isEmpty()`：检查队列是否为空。
- `int size()`：返回队列中的元素数量。

*(注：同样也存在“最小优先队列”，其操作是 `peekMin()` 和 `deleteMin()`，返回优先级最低的元素。最大和最小的实现原理是完全对称的。)*

------



### **第二部分：用什么来实现优先队列？—— 堆 (Heap) 的登场**

我们有多种数据结构可以实现优先队列，比如无序数组或有序数组。但它们的效率并不理想（我们将在最后总结）。实现优先队列最高效的数据结构之一，就是我们今天的主角——**堆**。



#### **1. 堆的定义**

堆是一种基于**树**的特殊数据结构。我们通常讨论的是**二叉堆（Binary Heap）**，它满足以下两个至关重要的属性：



#### **2. 堆的两个核心属性**

**属性一：完全性 (Completeness)** 一个二叉堆必须是一个**完全二叉树**。这意味着：

- 树的每一层都是满的，除了最底层。
- 最底层的节点必须**从左到右**连续排列，中间不能有空缺。

下面是一个例子：

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png)

**这个属性为什么重要？** 因为完全二叉树有一个绝佳的特性：我们可以非常方便地用**数组**来存储它，而不需要使用指针。这极大地节省了空间，并能快速定位节点。

**属性二：堆序性 (Heap-Order Property)** 堆序性决定了节点之间的值应该如何排列。它分为两种：

- **最大堆 (Max Heap)**：**任何一个父节点的值都大于或等于它的所有子节点的值**。这意味着，树的根节点一定是整个堆中的最大值。
- **最小堆 (Min Heap)**：**任何一个父节点的值都小于或等于它的所有子节点的值**。这意味着，树的根节点一定是整个堆中的最小值。

下面是一个最大堆的例子，注意每个父节点都比它的孩子大：

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%9C%80%E5%A4%A7%E5%A0%86.png)

**请注意：** 堆序性只保证了垂直方向上的顺序（父子关系），但**没有**保证水平方向上的顺序（兄弟关系）。比如在上图中，19 虽然在 36 的左边，但它比 36 小。

**总结一下：堆就是一个满足“完全性”和“堆序性”的二叉树。**

------



### **第三部分：堆的实现与核心操作**

现在我们进入最关键的部分：如何用代码实现一个堆，并完成优先队列的 `insert` 和 `deleteMax` 操作。



#### **1. 堆的数组表示**

得益于“完全性”，我们可以将堆平铺到一个数组中。通常，为了计算方便，我们会**舍弃数组的第0个索引**，从索引1开始存储节点。

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%A0%86%E7%9A%84%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA.png)

这种表示法下，父子节点索引之间存在优美的数学关系：

- 节点 `k` 的父节点在索引：`k / 2`
- 节点 `k` 的左子节点在索引：`2 * k`
- 节点 `k` 的右子节点在索引：`2 * k + 1`



#### **2. 核心操作：`insert` 与 `swim` (上浮)**

当我们要向最大堆中插入一个新元素时，为了保持完全二叉树的结构，我们只能将它放在数组的末尾（也就是树的最后一个位置）。

但这样做很可能会破坏“堆序性”（新元素可能比它的父节点大）。怎么办呢？

答案是：让这个新元素**“上浮”（swim）**。

**上浮过程：**

1. 将新元素添加到数组末尾。
2. 比较该元素和它的父节点。
3. 如果该元素比父节点大，就交换它们的位置。
4. 重复步骤2和3，直到该元素不再比它的父节点大，或者它已经到达了根节点（索引1）的位置。

**代码解析 (`swim`):**

```java
// k 是当前节点的索引
private void swim(int k) {
    // 如果 k > 1 (不是根节点) 并且 k 比它的父节点大
    while (k > 1 && less(k / 2, k)) {
        // 交换 k 和它的父节点
        exch(k / 2, k);
        // 更新 k 的位置到它的父节点，继续向上检查
        k = k / 2;
    }
}

// insert 操作就是先添加到末尾，再执行 swim
public void insert(Key v) {
    pq[++size] = v; // pq 是存储堆的数组, size 是元素数量
    swim(size);
}
```

`less(i, j)` 是一个辅助函数，用于比较 `pq[i]` 和 `pq[j]` 的大小。`exch(i, j)` 用于交换数组中两个索引的元素。



#### **3. 核心操作：`deleteMax` 与 `sink` (下沉)**

对于一个最大堆，优先级最高的元素永远在根节点（索引1）。删除它很简单，但删除后，我们需要在根节点位置填补一个新元素，并维持堆的结构。

**下沉过程：**

1. 取出根节点的值（这是要返回的最大值）。
2. 将数组的**最后一个元素**移动到根节点（索引1）的位置。这样做是为了维持树的“完全性”。
3. 此时，新的根节点的值很可能太小，破坏了“堆序性”。我们需要让它**“下沉”（sink）**。
4. 比较当前节点和它的两个子节点，找出**值最大的那个子节点**。
5. 如果当前节点比它最大的子节点还要小，就交换它们的位置。
6. 重复步骤4和5，直到当前节点不再比它的任何一个子节点小，或者它已经到达了叶子节点的位置。

**代码解析 (`sink`):**

```java
// k 是当前节点的索引
private void sink(int k) {
    // 只要 k 还有子节点 (左子节点索引 <= size)
    while (2 * k <= size) {
        int j = 2 * k; // j 指向左子节点
        // 如果右子节点存在，并且比左子节点大，那么 j 指向右子节点
        if (j < size && less(j, j + 1)) {
            j++;
        }
        // 如果 k 不比它两个子节点中较大的那个小，说明位置正确，结束下沉
        if (!less(k, j)) {
            break;
        }
        // 否则，交换 k 和较大的子节点 j
        exch(k, j);
        // 更新 k 的位置，继续向下检查
        k = j;
    }
}

// deleteMax 操作就是交换首尾，删除末尾，再对新的首元素执行 sink
public Key delMax() {
    Key max = pq[1];      // 从根节点得到最大元素
    exch(1, size--);    // 将其和最后一个节点交换
    pq[size + 1] = null; // 防止对象游离 (内存泄漏)
    sink(1);              // 恢复堆的有序性
    return max;
}
```

------



### **第四部分：性能分析与总结**

现在，我们来对比一下不同实现方式下，优先队列的性能。

| **实现方式**      | **`insert` (插入)**   | **`deleteMax` (删除最大值)** |
| ----------------- | --------------------- | ---------------------------- |
| **无序数组/链表** | `O(1)`                | `O(N)` (需要遍历查找)        |
| **有序数组/链表** | `O(N)` (需要移动元素) | `O(1)`                       |
| **二叉堆 (Heap)** | **`O(log N)`**        | **`O(log N)`**               |



**为什么堆的复杂度是 O(log N)？** 因为堆是一个（近似）平衡的完全二叉树，它的高度约等于 `log N`。无论是 `swim` 还是 `sink` 操作，元素移动的路径长度最多就是树的高度。因此，插入和删除操作的耗时都和树的高度成正比。



#### **知识点总结**

1. **优先队列 (PQ)** 是一种根据元素优先级进行出队操作的抽象数据类型。
2. **堆 (Heap)** 是实现优先队列的一种高效数据结构，本质是一个**完全二叉树**。
3. 堆必须满足**堆序性**（最大堆或最小堆）和**完全性**。
4. 堆通常用**数组**实现，利用索引计算来模拟父子关系，非常节省空间。
5. 堆的 `insert` 操作依赖于**上浮 (swim)** 算法来恢复堆序性。
6. 堆的 `deleteMax` 操作依赖于**下沉 (sink)** 算法来恢复堆序性。
7. 基于堆的优先队列，其核心操作的时间复杂度均为 **O(log N)**，性能非常优越。