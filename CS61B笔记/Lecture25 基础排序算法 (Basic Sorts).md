## Lecture25 基础排序算法 (Basic Sorts)



### 1. 排序问题导论 (The Sorting Problem)

在我们开始学习具体的算法之前，我们首先要明确我们要解决的问题是什么。



#### 1.1 排序的定义

简单来说，排序就是将一组元素按照特定的顺序重新排列 。为了能够进行排序，我们必须首先定义一个“排序关系” (ordering relation)，这个关系需要满足两个基本定律，形成一个“全序” (total order) ：

- **三歧义定律 (Law of Trichotomy)**: 对于任意两个元素 a 和 b，以下三种情况中**有且仅有**一种为真：a<b，a=b，或者 b<a 。
- **传递性定律 (Law of Transitivity)**: 如果 a<b 且 b<c，那么必然有 a<c 。



一个排序算法就是一个对元素序列的**排列 (permutation)**，它将这些元素按照我们给定的排序关系，整理成非递减的顺序，即 X1≤X2≤⋯≤XN 。



**【例子：按字符串长度排序】** 假设我们有这样一个字符串数组：`["cows", "get", "going", "the"]`。 如果我们的排序关系是“字符串的长度”，那么 "get" 和 "the" 在这个关系下是相等的，因为它们的长度都是 3 。因此，以下两种都是有效的排序结果 ：

- `["the", "get", "cows", "going"]` 
- `["get", "the", "cows", "going"]` 



在 Java 中，我们通常通过实现 `Comparator` 接口的 `compare` 方法或 `Comparable` 接口的 `compareTo` 方法来定义这种排序关系 。



#### 1.2 逆序对 (Inversions)

我们还可以从另一个角度理解排序：**消除逆序对**。 一个**逆序对**指的是在一组序列中，一对“乱序”的元素 。例如，在序列 `[8, 6, 9, 5, 7]` 中，`(8, 6)` 是一个逆序对，因为 8 出现在 6 的前面但 8 > 6。



*图例：序列中的逆序对。* 

<img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.png" style="zoom: 67%;" />

因此，排序的目标也可以看作是：执行一系列操作，将序列中的逆序对数量减少到 0 。



#### 1.3 性能衡量标准

我们用**时间复杂度 (Time Complexity)** 和 **空间复杂度 (Space Complexity)** 来衡量一个算法的效率。

- **时间复杂度**: 描述算法运行时间随输入规模增长的变化趋势 。例如，我们说迪杰斯特拉算法的时间复杂度是 O(ElogV) 。

- **空间复杂度**: 描述算法在运行过程中额外需要的内存空间 。我们通常不计算输入数据本身占用的空间 。

  

------



### 2. 选择排序 (Selection Sort)

选择排序是最直观的排序算法之一。它的核心思想非常简单，就像我们整理扑克牌一样。



#### 2.1 算法思想

对于一个包含 N 个元素的数组，选择排序的步骤如下 ：

1. 在数组的**未排序部分**找到最小的元素 。
2. 将这个最小的元素与未排序部分的第一个元素交换位置，这样它就移动到了**已排序部分**的末尾 。
3. 重复以上步骤，直到所有元素都被排序 。



#### 2.2 图解过程

我们来看一个具体的例子，排序数组 `[32, 15, 2, 17, 19, 26, 41, 17, 17]`。灰色部分代表已排序，绿色部分代表未排序。

1. **初始状态**: 整个数组都是未排序的。
2. **第 1 轮**: 在整个数组中找到最小的元素 `2`。 将 `2` 和数组第一个元素 `32` 交换。现在 `2` 已经排好序。
3. **第 2 轮**: 在剩下的未排序部分 `[15, 32, ...]` 中找到最小的元素 `15`。 它已经在正确的位置，无需交换。现在 `[2, 15]` 是已排序部分。
4. **第 3 轮**: 在 `[32, 17, ...]` 中找到最小的元素 `17`。 将它和 `32` 交换。
5. **后续过程**: 重复这个过程，直到整个数组排序完成。

<img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.png" style="zoom:50%;" />



#### 2.3 性能分析

- **时间复杂度**:

  - 在第一轮中，为了找到最小的元素，我们需要比较 N-1 次。

  - 第二轮需要比较 N-2 次。

  - ...

  - 最后一轮需要比较 1 次。 总的比较次数是 
    $$
    (N−1)+(N−2)+⋯+1=\frac {N(N−1)} 2
    $$
    。因此，无论输入数据是什么样的，选择排序的时间复杂度都是 Θ(N2) 。

- **空间复杂度**:

  - 选择排序是在原始数组上进行交换操作的，我们只需要常数个额外的变量来存储最小值和索引。因此，它的空间复杂度是 Θ(1)，是一种**原地 (in-place)** 排序 。



**小结**: 选择排序虽然简单，但效率不高，因为它在每一轮中都对未排序部分进行了完整的扫描，没有利用到之前扫描获得的信息 。



------



### 3. 堆排序 (Heapsort)

选择排序的主要瓶颈是“寻找最小/最大值”这个操作太慢。我们自然会想到，有没有一种数据结构能够让我们快速地找到最大值呢？答案就是**堆 (Heap)**。

堆排序就是利用堆这种数据结构来优化选择排序。我们将使用**最大堆 (Max Heap)** 来进行讲解 。



#### 3.1 朴素堆排序 (Naive Heapsort)

这是一种比较直接的思路，它需要一个额外的数组来存储结果。

1. **建堆 (Heap Creation)**: 创建一个空的**最大堆**。将输入数组中的所有元素逐个插入到这个堆中 。

2. **排序 (Heap Deletion)**: 重复 N 次，从最大堆中删除堆顶元素（也就是当前的最大值），然后将这个元素放入输出数组中，从后往前填充 。

   

**图解过程**:

1. **建堆**: 将所有元素 `[32, 15, ..., 17]` 插入最大堆，最终堆的结构如下：

   <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%8E%92%E5%BA%8F%E5%BB%BA%E5%A0%86.png" style="zoom:50%;" />

2. **排序**:

   - 删除最大值 `41`，放入输出数组的末尾。

     <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%8E%92%E5%BA%8F-%E5%A0%86.png" style="zoom: 33%;" />

   - 删除新的最大值 `32`，放入输出数组的倒数第二位。

   - ...重复此过程，直到堆为空，此时输出数组就完全有序了。

     <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%8E%92%E5%BA%8F-%E5%A0%862.png" style="zoom:33%;" />

     

**性能分析**:

- **时间复杂度**: 插入 N 个元素到堆中，每次插入的时间复杂度是 O(logN)，总共是 O(NlogN)。删除 N 个元素，每次删除也是 O(logN)，总共是 O(NlogN)。因此，总时间复杂度为 O(NlogN) 。
- **空间复杂度**: 我们需要一个额外的空间来存储堆，以及一个输出数组，因此空间复杂度是 Θ(N) 。



#### 3.2 原地堆排序 (In-place Heapsort)

朴素堆排序 Θ(N) 的空间复杂度在某些场景下是不可接受的。我们可以通过一个巧妙的技巧，只用输入数组本身完成排序，实现 Θ(1) 的空间复杂度。



**核心思想**: 将输入数组“原地”变成一个最大堆。然后，我们将堆的未排序部分和数组的已排序部分巧妙地结合在同一个数组里 。

**算法步骤**:

1. **原地建堆 (Heapification)**:

   - 这是一个关键步骤。我们不是从上往下建堆，而是采用一种更高效的**自底向上 (bottom-up)** 的方法 。
   - 我们从最后一个非叶子节点开始，一直到根节点，对每个节点执行 `sink` (下沉) 操作。
   - `sink` 操作会确保以该节点为根的子树满足堆的性质。当我们对根节点完成 `sink` 后，整个数组就变成了一个最大堆 。

   **图解 Heapification**:

   - 初始数组，可视为一个不满足堆性质的完全二叉树。

     <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%A0%86%E6%8E%92%E5%BA%8F1.png" style="zoom: 33%;" />

   - 从后往前，对 `2` 进行 sink，它和 `41` 交换，使得以 `41` 为根的子树成为一个堆。

     <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%A0%86%E6%8E%92%E5%BA%8F2.png" style="zoom:33%;" />

   - 再对`15`与`19`进行交换，确保是一个正确的堆。

     <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%A0%86%E6%8E%92%E5%BA%8F3.png" style="zoom:33%;" />

   - 继续对 `32` 和 `41` 进行 sink 操作，直到整个数组变成一个合法的最大堆。

     <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%A0%86%E6%8E%92%E5%BA%8F4.png" style="zoom:33%;" />

     

     

2. **排序阶段 (Sortdown)**:

   - 此时，数组的第一个元素 `arr[0]` 是最大值。
   - 将 `arr[0]` 与堆的最后一个元素交换。此时，最大值被放到了数组的末尾，也就是它最终应该在的位置 。
   - 现在，数组的末尾元素可以被看作“已排序”部分，而前面的 N-1 个元素是“未排序”的堆。
   - 但是，交换后的新根节点可能破坏了堆的性质，所以我们需要对新的根节点执行 `sink` 操作，来恢复堆的结构（堆的大小减 1）。
   - 重复这个“交换-下沉”的过程 N-1 次，直到堆的大小变为 1。

   **图解 Sortdown**:

   - 将堆顶 `41` 和堆尾 `17` 交换。`41` 到达最终位置。

   - 堆大小减一，对新的根 `17` (图中显示交换后根变为 `32` 是因为 sink 操作已经完成) 进行 sink 恢复堆结构。

   - 重复此过程，已排序部分从数组末尾开始不断扩大，堆部分从数组开头不断缩小，直到完成。

     <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%A0%86%E6%8E%92%E5%BA%8F5.png" style="zoom:50%;" />
     
     

**性能分析**:

- **时间复杂度**:

  - 自底向上的建堆过程，虽然看起来是 N 个 sink 操作，每个 O(logN)，但可以被精确地证明其时间复杂度是 Θ(N) 。
  - 排序阶段包含 N-1 次 `removeMax` 操作，每次操作包括一次交换和一次 `sink` (O(logk)，k为当前堆大小)。总时间为 ∑k=2Nlogk=Θ(NlogN)。
  - 因此，原地堆排序的总时间复杂度为 Θ(NlogN) 。

  

- **空间复杂度**:

  - 整个过程都在原数组上进行，只需要常数个额外变量。因此，空间复杂度是 Θ(1) (假设 `sink` 等操作是迭代实现的 )。



------



### 4. 归并排序 (Mergesort)

归并排序是**分治 (Divide and Conquer)** 思想的完美体现。



#### 4.1 算法思想

归并排序的步骤如下 ：

1. **分解 (Divide)**: 如果数组大小大于 1，就将它从中间分成两个大致相等的部分 。

2. **解决 (Conquer)**: 递归地对左半部分和右半部分进行归并排序 。

3. **合并 (Merge)**: 当左右两个半部分都有序后，将它们合并成一个单一的有序数组 。



#### 4.2 核心操作：合并 (Merge)

合并是归并排序中最关键的一步。它需要一个辅助数组 (auxiliary array)。



**步骤**: 假设我们有两个已排序的子数组 `left` 和 `right`，以及一个空的辅助数组 `aux`。

1. 使用两个指针，分别指向 `left` 和 `right` 的起始位置。
2. 比较两个指针指向的元素，将较小的那个复制到 `aux` 数组中，并将对应的指针后移一位。
3. 重复此过程，直到其中一个子数组的所有元素都被复制完毕。
4. 将另一个子数组中剩余的所有元素直接复制到 `aux` 数组的末尾。
5. 最后，将 `aux` 数组中的内容复制回原数组的相应位置。



**图解 Merge 操作**: 

- 将数组拆分，并递归地将左右两半数组排好序。

  <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" style="zoom:50%;" />

- 现在我们将它们合并。`i` 指向左半部分，`j` 指向右半部分，`p` 指向辅助数组。

  <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.png" style="zoom:50%;" />

- 比较 `2` 和 `17`，将 `2` 放入辅助数组。

  <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F3.png" style="zoom: 33%;" /><img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F4.png" style="zoom: 33%;" />

- 比较 `15` 和 `17`，将 `15` 放入辅助数组。


- ...这个过程一直持续，直到所有元素都合并到辅助数组中。

  <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F5.png" style="zoom:50%;" />





#### 4.3 性能分析

- **时间复杂度**:

  - 我们可以把归并排序的递归过程想象成一棵树。这棵树的高度是 log2N 。

  - 在树的每一层，我们需要对多个子数组进行合并操作。但无论如何，每一层所有合并操作的总工作量加起来总是 Θ(N) 。

  - 例如，顶层是 1 次大小为 N 的合并，下一层是 2 次大小为 N/2 的合并... 每一层的总元素数都是 N。

  - 因此，总的时间复杂度是 (层数) × (每层的工作量) = logN×Θ(N)=Θ(NlogN) 。这是一个非常稳定的时间复杂度，无论最好还是最坏情况都是如此 。

  
  
  
  *图例：归并排序的递归与合并过程树状图。* 
  
  <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E5%90%88%E5%B9%B61.png" style="zoom: 67%;" />                                         <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E5%90%88%E5%B9%B62.png" alt="归并排序的递归与合并2" style="zoom: 67%;" />
  
  
  
  
  
  
  
- **空间复杂度**:

  - 在合并操作中，我们需要一个与待合并数组同样大小的辅助数组。在最高层递归中，这个辅助数组的大小是 N。因此，归并排序的空间复杂度是 Θ(N) 。

    


------



### 5. 总结与比较

| 算法             | 最好情况时间 | 最坏情况时间 | 空间复杂度 | 关键点                                                       |
| ---------------- | ------------ | ------------ | ---------- | ------------------------------------------------------------ |
| **选择排序**     | Θ(N²)        | Θ(N²)        | Θ(1)       | 实现简单，但效率低下。                                       |
| **堆排序(原地)** | Θ(N)*        | Θ(NlogN)     | Θ(1)**     | O(NlogN) 的时间保证和 Θ(1) 的空间是最大优点。但因为访问不连续，缓存性能较差 。 |
| **归并排序**     | Θ(NlogN)     | Θ(NlogN)     | Θ(N)       | 性能稳定可靠，实际运行速度通常比堆排序快。主要缺点是需要额外空间 。 |

*注*: 

- 当数组中所有元素都相同时，建堆过程是线性的，排序过程也是线性的 。 
- 假设堆操作是迭代实现的 。