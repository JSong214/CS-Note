## Lecture21 “最短路径” (Shortest Paths) 



### **第一部分：最短路径问题简介 (Introduction)**

#### **1. 什么是图 (Graph)？**

在计算机科学中，图是由**顶点 (Vertices)** 和连接顶点的**边 (Edges)** 组成的结构。

- **顶点**：可以代表任何事物，比如城市、交叉路口、网络中的计算机或社交网络中的人。
- **边**：代表顶点之间的连接。例如，城市之间的道路、计算机之间的网络连接等。
- **权重 (Weight)**：边可以有一个“权重”或“成本”，代表了从一个顶点到另一个顶点的代价。这个代价可以是距离、时间、费用等。一个所有边都有权重的图被称为**加权图 (Weighted Graph)**。



#### **2. 最短路径问题 (Shortest Path Problem)**

最短路径问题，就是在加权图中，找到从一个**起始顶点 (Source)** 到一个**目标顶点 (Target)** 的所有可能路径中，**权重之和最小**的那一条路径。

我们主要关注**单源最短路径问题 (Single-Source Shortest Paths, SSSP)**：即给定一个起始顶点 `s`，找出从 `s` 到图中**所有**其他顶点的最短路径。



#### **3. 如何表示最短路径？——最短路径树 (Shortest Path Tree, SPT)**

当我们找到从源点 `s` 到所有其他可达顶点的最短路径后，这些路径会构成一棵“树”，我们称之为最短路径树。在代码实现中，我们通常用两个数组来存储这棵树：

1. `distTo[v]`：一个数组，存储从源点 `s` 到顶点 `v` 的**最短路径的权重之和**（也就是最短距离）。
2. `edgeTo[v]`：一个数组，存储在从 `s` 到 `v` 的最短路径上，`v` 的**前一个顶点**。通过这个数组，我们可以从任何目标顶点回溯到源点，从而重建整条路径。

**图例：最短路径树**

想象一下一个简单的图，源点是 A。

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%9B%BE%E4%BE%8B.png)

从 A 出发的最短路径树可能是这样的（以 `edgeTo` 关系表示）：

- `edgeTo[B] = A`
- `edgeTo[D] = A`
- `edgeTo[C] = B` (因为 A->B->C 的总权重是 1+2=3，优于 A->D->E->C ... 的其他路径)
- `edgeTo[E] = D` (因为 A->D->E 的总权重是 4+1=5)

`distTo` 数组则会是：

- `distTo[A] = 0`
- `distTo[B] = 1`
- `distTo[D] = 4`
- `distTo[C] = 3`
- `distTo[E] = 5`



#### **4. 核心操作：松弛 (Relaxation)**

几乎所有的最短路径算法都依赖一个核心操作，叫做**松弛**。这个操作的逻辑非常直观：

> 对于一条从顶点 `u` 到顶点 `v`，权重为 `w` 的边 `(u, v)`，如果我们发现一条**经过 `u` 到达 `v` 的路径**比当前已知的到 `v` 的最短路径还要短，那么我们就更新到 `v` 的最短路径。

用伪代码表示就是：

```
// distTo[u] 是已知的从源点到 u 的最短距离
// w 是边 (u, v) 的权重
if (distTo[u] + w < distTo[v]) {
    distTo[v] = distTo[u] + w;  // 更新到 v 的最短距离
    edgeTo[v] = u;             // 更新 v 的前驱节点为 u
}
```

这个过程就好像是拉伸一根橡皮筋，如果找到了更短的路径，就“放松”它，让它收缩到更短的长度。

------



### **第二部分：Dijkstra 算法**

Dijkstra（迪杰斯特拉）算法是解决单源最短路径问题最经典、最著名的算法。但请注意：**Dijkstra 算法只适用于所有边的权重都是非负数（大于等于0）的图。**



#### **1. 核心思想**

Dijkstra 算法是一种**贪心算法 (Greedy Algorithm)**。它的核心思想是：

1. 维护一个**待访问顶点的集合**，我们称之为“边缘” (Fringe)。
2. 每次都从“边缘”中选择一个当前距离源点**最近**的顶点 `v` 进行访问。
3. 一旦访问了顶点 `v`，我们就认为已经找到了从源点到 `v` 的最短路径（这就是贪心的体现），并且这条路径不会再被改变。
4. 然后，我们对 `v` 的所有邻居进行**松弛操作**，可能会更新它们到源点的距离，并把它们也加入到“边缘”中。

这个过程不断重复，直到所有可达的顶点都被访问过。



#### **2. 数据结构**

为了高效地“从边缘中选择距离最近的顶点”，我们使用一个**优先队列 (Priority Queue)** 来实现这个“边缘”集合。优先队列能让我们在对数时间内快速地取出距离最小的顶点。

所以，我们需要：

- `distTo[v]`：存储源点到 `v` 的最短距离。
- `edgeTo[v]`：存储 `v` 的前驱节点。
- `MinPQ<Vertex>`：一个最小优先队列，根据 `distTo` 的值来排列顶点。`distTo` 值越小的顶点，优先级越高。



#### **3. 算法步骤**

假设源点是 `s`：

1. **初始化**：
   - 将 `distTo[s]` 设置为 0。
   - 将所有其他顶点的 `distTo` 值设置为无穷大 (`∞`)。
   - 将 `s` 加入优先队列，优先级为 0。
2. **循环**：
   - 当优先队列不为空时，执行以下操作：
     - 从优先队列中取出优先级最高（即 `distTo` 值最小）的顶点 `u`。
     - 如果 `u` 已经被访问过，则跳过。标记 `u` 为已访问。
     - 对于 `u` 的每一个邻居 `v`：
       - 执行松弛操作：如果 `distTo[u] + weight(u, v) < distTo[v]`，则更新 `distTo[v]` 和 `edgeTo[v]`，并更新 `v` 在优先队列中的优先级。



#### **4. 图例解析**

让我们通过一个例子来模拟 Dijkstra 的过程。源点为 A。

**图:**

```
      (1)
    B ----- C
   / \     / \
(4)   (2) (5)  (3)
 /     \ /     \
A ----- D ----- E
   (2)     (1)
```

**数据结构初始化:**

- `distTo = {A:0, B:∞, C:∞, D:∞, E:∞}`
- `edgeTo = {A:null, B:null, C:null, D:null, E:null}`
- `PQ = { (A, 0) }`

**步骤模拟:**

1. **取出 A (dist=0)**。
   - 松弛 B: `distTo[A]+4 < ∞` -> `distTo[B]=4`, `edgeTo[B]=A`。将 (B, 4) 加入 PQ。
   - 松弛 D: `distTo[A]+2 < ∞` -> `distTo[D]=2`, `edgeTo[D]=A`。将 (D, 2) 加入 PQ。
   - `PQ = { (D, 2), (B, 4) }`
2. **取出 D (dist=2)**。
   - 松弛 B: `distTo[D]+2 < distTo[B]` (即 `2+2 < 4`) -> 不成立。
   - 松弛 C: `distTo[D]+5 < ∞` -> `distTo[C]=7`, `edgeTo[C]=D`。将 (C, 7) 加入 PQ。
   - 松弛 E: `distTo[D]+1 < ∞` -> `distTo[E]=3`, `edgeTo[E]=D`。将 (E, 3) 加入 PQ。
   - `PQ = { (E, 3), (B, 4), (C, 7) }`
3. **取出 E (dist=3)**。
   - 松弛 C: `distTo[E]+3 < distTo[C]` (即 `3+3 < 7`) -> `distTo[C]=6`, `edgeTo[C]=E`。更新 (C, 6) 在 PQ 中的优先级。
   - `PQ = { (B, 4), (C, 6) }`
4. **取出 B (dist=4)**。
   - 松弛 C: `distTo[B]+1 < distTo[C]` (即 `4+1 < 6`) -> `distTo[C]=5`, `edgeTo[C]=B`。更新 (C, 5) 在 PQ 中的优先级。
   - `PQ = { (C, 5) }`
5. **取出 C (dist=5)**。C 没有未访问的邻居。

PQ 为空，算法结束。

**最终结果:**

- `distTo = {A:0, B:4, C:5, D:2, E:3}`
- `edgeTo = {B:A, D:A, E:D, C:B}`
- 最短路径树构建完成！例如，到 C 的最短路径是 A -> B -> C。



#### **5. 运行时分析**

- 每个顶点入队和出队一次，操作为 `O(V * logV)`。
- 每条边最多被松弛一次。每次松弛可能导致优先队列的更新，操作为 `O(E * logV)`。
- 总时间复杂度为 **O(E logV)**（在稠密图中，E 接近 V^2，复杂度可近似为 O(V^2 logV)；在稀疏图中，E 接近 V，复杂度近似为 O(V logV)）。

------



### **第三部分：A\* 算法 (A-Star Algorithm)**

Dijkstra 算法非常有效，但它有一个“盲目”的缺点：它会以源点为中心，向所有方向均匀地探索。如果你的目标只是找到从旧金山到纽约的最短路径，Dijkstra 可能会花费大量时间探索去往洛杉矶方向的路径。

A* 算法就是为了解决这个问题而生的。它是一种**启发式搜索 (Heuristic Search)** 算法，通过引入一个“启发函数”来“智能地”指导搜索方向，从而更快地找到**特定目标**。



#### **1. A\* vs Dijkstra**

- **Dijkstra**: 寻找从**源点**到**所有其他点**的最短路径。
- **A\***: 寻找从**源点**到**某个特定目标点**的最短路径。

A* 的核心思想是在 Dijkstra 的基础上，改变优先队列的优先级计算方式。



#### **2. 核心思想与启发函数 (Heuristic)**

Dijkstra 在优先队列中使用的优先级是 `distTo[v]`，即从源点 `s` 到顶点 `v` 的已知最短距离。

A* 算法为每个顶点 `v` 引入了一个**启发函数 `h(v)`**。这个函数用于**估计**从顶点 `v` 到**目标点 `t`** 的最短距离。于是，A* 使用的优先级变成了：

**`priority(v) = distTo[v] + h(v)`**

- `distTo[v]` (g-score): 从源点到 `v` 的**已知实际代价**。
- `h(v)` (h-score): 从 `v` 到目标点的**估计代价**（启发值）。

这个公式的直观解释是：我们优先探索那些不仅离起点近，而且**看起来**离终点也近的顶点。



#### **3. 启发函数的关键性质**

一个好的启发函数是 A* 算法高效且正确的关键。它必须满足一个重要条件：

**可采纳性 (Admissibility)**: 对于任何顶点 `v`，`h(v)` 的估计值**永远不能大于**从 `v` 到目标点的**实际最短距离**。即 `h(v) <= true_distance(v, t)`。

- **为什么重要？** 如果启发函数高估了距离，A* 可能会被误导，错过真正的最短路径，从而得不到最优解。一个可采纳的启发函数能保证 A* 找到的路径一定是最短的。
- **例子**: 在地图上找路，一个很好的可采纳启发函数是两点间的**直线距离（欧几里得距离）**。因为实际的道路距离永远不可能比直线距离更短。

另一个更强的性质是**一致性 (Consistency)**：对于任意一条从 `u` 到 `v` 的边，必须满足 `h(u) <= weight(u, v) + h(v)`。一致性保证了可采纳性。



#### **4. A\* 与 Dijkstra 的关系**

- A* 可以看作是 Dijkstra 算法的一个**泛化**。
- 如果将启发函数 `h(v)` 设置为恒等于 0，那么 A* 算法的优先级计算就退化成了 `distTo[v] + 0`，这**完全等价于 Dijkstra 算法**。



#### **5. 图例解析**

想象一下在一个网格地图上寻路，从左上角的 S 到右下角的 T。

```
+---+---+---+---+
| S |   | W |   |  S: Start
+---+---+---+---+  T: Target
|   | W |   |   |  W: Wall (无法通过)
+---+---+---+---+
|   |   |   | T |
+---+---+---+---+
```

- **Dijkstra 的探索范围**: 会像一个圆形或菱形一样，从 S 点向四周均匀扩散，直到碰到 T。
  - *它会探索很多明显错误的方向，比如一直往左的格子。*
- **A\* 的探索范围 (使用直线距离作为启发)**: 探索会形成一个指向 T 的椭圆形。
  - *它会优先探索右下方、看起来离 T 更近的格子，从而大大减少了搜索的范围，更快找到目标。*

算法的执行步骤与 Dijkstra 完全相同，唯一的区别就是在计算和更新优先队列中顶点的优先级时，使用的是 `distTo[v] + h(v)` 而不是 `distTo[v]`。

------



### **第四部分：总结 (Summary)**

让我们来总结一下今天学习的两个核心算法。

| 特性         | Dijkstra 算法                                        | A* 算法                                                      |
| ------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| **目标**     | 计算从**一个源点**到**图中所有其他顶点**的最短路径。 | 计算从**一个源点**到**一个特定目标点**的最短路径。           |
| **核心思想** | **贪心**。每次选择离源点最近的未访问顶点进行探索。   | **启发式搜索**。结合已知代价和到目标的估计代价进行探索。     |
| **优先级**   | `distTo[v]` (从源点到 v 的实际代价)                  | `distTo[v] + h(v)` (实际代价 + 到目标的估计代价)             |
| **搜索方向** | 无方向性，以源点为中心向所有方向均匀扩展。           | 有方向性，在启发函数的指引下，倾向于朝目标方向搜索。         |
| **前提条件** | 图中所有边的权重必须为**非负数**。                   | 边的权重为非负数，且启发函数 `h(v)` 必须是**可采纳的 (admissible)**。 |
| **关系**     | A* 算法在 `h(v) = 0` 时，等价于 Dijkstra 算法。      | A* 是 Dijkstra 算法的泛化和优化版本。                        |





#### **如何选择？**

- 如果你需要知道从一个点出发到**所有其他点**的最短距离（例如，构建完整的导航地图数据），使用 **Dijkstra**。
- 如果你只需要找到从 A 点到 B 点的**单条最短路径**（例如，一次具体的导航查询），并且你能设计一个好的启发函数，那么 **A\*** 会比 Dijkstra 快得多。