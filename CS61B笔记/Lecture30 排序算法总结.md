## Lecture30 排序算法总结

### 第一部分：排序结论 (Sorting Conclusion)

这部分的核心是理解不同排序算法的适用场景，特别是何时使用基数排序 (Radix Sort) 而非我们熟知的比较排序 (Comparison Sort)，如归并排序 (Merge Sort)。



#### 1.1 基数排序 vs. 比较排序 (Radix vs. Comparison)

我们以**排序字符串**为例来分析。假设我们有 `N` 个字符串，每个字符串的最大长度为 `W`。

**归并排序 (Merge Sort):**

- 我们知道归并排序需要 Θ(N log N) 次**比较**。

- **关键问题**：比较两个字符串的成本是多少？

- **最佳情况 (Best Case):** Θ(N log N)。如果所有字符串的第一个字符都不同（例如："Apple", "Banana", "Cherry"），那么每次比较都只需要 O(1) 的时间。

- **最差情况 (Worst Case):** Θ(WN log N)。如果所有字符串都非常相似，甚至是相同的（例如："AAAAAAAAA", "AAAAAAAAB"），那么每次比较都需要 Θ(W) 的时间来找到第一个不同的字符。

  

**LSD 基数排序 (LSD Radix Sort):**

- LSD（Least Significant Digit）排序，我们将其视为以 R（字母表大小）为基数的排序。
- 它的运行时间总是 Θ(WN)（假设 R 是常数，例如 R=256） 。它会遍历所有 N 个字符串 W 次（从最后一个字符到第一个字符）。



结论：哪个更好？

- **LSD 基数排序 Θ(WN) 在以下情况更快：**
  1. 当字符串非常**相似**时。此时归并排序的性能会下降到 Θ(WN log N)，这显然比 Θ(WN) 慢。
  2. 当 N 非常大时（渐近地看，N 最终会大于 log N）。
- **归并排序 Θ(N log N) 在以下情况更快：**
  1. 当字符串高度**不相似**时。此时归并排序的比较成本接近 O(1)，其总时间 Θ(N log N) 通常优于 Θ(WN)（假设 W > log N）。



#### 1.2 基数排序整数 (Radix Sorting Integers)

我们如何对整数进行基数排序？整数没有 `charAt` 方法。



**核心思想：** 我们可以将整数视为**任意基数（Base）**的数字。

- **方法1：** 转成字符串（基数为10）。一个Java `int` 最多约10位数字，所以 W=10。

- **方法2 (更灵活)：** 我们可以选择不同的基数 R，这会改变“位数” W。

  - 例如，一个32位的Java整数：

  - $$
    Base 16 (R=16):16^8 \approx 2^{32} \space;\space W=8
    $$

  - $$
    Base 256 (R=256): 256^4 = (2^8)^4 = 2^{32} \space;\space W=4
    $$

  - $$
    Base 65536 (R=65536): 65536^2 = (2^{16})^2 = 2^{32} \space;\space W=2
    $$

    

**权衡 (Trade-off):**

- LSD 基数排序的真正运行时间是 Θ(W(N+R))，因为每一轮（共 W 轮）都需要进行一次计数排序（Counting Sort），而计数排序的时间是 Θ(N+R)（R 是字母表或桶的大小）。
- **选择小的 R (如 R=16)**：W 比较大（W=8）。
- **选择大的 R (如 R=65536)**：W 很小（W=2），但 R 很大，导致 Θ(N+R) 的成本很高。
- 实验表明：对于1亿个整数排序，**Base 256** (W=4, R=256) 是一个“甜点” (sweet spot)，它在 W 和 R 之间取得了很好的平衡，性能远超Java的内置快速排序 (QuickSort)。



#### 1.3 排序与数据结构的联系

讲义中提到了一个非常深刻的联系：**排序算法**的设计思想与**搜索数据结构**的设计思想是平行的。

| **搜索数据结构 (Search)** | **排序算法 (Sort)**            | **核心机制**                                         |
| ------------------------- | ------------------------------ | ---------------------------------------------------- |
| 平衡搜索树 (BSTs, LLRBs)  | 比较排序 (MergeSort, HeapSort) | 基于 `compareTo()` 进行比较                          |
| 哈希表 (Hashing)          | 计数排序 (Counting Sort)       | 基于 `hashCode()` 和 `equals()` (或直接将键作为索引) |
| Tries (字典树)            | 基数排序 (Radix Sort)          | 逐个“数字”(digit-by-digit) 处理                      |