## Lecture2 定义和使用Classes. Lists, Sets and Maps

#### 第一部分：定义和使用类 (Defining and Using Classes)

这部分是面向对象编程 (Object-Oriented Programming, OOP) 的基石。核心思想是把现实世界的事物抽象成代码中的“类”，然后通过类创建具体的“对象”。



##### 1. 类 (Class) vs. 对象 (Object)

- **类 (Class):** 一个模板或蓝图 (blueprint)。它描述了一类事物**共同拥有**的属性 (state) 和行为 (behavior)。
  - 例如，`Dog` 类可以描述所有狗都具有的属性（如：体重 `weight`、名字 `name`）和行为（如：叫 `bark()`）。
- **对象 (Object):** 类的一个具体实例 (instance)。它是根据类的模板创建出来的，真实存在、占用内存的个体。
  - 例如，`myDog = new Dog()` 创建了一个具体的狗对象，这个对象有它自己的体重和名字。



##### 2. 类的三大组成部分

一个类通常由以下三个部分定义：

- **实例变量 (Instance Variables / Fields):**

  - **定义：** 定义在方法之外，用于描述对象的状态或属性。每个对象都拥有自己的一套实例变量。
  - **示例：** 在 `Dog` 类中，`private double weight;` 和 `private String name;` 就是实例变量。`myDog` 的 `weight` 和 `yourDog` 的 `weight` 是相互独立的。
  - **重要：** 通常使用 `private` 修饰符来保护数据，这被称为**封装 (Encapsulation)**。

- **构造函数 (Constructors):**

  - **定义：** 一个特殊的方法，用于创建和初始化 (initialize) 对象。当你使用 `new` 关键字时，构造函数就会被调用。

  - **特点：**

    1. 函数名必须与类名完全相同。
    2. 没有返回类型 (连 `void` 都没有)。

  - **示例：**

    ```java
    public class Dog {
        private double weight;
        private String name;
    
        // 这是构造函数
        public Dog(double w, String n) {
            this.weight = w;
            this.name = n;
        }
    }
    // 使用: Dog d = new Dog(25.5, "Fido");
    ```

- **方法 (Methods):**

  - **定义：** 描述对象的行为或能力。方法可以读取或修改实例变量。
  - **分类：**
    - **实例方法 (Instance Methods):** 属于对象的行为，必须通过对象实例来调用。例如 `myDog.bark()`。
    - **静态方法 (Static Methods):** 属于类本身的行为，与任何具体对象都无关。通过类名直接调用。例如 `Math.random()`。



##### 3. **重要知识点详解**

- **`this` 关键字**
  - **作用：** 在一个实例方法或构造函数内部，`this` 指代**当前对象**的引用。
  - **核心用途：** 区分实例变量和局部变量/参数。在上面的构造函数例子中，`this.name = name;` 的意思是“把参数 `name` 的值赋给这个对象的实例变量 `name`”。
- **静态变量 vs. 实例变量 (Static vs. Instance Variables)**
  - **实例变量 (Instance Variable):**
    - 归属：属于每个**对象**。
    - 存储：每个对象都有一份独立的拷贝。
    - 好比：每个学生自己的笔记本，内容各不相同。
  - **静态变量 (Static Variable):**
    - 归属：属于**类**本身，被该类的所有对象共享。
    - 存储：内存中只有一份拷贝。
    - 好比：教室里的公共白板，所有学生都能看到和修改，修改后所有人看到都是新内容。
  - **语法：** 使用 `static` 关键字定义。`private static int count = 0;`
- **静态方法 vs. 实例方法 (Static vs. Instance Methods)**
  - **实例方法 (Instance Method):**
    - 调用：必须通过对象引用来调用 (`myDog.bark()`)。
    - 访问：可以访问该对象的实例变量和静态变量。
  - **静态方法 (Static Method):**
    - 调用：通过类名直接调用 (`Dog.printDogCount()`)。
    - 访问：**只能访问静态变量和调用其他静态方法**。它不能访问任何实例变量，因为它不与任何特定对象绑定。

------



#### 第二部分：Java 集合框架 (Java Collections Framework)

Java 提供了一套性能优良、使用方便的接口和类，用于存储和操作数据集合，这就是集合框架。`List`, `Set`, `Map` 是其中最重要的三个接口。



##### 核心概念：接口 (Interface) vs. 实现 (Implementation)

- **接口：** 定义了一套规范和契约 (contract)，规定了“能做什么”（比如 `List` 接口规定了必须有 `add`, `get`, `size` 等方法），但不关心“如何做”。

- **实现：** 具体的类，它实现了接口中定义的所有方法，提供了“如何做”的具体细节。

- **最佳实践：** “面向接口编程”。声明变量时使用接口类型，创建对象时使用具体的实现类。

  ```java
  // 推荐:
  List<String> names = new ArrayList<>();
  // 不那么推荐:
  // ArrayList<String> names = new ArrayList<>();
  ```

  这样做的好处是，如果将来想更换实现（比如把 `ArrayList` 换成 `LinkedList`），只需要改动 `new` 的部分，其他代码完全不用变，增强了代码的灵活性。



##### 1. 列表 (List)

- **特点：**
  1. **有序 (Ordered):** 元素按照插入的顺序存储，每个元素都有一个唯一的索引 (index)。
  2. **可重复 (Allows Duplicates):** 可以包含相同的元素。
- **常用实现：**
  - `ArrayList`:
    - **底层结构：** 动态数组 (Dynamic Array)。
    - **性能：**
      - **查询/访问 (`get(index)`) 极快**，时间复杂度为 O(1)。
      - **在末尾添加/删除 (`add`, `remove`) 很快** (均摊 O(1))。
      - **在中间或开头添加/删除元素很慢**，因为需要移动后续所有元素，时间复杂度为 O(N)。
    - **适用场景：** 频繁的随机读取，较少的中间插入/删除。
  - `LinkedList`:
    - **底层结构：** 双向链表 (Doubly-Linked List)。
    - **性能：**
      - **查询/访问 (`get(index)`) 较慢**，需要从头或尾遍历，时间复杂度为 O(N)。
      - **在开头或末尾添加/删除极快**，时间复杂度为 O(1)。
      - **在中间插入/删除也很快** (如果已经有指向该位置的迭代器)。
    - **适用场景：** 频繁的插入和删除操作，特别是从列表的两端。



##### 2. 集 (Set)

- **特点：**
  1. **无序 (Unordered):** 大多数实现不保证元素的顺序（`LinkedHashSet` 除外）。
  2. **不重复 (No Duplicates):** 不能包含相同的元素。尝试添加重复元素会被忽略。
- **常用实现：**
  - `HashSet`:
    - **底层结构：** 哈希表 (Hash Table)。
    - **性能：** **添加 (`add`)、删除 (`remove`)、查找 (`contains`) 操作极快**，平均时间复杂度为 O(1)。
    - **注意：** 存入 `HashSet` 的对象必须正确实现 `hashCode()` 和 `equals()` 方法，这是保证元素唯一性的关键。
    - **适用场景：** 需要快速判断一个元素是否存在，并且不关心其顺序。
  - `TreeSet`:
    - **底层结构：** 红黑树 (Red-Black Tree)，一种自平衡二叉搜索树。
    - **性能：** 添加、删除、查找操作的平均时间复杂度为 O(logN)，比 `HashSet` 慢。
    - **最大特点：** **元素自动排序**。元素可以按自然顺序排序（如数字、字母），或者根据自定义的比较器 (Comparator) 排序。
    - **适用场景：** 需要一个自动排序的、无重复的元素集合。



##### 3. 映射 (Map)

- **特点：**

  1. 存储**键值对 (Key-Value Pairs)**。
  2. **键 (Key) 必须唯一**，不能重复。
  3. 每个键精确地映射到一个值 (Value)。值可以重复。

  - **类比：** 就像一本字典，"单词"是 Key，"释义"是 Value。

- **常用实现：**

  - `HashMap`:
    - **底层结构：** 哈希表 (Hash Table)。
    - **性能：** **添加 (`put`)、获取 (`get`)、查找 (`containsKey`) 操作极快**，平均时间复杂度为 O(1)。
    - **顺序：** 不保证键值对的顺序。
    - **注意：** Key 对象必须正确实现 `hashCode()` 和 `equals()` 方法。
    - **适用场景：** 绝大多数需要键值对存储的场景。
  - `TreeMap`:
    - **底层结构：** 红黑树 (Red-Black Tree)。
    - **性能：** 添加、获取、查找操作的平均时间复杂度为 O(logN)。
    - **最大特点：** **键 (Key) 会自动排序**。
    - **适用场景：** 需要一个根据键排序的映射。

------



### 总结与对比

| 接口 (Interface) | 主要特点                   | 常用实现     | 性能特点 (平均)                               |
| ---------------- | -------------------------- | ------------ | --------------------------------------------- |
| **`List`**       | 有序，可重复，通过索引访问 | `ArrayList`  | 读快 (O(1))，中间增删慢 (O(N))                |
|                  |                            | `LinkedList` | 读慢 (O(N))，两端增删快 (O(1))                |
| **`Set`**        | 无序 (大多)，不重复        | `HashSet`    | 增删查都非常快 (O(1))                         |
|                  |                            | `TreeSet`    | 自动排序，增删查较快 (O(logN))                |
| **`Map`**        | 键值对存储，键唯一         | `HashMap`    | 基于 Key 的增删查都非常快 (O(1))              |
|                  |                            | `TreeMap`    | Key 自动排序，基于 Key 的增删查较快 (O(logN)) |