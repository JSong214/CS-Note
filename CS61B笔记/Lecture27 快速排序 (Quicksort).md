## Lecture27 快速排序 (Quicksort) 

### 1. 快速排序 (Quicksort) 的核心思想与优化

快速排序是由 Tony Hoare 在 1959 年发明的一种高效的排序算法。顾名思义，它在大多数情况下都表现得非常“快”。



#### 1.1 核心思想：分区 (Partitioning)

快速排序的精髓在于“分而治之”（Divide and Conquer），其核心操作是**分区**。

1. **选择一个基准元 (Pivot)**：从数组中挑选一个元素作为基准。
2. **分区**：重新排列数组，将所有小于等于基准的元素放在基准的左边，所有大于等于基准的元素放在基准的右边。完成这一步后，该基准元就到达了它在排序后数组中的最终位置。
3. **递归排序**：对基准元左右两边的两个子数组递归地应用快速排序。

这个过程可以用下图直观地展示：

<img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" style="zoom:50%;" />

上图中，我们选择 `5` 作为基准元。经过分区操作后，所有小于 `5` 的元素 `[3, 2, 1, 4]` 都被移动到了左边，所有大于 `5` 的元素 `[7, 8, 6]` 都被移动到了右边。此时，`5` 已经就位了。接下来，我们只需要分别对左右两个子数组 `[3, 2, 1, 4]` 和 `[7, 8, 6]` 重复这个过程即可。



#### 1.2 性能分析：为何快？又为何会慢？

快速排序的性能高度依赖于每次选择的基准元的好坏。

- **最佳情况 (Best Case)**：每次选中的基准元都恰好是当前子数组的中位数，能够将数组平分成两个大小几乎相等的子数组。
  - **时间复杂度**: O(N log N)。这和归并排序 (Mergesort) 一样高效。
  - 如下图所示，每一层递归的分区操作总共需要处理 N 个元素，工作量为O(N) 。而递归的深度为 O(log N)。
- **最坏情况 (Worst Case)**：每次选中的基准元都是当前子数组的最小值或最大值。这通常发生在**数组已经有序或接近有序**，而我们又总是选择第一个元素作为基准元的情况下。
  - **时间复杂度**: O(N²)。此时，分区操作变得极不均衡，一个子数组为空，另一个子数组大小为 N-1。这使得递归树变成一条长链，深度为 N。
- **平均情况 (Average Case)**：在随机数据下，基准元的选择虽然不总是完美的，但长期来看会将数组划分得比较均衡。
  - **时间复杂度**: O(N log N)。这也是为什么在实践中，快速排序通常是**最快的内部排序算法**。



#### 1.3 如何避免最坏情况？

既然最坏情况是存在的，我们就需要策略来避免它。主要有以下几种哲学思想：

1. **随机化 (Randomness)**：这是最常用且有效的方法。
   - **随机选择基准元 (Random Pivot)**：每次不再固定选择第一个或最后一个元素，而是在当前子数组中随机挑选一个元素作为基准。
   - **预先打乱数组 (Shuffle)**：在排序开始前，将整个数组随机打乱。这样，无论输入是有序的还是部分有序的，对于排序算法来说，它都像一个随机数组，从而极大概率地避免了最坏情况的发生。
2. **更智能的基准元选择 (Smarter Pivot Selection)**：
   - 尝试计算或估算数组的中位数，并用它作为基准。一个常见的做法是“三数取中法”（Median-of-three），即取数组的第一个、中间和最后一个元素的中位数作为基准。
   - 我们可以使用 Quick Select 算法（稍后会讲）来精确找到中位数，但这通常会增加额外的开销，导致整体性能下降。
3. **内省 (Introspection)**：
   - 在递归过程中监控递归深度。如果深度超过某个阈值（例如 k * log N），就切换到其他能保证 O(N log N) 最坏情况时间复杂度的算法，如 Heapsort 或 Mergesort 。这种混合排序算法被称为 **Introsort**。



#### 1.4 分区方案的优化：Hoare Partitioning Scheme

我们之前讨论的分区方法（讲义中称为 L3S，即三路扫描分区）虽然直观，但需要额外的空间来创建副本。Tony Hoare 本人提出了一种更高效的**原地分区 (in-place partitioning)** 方案。



**Hoare 分区方案思想**：

1. 选择一个基准元（例如，第一个元素）。

2. 设置两个指针，一个 `L` 从左向右移动，一个 `G` 从右向左移动。

3. `L` 指针的任务是寻找**大于等于**基准元的元素（它不喜欢大元素）。

4. `G` 指针的任务是寻找**小于等于**基准元的元素（它不喜欢小元素）。

5. 当 `L` 和 `G` 都停下时，如果 `L` 在 `G` 的左边，就交换它们指向的元素。

6. 重复步骤 3-5，直到 `L` 和 `G` 指针相遇或交错。



<img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%88%86%E5%8C%BA.gif" style="zoom:50%;" />

   

 

这个方案通过双向扫描和交换，在 O(N) 时间内完成了原地分区，且空间复杂度为 O(1)，效率更高。实验数据显示，使用 Hoare 分区的 Quicksort (LTHS) 明显快于三路扫描分区 (L3S) 和 Mergesort。





### 2. 快速选择 (Quick Select)

现在，我们来看一个与 Quicksort 密切相关的问题：**选择问题 (Selection Problem)**。这个问题要求在**不排序**的情况下，从一个无序数组中找到第 k 小（或第 k 大）的元素。当 k 为数组长度的一半时，这个问题就是“找中位数”。

Quick Select 算法巧妙地利用了 Quicksort 的分区思想来解决这个问题。



#### 2.1 算法流程

1. 从数组中选择一个基准元，并对其进行分区，得到基准元的最终位置 `p`。
2. 比较 `p` 和 `k`：
   - 如果 `p == k`，那么我们找到了第 k 小的元素，就是这个基准元，算法结束。
   - 如果 `p > k`，说明第 k 小的元素在基准元的**左边**，我们只需要在左子数组中递归地寻找第 k 小的元素。
   - 如果 `p < k`，说明第 k 小的元素在基准元的**右边**，我们只需要在右子数组中递归地寻找第 `k - p - 1` 小的元素（注意索引的调整）。



如下图所示，我们想找中位数（第 4 小的元素）。

1. 第一次分区，基准元 `9` 落在索引 `2` 的位置。因为 `2 < 4`，所以我们只需要在右半部分继续寻找。

2. 在右半部分 `[550, 14, 10, 330, 817, 913]` 中，基准元 `550` 落在全局索引 `6` 的位置。因为 `6 > 4`，我们转到左半部分。

3. 最终，我们在子数组 `[14, 10, 330]` 中分区，基准元 `14` 落在全局索引 `4` 的位置。`4 == 4`，我们找到了中位数！

<img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9.png" style="zoom:50%;" />



#### 2.2 性能分析

- **最佳/平均情况**: 每次分区都能将问题规模缩小一半左右。总的计算量为 N + N/2 + N/4 + ... + 1，这是一个等比数列求和，结果为 O(N)。所以 Quick Select 是一个平均情况下**线性时间**的算法！

- **最坏情况**: 和 Quicksort 一样，如果每次选的基准元都极差，会导致算法退化到 O(N²)。同样，可以通过随机化来避免。

有一个名为 **BFPRT** (或称 Median of Medians) 的算法，可以保证在最坏情况下也以 O(N) 的时间找到第 k 小的元素。但由于其常数因子较大，在实践中很少使用。



### 3. 排序算法的稳定性 (Stability)

这是一个非常重要的概念，尤其是在处理复杂数据结构时。



#### 3.1 什么是稳定性？

一个排序算法是**稳定**的，如果它能保证在排序过程中，**值相等的元素的原始相对顺序保持不变**。

**举个例子**：假设我们有一个学生列表，需要按成绩排序。

原始数据: `[(Alice, 90), (Bob, 85), (Charlie, 90)]`

如果使用**稳定**的排序算法按成绩排序，结果**必须**是：

`[(Bob, 85), (Alice, 90), (Charlie, 90)]`	（Alice 在 Charlie 前面的原始顺序被保留了）

如果使用**不稳定**的排序算法，结果可能是上面那样，也可能是：

`[(Bob, 85), (Charlie, 90), (Alice, 90)]`	（Alice 和 Charlie 的相对顺序可能被改变）



#### 3.2 常见排序算法的稳定性

- **稳定**:
  - **Insertion Sort (插入排序)**
  - **Merge Sort (归并排序)**
  - **Counting Sort (计数排序)**
- **不稳定**:
  - **Selection Sort (选择排序)**
  - **Heapsort (堆排序)**
  - **Quicksort (快速排序)**

**为什么 Quicksort 不稳定？**

在 Quicksort 的分区过程中，特别是像 Hoare 分区那样的原地交换方案，一个元素可能会被交换到远离它原始位置的地方，从而越过其他与它值相等的元素，导致稳定性被破坏。

例如，对于数组 `[..., 5a, ..., 5b, ...]`，如果基准元是 `4`，`5a` 和 `5b` 都在右侧。如果基准元是 `6`，它们都在左侧。但如果基准元是 `5`，`5a` 和 `5b` 可能会被交换到任意位置，从而打乱它们的相对顺序。



### 总结

让我们用一张表格来回顾一下我们讨论过的主要排序算法的特性：

| **排序算法**       | **时间复杂度 (平均)** | **时间复杂度 (最坏)** | **空间复杂度**          | **稳定性** | **备注**                                              |
| ------------------ | --------------------- | --------------------- | ----------------------- | ---------- | ----------------------------------------------------- |
| **Insertion Sort** | O(N²)                 | O(N²)                 | O(1)                    | 稳定       | 对近乎有序的数据或小规模数据非常快，复杂度可达 O(N)。 |
| **Merge Sort**     | O(N log N)            | O(N log N)            | O(N)                    | 稳定       | 性能稳定可靠，是外部排序的常用选择。                  |
| **Heapsort**       | O(N log N)            | O(N log N)$           | O(1)                    | 不稳定     | 空间效率高，但缓存性能较差。                          |
| **Quicksort**      | O(N log N)            | O(N²)                 | O(log N) <br />(递归栈) | 不稳定     | 实践中通常最快的内部排序算法，但需注意避免最坏情况。  |