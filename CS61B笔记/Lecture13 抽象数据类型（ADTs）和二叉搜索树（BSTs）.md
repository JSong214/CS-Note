## Lecture13 抽象数据类型（ADTs）**和**二叉搜索树（BSTs）



### **第一部分：抽象数据类型 (Abstract Data Types - ADTs)**



#### **1.1 什么是抽象数据类型？**

我们可以从一个简单的类比开始：当我们开车时，我们只需要知道如何使用方向盘、油门和刹车来控制汽车，而不需要关心发动机、变速箱等内部是如何工作的。

**抽象数据类型（ADT）** 正是计算机科学中的这种思想。它是一种理论上的概念，**只定义了数据的逻辑行为和可以对数据执行的操作，而不关心其具体的实现细节**。

- **关注点分离**：ADT 将“做什么”（What）与“怎么做”（How）分离开来。它定义了一个接口（API），规定了数据类型应该支持哪些操作。
- **语言无关性**：ADT 是一个纯粹的理论模型，不依赖于任何特定的编程语言。例如，“列表”这个 ADT，可以用 Java 的 `ArrayList` 或 `LinkedList` 实现，也可以用 Python 的 `list` 实现。

常见的 ADT 例子包括：

- **List (列表)**：一个有序的元素集合。操作：`add(item)`, `get(index)`, `remove(index)`, `size()`。
- **Set (集合)**：一个不包含重复元素的集合。操作：`add(item)`, `contains(item)`, `remove(item)`。
- **Map (映射/字典)**：一个存储键值对（key-value pairs）的集合，每个键都是唯一的。操作：`put(key, value)`, `get(key)`, `remove(key)`。
- **Stack (栈)**：后进先出 (LIFO) 的数据结构。操作：`push(item)`, `pop()`。
- **Queue (队列)**：先进先出 (FIFO) 的数据结构。操作：`enqueue(item)`, `dequeue()`。



#### **1.2 为什么 ADT 如此重要？**

1. **抽象化 (Abstraction)**：隐藏了底层的复杂性，让我们可以专注于更高层次的逻辑设计。
2. **模块化 (Modularity)**：代码更易于理解和维护。如果我们需要更换一个 ADT 的底层实现（例如，将 `ArrayList` 换成 `LinkedList`），只要接口不变，其他使用它的代码就无需改动。
3. **代码复用 (Code Reusability)**：一旦实现了一个 ADT，就可以在多个不同的程序中重复使用。

------



### **第二部分：二叉搜索树 (Binary Search Trees - BSTs)**

现在我们来学习一个具体的数据结构——二叉搜索树。BST 是实现**Set**和**Map**这两个 ADT 的一种非常高效的方式。



#### **2.1 树的基本概念**

在学习 BST 之前，我们先快速回顾一下“树”的基本术语：

- **节点 (Node)**：树的基本组成单位，通常包含一个值（或键值对）。
- **边 (Edge)**：连接两个节点的线。
- **根节点 (Root)**：树顶端的节点，没有父节点。
- **父节点 (Parent)** 和 **子节点 (Child)**：一个节点的直接上级是其父节点，直接下级是其子节点。
- **叶节点 (Leaf)**：没有子节点的节点。
- **二叉树 (Binary Tree)**：每个节点最多有两个子节点（通常称为左子节点和右子节点）的树。



#### **2.2 BST 的核心定义与性质**

**二叉搜索树 (BST)** 是一种特殊的二叉树，它满足以下**BST 性质**：

对于树中的**任意一个节点 X**：

1. 其**左子树**中的所有节点的键（key）都**小于**节点 X 的键。
2. 其**右子树**中的所有节点的键（key）都**大于**节点 X 的键。
3. 它的左、右子树也分别是二叉搜索树。

这个性质是 BST 最核心、最重要的规则！它直接导致了 BST 高效的搜索能力。同时，这个性质也意味着**BST 中不允许有重复的键**。

下面是一个 BST 的例子：

```
      8
     / \
    3   10
   / \    \
  1   6    14
     / \   /
    4   7 13
```

你可以验证一下，树中的任何一个节点都满足 BST 性质。例如，对于根节点 8，它左边的所有数都比 8 小，右边的所有数都比 8 大。

------



### **第三部分：BST 的核心操作与代码解析**

BST 的强大之处在于它能高效地执行查找、插入和删除操作。



#### **3.1 查找 (Search / contains)**

得益于 BST 性质，查找一个元素变得非常高效。算法如下：

1. 从根节点开始。
2. 将要查找的键与当前节点的键进行比较：
   - 如果相等，说明找到了，返回该节点。
   - 如果要查找的键**小于**当前节点的键，则移动到**左子节点**，重复步骤 2。
   - 如果要查找的键**大于**当前节点的键，则移动到**右子节点**，重复步骤 2。
3. 如果当前节点为 `null`，说明树中不存在该键，查找失败。

这个过程就像是在一个有序的结构中进行二分查找，每次比较都能排除掉一半的可能。

**代码解析 (Java):**

```java
public class BST<Key extends Comparable<Key>> {
    private Node root;

    private class Node {
        private Key key;
        private Node left, right;

        public Node(Key key) {
            this.key = key;
        }
    }

    // 公共的 contains 方法，对用户隐藏实现细节
    public boolean contains(Key key) {
        return contains(root, key);
    }

    // 私有的辅助方法，使用递归实现
    private boolean contains(Node x, Key key) {
        if (x == null) {
            return false; // 树为空或已到达叶子节点的末端，未找到
        }

        int cmp = key.compareTo(x.key);
        if (cmp < 0) {
            return contains(x.left, key); // 目标键较小，在左子树中继续查找
        } else if (cmp > 0) {
            return contains(x.right, key); // 目标键较大，在右子树中继续查找
        } else {
            return true; // 找到了
        }
    }
}
```

**逻辑讲解**：`contains` 方法优雅地利用了递归。`compareTo` 方法返回一个负数、零或正数，分别表示调用对象小于、等于或大于参数对象。我们根据比较结果，决定是向左走、向右走，还是已经找到了目标。



#### **3.2 插入 (Insert)**

插入操作同样利用 BST 性质来找到新元素应该被放置的位置。

1. 执行与**查找**几乎完全相同的过程，来寻找要插入的键。
2. 如果找到了相同的键，则什么都不做（或更新值，如果实现的是 Map）。
3. 如果查找过程走到了一个 `null` 链接（即到达了树的底部），那么这就是新节点应该被插入的位置。**新节点总是作为叶节点被插入**。

**代码解析 (Java):**

```java
// 在上面的 BST 类中添加
public void insert(Key key) {
    root = insert(root, key);
}

private Node insert(Node x, Key key) {
    if (x == null) {
        return new Node(key); // 找到了插入位置，创建一个新节点并返回
    }

    int cmp = key.compareTo(x.key);
    if (cmp < 0) {
        x.left = insert(x.left, key); // 递归地在左子树中插入
    } else if (cmp > 0) {
        x.right = insert(x.right, key); // 递归地在右子树中插入
    }
    // 如果 cmp == 0，说明键已存在，我们什么都不做

    return x; // 返回当前节点（可能它的子节点指针已被更新）
}
```

**逻辑讲解**：这个递归实现非常精妙。当 `x` 为 `null` 时，意味着我们找到了插入点，此时创建一个新节点并返回它。在递归的回溯过程中，`x.left = ...` 或 `x.right = ...` 这两行代码会将新创建的节点链接到其父节点上。



#### **3.3 删除 (Delete)**

删除是 BST 操作中最复杂的一个，需要分情况讨论：

1. **要删除的节点是叶节点（没有子节点）**： 直接将其父节点指向它的链接设为 `null` 即可。

2. **要删除的节点只有一个子节点**： 将其父节点直接链接到它的那个唯一的子节点上，相当于“跳过”被删除的节点。

3. **要删除的节点有两个子节点（最复杂的情况）**： 这个情况不能直接删除，否则会破坏树的结构。我们需要在树中找到一个节点来“顶替”被删除节点的位置。这个顶替者必须满足：

   - 比左子树的所有节点都大。
   - 比右子树的所有节点都小。

   我们有两个选择： a.  其**左子树中的最大节点**（即左子树中最右边的节点）。 b.  其**右子树中的最小节点**（即右子树中最左边的节点）。

   这种删除策略被称为 **Hibbard Deletion**。步骤是：

   1. 找到右子树的最小节点（或左子树的最大节点），称之为 `successor`。
   2. 将要删除的节点的数据替换为 `successor` 的数据。
   3. 现在问题转化为删除 `successor` 节点。因为 `successor` 是其子树中最小（或最大）的元素，所以它最多只有一个子节点，可以按照情况 1 或 2 来删除。



#### **3.4 运行时间分析**

- **最佳情况 (平衡/浓密 Bushy 的树)**：如果树是“平衡”的，即它的形状矮而胖，那么树的高度大约是 **log N**（N 是节点数）。在这种情况下，查找、插入和删除操作的运行时间都是 **O(log N)**。
- **最坏情况 (不平衡/细长 Spindly 的树)**：如果插入的元素是按顺序的（例如，1, 2, 3, 4, 5），BST 将退化成一个链表。此时，树的高度为 **N**。所有操作的运行时间都将退化为 **O(N)**。

这就是为什么后续课程中会引入**平衡二叉搜索树**（如红黑树、AVL树）的原因，它们通过一些机制来确保树总是接近平衡状态，从而保证 O(log N) 的性能。

------



### **第四部分：BST 作为 Set 和 Map 的应用**

理解了 BST 的原理和操作后，我们就能明白为什么它能高效地实现 Set 和 Map 这两个 ADT。

- **用 BST 实现 Set**：
  - `Set` 的核心是存储不重复的元素并能快速判断元素是否存在。
  - BST 的键（key）正好可以用来存储 `Set` 中的元素。
  - `Set.add(item)` 操作对应 BST 的 `insert(key)`。
  - `Set.contains(item)` 操作对应 BST 的 `contains(key)`。
  - 由于 BST 保证了 O(log N) 的平均性能，这远比基于数组或链表的 `Set` 实现（通常是 O(N)）要快得多。
- **用 BST 实现 Map**：
  - `Map` 存储键值对。
  - 我们可以在 BST 的每个节点中不仅存储一个 `key`，还存储一个关联的 `value`。
  - `Map.put(key, value)`：在 BST 中查找 `key`。如果找到，就更新其 `value`；如果没找到，就插入一个新的 `(key, value)` 节点。
  - `Map.get(key)`：在 BST 中查找 `key`，找到后返回其关联的 `value`。

------



### 总结

- **ADT** 是一种高级的设计思想，它强调**接口与实现分离**，是现代软件工程的基石。
- **BST** 是一种高效的数据结构，它利用**BST 性质**实现了平均 **O(log N)** 时间复杂度的查找、插入和删除操作。