## Lecture3 引用，递归，IntLists



### 核心知识点总览

本章主要围绕三个核心概念展开：

1. **Java 的两种变量类型**：基本类型 (Primitives) 和引用类型 (References)。理解它们的区别是掌握后续内容的关键。
2. **IntList 的构建**：学习如何从零开始构建一个我们自己的列表结构 `IntList`，它是一个典型的递归式数据结构。
3. **递归 (Recursion)**：学习如何使用递归来操作 `IntList` 这种递归式的数据结构。

------



### 1. Java 中的引用 (References)

Java 中所有的数据类型被分为两大类：**基本类型**和**引用类型**。



#### **基本类型 (Primitive Types)**

- **定义**：Java 中预定义的、最基础的数据类型。共有8种：`byte`, `short`, `int`, `long`, `float`, `double`, `boolean`, `char`。
- **内存模型**：可以想象成一个“盒子”，盒子里直接存放着它的**值 (value)**。
  - 例如，`int x = 5;` 这行代码会创建一个大小为32位的盒子，里面直接存储着数字 `5` 的二进制表示。
- **赋值操作 (`=`)**：当你把一个基本类型变量赋给另一个时（如 `int y = x;`），计算机会**复制盒子里的值**，然后放到一个新的盒子里。
  - 此后，`x` 和 `y` 是两个完全独立的变量，修改 `x` 的值不会影响 `y`。



#### **引用类型 (Reference Types)**

- **定义**：除了8种基本类型之外的所有类型，包括数组 (Arrays) 和所有对象 (Objects)，例如我们自定义的 `Walrus` 类或即将学习的 `IntList` 类。
- **内存模型**：可以想象成一个“盒子”，但盒子里存放的不是对象本身，而是一个**地址（或称为“指针”、“引用”）**，这个地址指向内存中实际存储对象数据的地方。
  - 例如，`IntList L = new IntList(5, null);` 这行代码做了两件事：
    1. `new IntList(5, null)` 在内存中创建了一个 `IntList` 对象。
    2. 变量 `L` 得到的是这个新创建对象的内存地址。`L` 的盒子里存放的是一个指向该对象的箭头。
- **赋值操作 (`=`) (The Golden Rule of Equals)**：当你把一个引用类型变量赋给另一个时（如 `IntList L2 = L;`），计算机会**复制盒子里的地址**。
  - 这意味着 `L` 和 `L2` 这两个盒子里的箭头指向了**同一个对象**。
  - 因此，通过 `L2` 修改对象的内容（例如 `L2.first = 10;`），再通过 `L` 来访问时，会发现对象已经变了，因为它们指向的是同一个东西。



#### **作为方法参数传递**

Java 总是采用**按值传递 (pass-by-value)**。

- **传基本类型**：方法得到的是一个值的副本。在方法内部修改这个参数，不会影响到方法外部的原始变量。
- **传引用类型**：方法得到的是一个**地址的副本**。虽然地址本身是复制的，但它和原始变量指向的是同一个对象。因此，在方法内部通过这个地址副本修改了对象的内容，方法外部的原始变量也能看到这个变化。

------



### 2. IntList：一个递归式链表

`IntList` 是我们自己构建的一个简单的链表，用来存储一系列整数。它的设计思想是**递归**的。

- **定义**：一个 `IntList` 对象包含两个部分：

  1. `first`：一个 `int` 类型的值，表示链表的第一个元素。
  2. `rest`：一个指向下一个 `IntList` 对象的引用，表示链表的其余部分。如果这是链表的末尾，`rest` 的值为 `null`。

- **代码结构**：

  ```java
  public class IntList {
      public int first;
      public IntList rest;
  
      public IntList(int f, IntList r) {
          first = f;
          rest = r;
      }
  }
  ```

- **创建 IntList**：

  ```java
  // 创建一个表示 (10 -> 15 -> null) 的链表
  IntList L = new IntList(15, null);
  L = new IntList(10, L); // 将新节点加在最前面
  ```

  这个过程是“从后往前”构建的。`L` 最终指向代表 `10` 的节点，该节点的 `rest` 指向代表 `15` 的节点，`15` 节点的 `rest` 是 `null`。

------



### 3. 递归 (Recursion)

递归是一种解决问题的强大技巧，即一个方法调用其自身来解决一个更小规模的相同问题。`IntList` 的递归结构天然适合用递归方法来处理。

- **递归的两个关键部分**：
  1. **基本情况 (Base Case)**：这是递归的停止条件。对于一个问题，存在一个或多个最简单的情况，可以直接给出答案，而无需进一步递归。对于 `IntList`，最常见的 base case 就是链表为空 (`L == null`) 的情况。
  2. **递归步骤 (Recursive Step)**：如何将当前问题分解成一个或多个规模更小的子问题，并通过调用自身来解决这些子问题。对于 `IntList`，通常是处理 `L.first`，然后对 `L.rest` 进行递归调用。



#### **递归操作 IntList 的示例**

**示例1：计算 `IntList` 的长度 (`size` 方法)**

- **思想**：

  - **Base Case**: 如果链表是 `null`，那么它的长度是 `0`。
  - **Recursive Step**: 如果链表不为 `null`，那么它的长度是 `1` (当前节点) 加上**其余部分 (`rest`) 的长度**。

- **递归实现**:

  ```java
  public int size() {
      if (rest == null) {
          return 1; // Base Case
      }
      return 1 + this.rest.size(); // Recursive Step
  }
  ```

  *注意：这是一个实例方法 (instance method)，所以 `this` 代表当前节点。`this.rest.size()` 就是在对其余部分进行递归调用。*

**示例2：获取第 `i` 个元素 (`get` 方法)**

- **思想**：

  - **Base Case**: 如果要获取第 `0` 个元素，直接返回 `this.first`。
  - **Recursive Step**: 如果要获取第 `i` 个元素（`i > 0`），那么就去链表的**其余部分 (`rest`) 寻找第 `i-1` 个元素**。

- **递归实现**:

  ```java
  public int get(int i) {
      if (i == 0) {
          return this.first; // Base Case
      }
      return this.rest.get(i - 1); // Recursive Step
  }
  ```

  *这个实现假设 `i` 总是一个有效的索引。在实际应用中，还需要处理 `rest` 为 `null` 的情况以避免 `NullPointerException`。*



### 总结与要点

- **引用 vs. 基本类型**：这是 Java 编程中最核心的概念之一。“盒子与指针/箭头”的模型非常有助于理解变量赋值和参数传递的行为。记住**等号 `=` 永远是复制盒子里的内容**。
- **IntList 的递归本质**：一个 `IntList` 要么是 `null`，要么是一个整数 (`first`) 加上另一个 `IntList` (`rest`)。这种定义方式决定了使用递归来处理它是最自然、最优雅的方式。
- **编写递归代码的思维模式**：始终先思考**最简单的情况 (base case)** 是什么，然后思考如何将复杂问题分解，使其向 base case 靠近一步（**recursive step**）。相信递归调用能够正确处理规模更小的子问题（这被称为 "Leap of Faith"）。