## Lecture26 插入排序（Insertion Sort）**和**快速排序（Quicksort）



### Part 1: 插入排序 (Insertion Sort)

插入排序是一种简单直观的排序算法。它的核心思想是**构建一个有序序列**，对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。



#### 1.1 插入排序的两种实现方式

**1. 朴素插入排序 (Naive Insertion Sort)**

这种方法创建一个新的空列表作为输出。然后，它遍历输入列表的每个元素，并将其插入到输出列表的正确位置，以保持输出列表的有序性。

- **基本策略** ：

  - 从一个空的输出序列开始。
  - 依次获取输入序列中的每个元素，并将其插入到输出序列的正确位置，以维持序列的有序性。

- 图例解析：

  <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F1.png" style="zoom: 33%;" />

  - **输入**: `[32, 15, 2, 17, 19, 26, 41, 17, 17]`，**输出**: `[]`

  - 处理 `32` -> **输出**: `[32]`

  - 处理 `15` -> `15` 比 `32` 小，插入到 `32` 前面 -> **输出**: `[15, 32]`

  - 处理 `2` -> `2` 比 `15` 和 `32` 都小 -> **输出**: `[2, 15, 32]`

  - ... 以此类推，直到所有输入元素都插入到输出列表中。

    <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F2.png" style="zoom:33%;" />

这种方法的缺点是需要额外的 Θ(N) 空间来存储输出列表。



**2. 原地插入排序 (In-Place Insertion Sort)**

这是一种更高效的实现方式，它不需要额外的存储空间（空间复杂度为 Θ(1)），直接在原始数组上进行操作。

- **基本策略** ：

  - 从第一个元素开始，我们默认它自身是一个有序的子数组。
  - 遍历数组，从索引 `i = 1` 到 `N-1` 5。在每次迭代中，我们将 `item[i]`（称为“旅行者” traveler）与它左侧已排序部分的元素进行比较。
  - 通过**不断向前交换**，将“旅行者”移动到它在左边已排序部分的正确位置。

- 图例与代码逻辑解析 ：

  我们用一个外部循环 i 来遍历数组，i 左边的部分是已排序的。一个内部指针 j 用于追踪“旅行者”的当前位置。

  ```Java
  // 伪代码解析
  public static void insertionSort(int[] arr) {
      // i 从 1 开始，因为单个元素默认有序
      for (int i = 1; i < arr.length; i++) {
          // j 是当前要插入的元素（旅行者）的索引
          int j = i;
          // 当 j > 0 且旅行者比它前面的元素小时，向前交换
          while (j > 0 && arr[j] < arr[j-1]) {
              swap(arr, j, j-1);
              j--; // j 跟随旅行者移动
          }
      }
  }
  ```

  **图例解析 **：

  1. **i = 1**, 旅行者是 `15` (j=1)。`15 < 32`，交换。数组变为 `[15, 32, 2, ...]`。左侧` [15, 32] `有序。

  2. **i = 2**, 旅行者是 `2` (j=2)。

     - `2 < 32`，交换 -> `[15, 2, 32, ...]` (j=1)
     - `2 < 15`，交换 ->` [2, 15, 32, ...]` (j=0)，循环结束。左侧` [2, 15, 32] `有序。

  3. 这个过程持续进行，直到 `i` 到达数组末尾，整个数组完成排序。

     <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B.gif" style="zoom:50%;" />



#### 1.2 插入排序的性能分析

- **时间复杂度** ：
  - **最坏情况 (Worst Case)**: O(N²)。当数组是完全逆序时，每个元素都需要移动到最开始的位置，比较和交换次数都达到最大。
  - **最好情况 (Best Case)**: Θ(N)。当数组已经基本有序时，每次内部循环只需要进行一次比较，几乎没有交换。
  - **平均情况 (Average Case)**: O(N²)。
- **空间复杂度**：
  - 原地插入排序为 Θ(1)。



#### 1.3 插入排序的“甜蜜点” (Sweet Spots)

尽管插入排序的平均和最坏情况下的时间复杂度是二次的，但它在特定场景下非常高效：

1. 处理“几乎有序”的数组：

   一个衡量数组混乱程度的指标是逆序对 (Inversions) 的数量。逆序对是指数组中一对索引 `i < j `但 `arr[i] > arr[j] `的元素。

   - 原地插入排序的**交换次数恰好等于逆序对的数量**。
   - 其总运行时间可以表示为 Θ(N+K)，其中 K 是逆序对的数量。
   - 因此，当一个数组的逆序对很少时（即“几乎有序”），插入排序的性能接近线性时间 Θ(N)，速度极快。

2. 处理小规模数组：

   对于非常小的数组（例如 N < 15），插入排序通常是所有排序算法中最快的。因为它算法逻辑简单，没有像归并排序或快速排序那样复杂的递归调用开销。

   - **实践应用**：很多高级排序算法（如 Java 内置的 `Arrays.sort()`）在处理小规模子数组时，会切换到插入排序以提升效率。



------

### Part 2: 快速排序 (Quicksort)

快速排序是现实世界中最常用、最高效的排序算法之一 。它由 Tony Hoare 在 1960 年发明，其核心思想是**分而治之 (Divide and Conquer)**，通过一个名为**分区 (Partitioning)** 的精妙操作来实现。



#### 2.1 核心思想：分区 (Partitioning)

分区是快速排序的灵魂。其目标是：**选择一个元素作为“基准”(pivot)，然后重新排列数组，使得所有小于基准的元素都在基准的左边，所有大于或等于基准的元素都在基准的右边。**

- **分区后的效果**：

  - 基准元素此时已经到达了它在最终排序数组中应在的**正确位置**。
  - 数组被基准分成了两个独立的、无序的子数组（左边是“较小”的部分，右边是“较大”的部分）。

- 图例解析：

  <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" style="zoom:50%;" />

  - 假设我们有一个数组，并选择 `5` 作为基准：
  - **输入**: `[5, 3, 2, 1, 8, 4, 6, 7]`
  - 分区后的一种可能结果: `[3, 2, 1, 4, 5, 7, 8, 6]`

  在这个结果中，`5` 已经就位。所有比 `5` 小的数都在左边，所有比 `5` 大的数都在右边。注意，左右两边的子数组内部仍然是无序的。



#### 2.2 快速排序算法

有了分区操作，快速排序的算法就变得非常直观和优雅：

- **算法步骤** ：

  1. 从数组中选择一个基准（pivot）。一个简单的方法是选择最左边的元素。
  2. 对数组进行分区，使得基准到达其最终位置。
  3. 对基准左侧的子数组**递归地**调用快速排序。
  4. 对基准右侧的子数组**递归地**调用快速排序。

- **递归终止条件**：当子数组的大小为 0 或 1 时，它自然就是有序的，递归结束。

- **图例解析 **：

  1. **初始数组**: `[32, 15, 2, 17, 19, 26, 41, 17, 17]`
  2. **分区(32)**: `[15, 2, 17, 19, 26, 17, 17]`, `32`, `[41]`
  3. **递归排序左半部分**: `quicksort([15, 2, ...])`
  4. **递归排序右半部分**: `quicksort([41])` (已完成)

  这个递归过程会像一棵树一样展开，直到所有元素都就位。

  <img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%9B%BE%E7%A4%BA.gif" style="zoom:50%;" />

  



#### 2.3 快速排序的性能与注意事项

快速排序的性能**极大地依赖于基准的选择**。基准选择的好坏直接决定了分区后两个子数组的规模，从而影响递归的深度。

- **时间复杂度**：
  - **最好情况 (Best Case)**: Θ(N log N)。
    - 当每次选择的基准都能**恰好将数组平分**成两个大小几乎相等的子数组时，递归树的深度为 log N。
    - 每一层递归的所有分区操作加起来总共需要处理 N 个元素，时间为 Θ(N)。
    - 总时间 = 深度 × 每层时间 = Θ(N log N)。
  - **最坏情况 (Worst Case)**: Θ(N²)。
    - 当每次选择的基准都是当前子数组的**最大或最小元素**时。例如，对一个**已经有序**的数组，每次都选择最左边的元素作为基准。
    - 分区后，一个子数组为空，另一个子数组大小为 k-1（假设原数组大小为k）。
    - 这导致递归树变成一条链，深度为 Θ(N)。
    - 总时间 = Θ(N) + Θ(N-1) + ... + Θ(1) = Θ(N²)。
  - **平均情况 (Average Case)**: Θ(N log N)。
    - 数学上可以证明，即使基准选择不是完美的，只要它能在一定比例上分割数组（例如 10%-90%），长期来看递归深度仍然是对数级别的。
    - 在随机数据下，快速排序表现非常好，这也是它被广泛使用的原因。
- **如何避免最坏情况？**
  - **随机选择基准**：不总是选择第一个或最后一个元素，而是从子数组中随机选取一个元素作为基准。这使得出现最坏情况的概率变得极小。
  - **三数取中法 (Median-of-three)**：选取子数组的第一个、中间和最后一个元素，并用这三个元素的中位数作为基准。这种方法能有效避免在有序或逆序数组上的最坏情况。
  - **随机打乱数组**：在排序前，先将整个数组随机打乱（Shuffle）。这样，无论输入是什么样的，选择第一个元素作为基准都近似于随机选择。
- **空间复杂度**：
  - 快速排序是原地排序吗？这有点微妙。分区操作是原地的，但递归调用会消耗栈空间。
  - 空间复杂度取决于递归深度。最好情况下是 O(log N)，最坏情况下是 O(N)。

------

### Part 3: 总结与对比



| **特性**       | **插入排序 (In-Place)** | **快速排序**                   |
| -------------- | ----------------------- | ------------------------------ |
| **核心思想**   | 逐个插入已排序部分      | 分区与递归                     |
| **最好时间**   | Θ(N)                    | Θ(N log N)                     |
| **平均时间**   | Θ(N²)                   | Θ(N log N)                     |
| **最坏时间**   | Θ(N²)                   | Θ(N²)                          |
| **空间复杂度** | Θ(1)                    | O(log N) (平均) 到 O(N) (最坏) |
| **稳定性**     | 稳定                    | 不稳定                         |
| **适用场景**   | 小数组、几乎有序的数组  | 大规模、通用数据的排序         |
