## Lecture22 最小生成树（Minimum Spanning Trees, MSTs）



### **第一部分：最小生成树（MSTs）与切割属性（Cut Property）**

#### **1. 什么是生成树（Spanning Tree）？**

在正式学习最小生成树之前，我们先要理解什么是**图（Graph）和生成树（Spanning Tree）**。

- **图 (Graph)**：由一组**顶点（Vertices）和一组连接顶点的边（Edges）构成。我们这里讨论的是无向连通图（Undirected, Connected Graph）**，并且每条边都有一个**权重（Weight）**，代表连接两个顶点的成本或距离。
- **生成树 (Spanning Tree)**：对于一个无向连通图，它的一个生成树是该图的一个**子图（Subgraph）**，这个子图需要满足以下两个条件：
  1. 包含原图中**所有**的顶点。
  2. 它是一棵**树**（Tree）。也就是说，它必须是连通的，并且**没有环（No Cycles）**。

对于一个有 V 个顶点的图，它的任何一棵生成树都有且仅有 **V - 1** 条边。如果再多加一条边，必然会形成一个环；如果少一条边，则无法保证所有顶点都连通。



#### **2. 什么是最小生成树（Minimum Spanning Tree）？**

一个带权重的无向连通图可以有很多棵不同的生成树。其中，所有边的权重之和最小的那棵生成树，就被称为**最小生成树（MST）**。

**核心目标**：用最小的总成本（权重之和）连接图中的所有节点。

**应用场景举例**：

- **网络设计**：在一个城市中铺设光纤网络，要连接所有社区（顶点），并且使得光纤总长度（权重）最短。
- **电路板设计**：在电路板上连接多个引脚，需要用最少的导线长度。
- **交通网络**：建设连接多个城市的铁路，总建设成本最低。



#### **3. 切割属性（The Cut Property）**

这是理解为什么 MST 算法能够正确工作的**基石**，非常重要！

- **切割（Cut）**：一个“切割”操作就是将图中的所有顶点**分成两个非空的、不相交的集合**。我们可以想象在图中画一条线，把顶点分到线的两边。
- **横切边（Crossing Edge）**：一条连接着切割后两个不同集合中顶点的边，我们称之为“横切边”。

**切割属性定理**：

> 对于图中任意一种“切割”，在所有连接两个顶点集的“横切边”中，权重最小的那条边（如果权重唯一），必然属于该图的某一个最小生成树。

**用一个例子来理解这个属性：**

假设我们要在一个国家建立一个铁路网，连接所有城市。我们把所有城市分成两部分：东部城市和西部城市（这就是一次“切割”）。现在有很多条铁路可以连接东西部（这些是“横切边”）。为了让总成本最低，我们应该选择哪条铁路来连接东西部呢？直觉告诉我们，应该选择成本最低的那条铁路。切割属性就是这个直觉的数学证明。

- **图例说明**：
  - 想象一个图，顶点用 A, B, C, D, E, F 表示。
  - 我们做一个切割，将顶点分成两个集合：`S = {A, B, C}` 和 `T = {D, E, F}`。
  - 现在有很多横切边，比如 (B, D) 权重为 5，(C, E) 权重为 3，(A, F) 权重为 8。
  - 根据切割属性，权重为 3 的边 (C, E) **一定**是这个图的某个最小生成树的一部分。

**为什么这个属性是正确的（简要证明思路）？**

假设最小权重横切边 `e` 不在 MST `T` 中。那么 `T` 中必然有另一条横切边 `e'` 连接着这两个集合（否则这两个集合就不连通了）。如果我们把 `e'` 从 `T` 中去掉，再把 `e` 加入，会发生什么？

1. 去掉 `e'` 会使 `T` 分裂成两个部分，正好是我们切割的两个集合。
2. 加入 `e` 会重新将这两个部分连接起来，形成一棵新的生成树 `T_new`。
3. 因为 `e` 的权重小于 `e'`，所以新生成树 `T_new` 的总权重比 `T` 还要小。
4. 这就与 `T` 是 MST 的假设相矛盾了！所以，我们的假设“`e` 不在 MST 中”是错误的。因此，最小权重的横切边 `e` 必须在 MST 中。

切割属性为我们提供了一个**贪心（Greedy）**构建 MST 的思路：**不断地寻找并加入权重最小且不会形成环的安全边**。Prim 算法和 Kruskal 算法都是基于这个思想设计的。

------



### **第二部分：Prim 算法**

Prim 算法就像“扩张领地”一样，从一个起始顶点开始，逐步将周围最“便宜”的顶点和边纳入自己的集合，直到覆盖所有顶点。



#### **1. 算法思想**

1. 初始化一个空的 MST 集合。
2. 任选一个顶点作为**起始点**，并将其加入 MST 集合（此时 MST 集合中只有一个点）。
3. 重复以下步骤，直到所有顶点都被加入 MST 集合： a.  做一个“切割”，将已加入 MST 的顶点作为一个集合，未加入的顶点作为另一个集合。 b.  在所有连接这两个集合的“横切边”中，找到那条权重最小的边。 c.  将这条最小权重的边和它连接的那个“新”顶点加入到 MST 集合中。



#### **2. 步骤图解**

我们用一个具体的例子来走一遍 Prim 算法的流程。

**图例：** 一个图有顶点 A, B, C, D, E, F。边的权重如下： (A, B, 2), (A, C, 3), (B, C, 1), (B, D, 1), (B, E, 4), (C, F, 5), (D, E, 2), (E, F, 3)

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%9C%80%E5%B0%8F%E6%A0%911.png)

- **Step 1: 选择起点**
  - 我们选择顶点 A 作为起点。
  - **MST 集合**：`{A}`
  - **MST 边**：`{}`
  - **横切边**：(A, B, 2), (A, C, 3)
- **Step 2: 找到最小横切边**
  - (A, B, 2) 的权重小于 (A, C, 3)。选择边 (A, B)。
  - 将 B 加入 MST 集合。
  - **MST 集合**：`{A, B}`
  - **MST 边**：`{(A, B, 2)}`
  - **新的横切边**：(A, C, 3), (B, C, 1), (B, D, 1), (B, E, 4)
- **Step 3: 再次找到最小横切边**
  - 在新的横切边中，(B, C, 1) 和 (B, D, 1) 权重最小（都是 1）。随便选一个，比如 (B, C)。
  - 将 C 加入 MST 集合。
  - **MST 集合**：`{A, B, C}`
  - **MST 边**：`{(A, B, 2), (B, C, 1)}`
  - **新的横切边**：(A, C, 3)（注意这条边现在连接两个已在集合内的点，不再是横切边了，要忽略）, (B, D, 1), (B, E, 4), (C, F, 5)
- **Step 4: 继续...**
  - 最小横切边是 (B, D, 1)。将 D 加入。
  - **MST 集合**：`{A, B, C, D}`
  - **MST 边**：`{(A, B, 2), (B, C, 1), (B, D, 1)}`
  - **新的横切边**：(B, E, 4), (C, F, 5), (D, E, 2)
- **Step 5: 继续...**
  - 最小横切边是 (D, E, 2)。将 E 加入。
  - **MST 集合**：`{A, B, C, D, E}`
  - **MST 边**：`{(A, B, 2), (B, C, 1), (B, D, 1), (D, E, 2)}`
  - **新的横切边**：(B, E, 4)（忽略）, (C, F, 5), (E, F, 3)
- **Step 6: 最后一步**
  - 最小横切边是 (E, F, 3)。将 F 加入。
  - **MST 集合**：`{A, B, C, D, E, F}` (所有顶点都已加入)
  - **MST 边**：`{(A, B, 2), (B, C, 1), (B, D, 1), (D, E, 2), (E, F, 3)}`

算法结束。我们得到的 MST 总权重是 2 + 1 + 1 + 2 + 3 = 9。



#### **3. 代码实现与数据结构**

如何高效地找到“最小横切边”呢？这正是**优先队列（Priority Queue）**大显身手的地方。

我们可以用一个优先队列来存储所有横切边，并按权重从小到大排序。

**伪代码：**

```
function Prims(Graph G):
  // 初始化
  MST = {} // 存储MST的边
  visited = {} // 记录已访问的顶点
  pq = new PriorityQueue() // 存储横切边，按权重排序

  // 1. 选择一个起始顶点
  start_vertex = G.vertices[0]
  visited.add(start_vertex)

  // 2. 将起始点的所有邻边加入优先队列
  for edge in start_vertex.edges:
    pq.add(edge)

  // 3. 循环直到pq为空或已访问V个顶点
  while not pq.isEmpty() and visited.size() < G.num_vertices:
    // a. 取出权重最小的横切边
    min_edge = pq.poll()
    
    // b. 找到这条边连接的“新”顶点
    u, v = min_edge.vertices
    new_vertex = (v if u in visited else u)

    // c. 如果这个新顶点已经访问过，则跳过（避免形成环）
    if new_vertex in visited:
      continue

    // d. 否则，将该边和顶点加入MST
    MST.add(min_edge)
    visited.add(new_vertex)

    // e. 将新顶点的所有邻边加入pq，但只加那些连接到未访问顶点的边
    for edge in new_vertex.edges:
      if edge.other_vertex(new_vertex) not in visited:
        pq.add(edge)

  return MST
```

**复杂度分析**：

- 假设图有 V 个顶点和 E 条边。
- 我们最多需要将 E 条边都加入一次优先队列。
- 每次从优先队列中取出最小元素的操作是 `log(E)`。
- 总的时间复杂度是 **O(E log E)**。如果使用更高级的数据结构（斐波那契堆），可以优化到 **O(E + V log V)**，但在稠密图中 O(E log V) 更常见。

------



### **第三部分：Kruskal 算法**

Kruskal 算法则更为“直接”，它不从一个点开始扩张，而是从全局视角出发，把所有边看作独立的“零件”，然后按成本从小到大把它们“组装”起来，只要不形成环路就行。



#### **1. 算法思想**

1. 创建一个森林（forest），其中每个顶点都是一棵独立的树。
2. 将图中所有的边按照权重**从小到大排序**。
3. 遍历排序后的边，对于每一条边 `(u, v)`： a.  检查顶点 `u` 和 `v` 是否已经在同一棵树（或同一个连通分量）中。 b.  如果**不在**同一棵树中，就将这条边加入到 MST 中，并合并 `u` 和 `v` 所在的树。 c.  如果**在**同一棵树中，则**忽略**这条边（因为加入它会形成一个环）。
4. 当 MST 中的边数达到 V - 1 时，算法结束。



#### **2. 步骤图解**

我们用同样的图例来走一遍 Kruskal 算法。

**图例边排序：** (B, C, 1), (B, D, 1), (A, B, 2), (D, E, 2), (A, C, 3), (E, F, 3), (B, E, 4), (C, F, 5)

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%9C%80%E5%B0%8F%E6%A0%911.png)

- **初始状态**：森林 `{A}, {B}, {C}, {D}, {E}, {F}`。每个顶点自成一派。
- **Step 1: 考虑边 (B, C, 1)**
  - B 和 C 在不同的集合中。
  - 加入此边。合并 `{B}` 和 `{C}`。
  - **MST 边**：`{(B, C, 1)}`
  - **森林**：`{A}, {B, C}, {D}, {E}, {F}`
- **Step 2: 考虑边 (B, D, 1)**
  - B 和 D 在不同的集合中（B 在 `{B, C}` 中，D 在 `{D}` 中）。
  - 加入此边。合并 `{B, C}` 和 `{D}`。
  - **MST 边**：`{(B, C, 1), (B, D, 1)}`
  - **森林**：`{A}, {B, C, D}, {E}, {F}`
- **Step 3: 考虑边 (A, B, 2)**
  - A 和 B 在不同的集合中。
  - 加入此边。合并 `{A}` 和 `{B, C, D}`。
  - **MST 边**：`{(B, C, 1), (B, D, 1), (A, B, 2)}`
  - **森林**：`{A, B, C, D}, {E}, {F}`
- **Step 4: 考虑边 (D, E, 2)**
  - D 和 E 在不同的集合中。
  - 加入此边。合并 `{A, B, C, D}` 和 `{E}`。
  - **MST 边**：`{... (A, B, 2), (D, E, 2)}`
  - **森林**：`{A, B, C, D, E}, {F}`
- **Step 5: 考虑边 (A, C, 3)**
  - 检查 A 和 C。它们都在同一个集合 `{A, B, C, D, E}` 中。
  - **忽略**此边，否则会形成 A-B-C-A 的环。
- **Step 6: 考虑边 (E, F, 3)**
  - E 和 F 在不同的集合中。
  - 加入此边。合并 `{A, B, C, D, E}` 和 `{F}`。
  - **MST 边**：`{... (D, E, 2), (E, F, 3)}`
  - **森林**：`{A, B, C, D, E, F}` (所有顶点都在一个集合里了)
- 此时我们已经有了 V-1 = 5 条边，算法结束。得到的 MST 与 Prim 算法找到的完全一样。



#### **3. 代码实现与数据结构**

Kruskal 算法的关键在于如何高效地“检查两个顶点是否在同一棵树中”以及“合并两棵树”。这正是**并查集（Union-Find）**数据结构的用武之地。

- `find(p)`: 查找元素 p 所在集合的代表元（根节点）。
- `union(p, q)`: 合并 p 和 q 所在的两个集合。

**伪代码：**

```
function Kruskals(Graph G):
  MST = {}
  pq = new PriorityQueue() // 存储所有边
  for edge in G.edges:
    pq.add(edge)

  uf = new UnionFind(G.vertices) // 初始化并查集，每个顶点一个集合

  while not pq.isEmpty() and MST.size() < G.num_vertices - 1:
    // 1. 取出权重最小的边
    edge = pq.poll()
    u, v = edge.vertices
    
    // 2. 检查 u 和 v 是否在同一个集合
    if not uf.connected(u, v):
      // 3. 如果不在，加入MST并合并
      uf.union(u, v)
      MST.add(edge)

  return MST
```

**复杂度分析**：

- **排序所有边**：将 E 条边放入优先队列（或直接排序），时间复杂度为 **O(E log E)**。
- **并查集操作**：接下来有 E 次 `find` 操作和 V-1 次 `union` 操作。使用路径压缩和按秩合并优化的并查集，这些操作的平均时间复杂度接近常数，可以认为是 O(α(V))，其中 α 是反阿克曼函数，增长极其缓慢。总的操作可以近似看作 **O(E α(V))**。
- 算法的**瓶颈在于排序**，所以总的时间复杂度是 **O(E log E)**。

------



### **第四部分：总结与对比**

现你已经学习了两种构造最小生成树的经典算法，我们来做一个总结和对比。

| 特性         | Prim 算法                                                    | Kruskal 算法                                                 |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **基本思想** | 从一个点开始，不断添加最近的顶点和边来**“生长”一棵树**。     | 从全局出发，选择权重最小的边，逐步将**森林合并成一棵树**。   |
| **数据结构** | **优先队列** (存储横切边)                                    | **优先队列** (存储所有边) + **并查集** (检测环)              |
| **关注点**   | 以**顶点**为中心，决策下一步该将哪个顶点纳入树中。           | 以**边**为中心，决策下一步该将哪条边加入森林中。             |
| **复杂度**   | O(E log E) 或 O(E + V log V)                                 | O(E log E)                                                   |
| **适用场景** | **稠密图**（边 E 接近 V^2）时，使用斐波那契堆优化的 Prim (O(E + V log V)) 更具优势。 | **稀疏图**（边 E 远小于 V^2）时，Kruskal 算法通常更简单且高效。 |
| **中间状态** | 始终保持一棵连通的树。                                       | 始终保持一个（可能不连通的）森林。                           |

**核心要点回顾：**

1. **MST** 是用最小总权重连接图中所有顶点的边的集合。
2. **Cut Property** 是 MST 算法正确性的理论基础，它保证了贪心选择的正确性。
3. **Prim 算法**是“加点法”，像一棵树不断生长。
4. **Kruskal 算法**是“加边法”，像搭积木一样把森林拼成一棵树。