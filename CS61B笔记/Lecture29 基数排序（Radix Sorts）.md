## Lecture29 基数排序（Radix Sorts）



### 1. 基石：Counting Sort (计数排序)

在学习基数排序之前，我们必须先掌握它的一个重要子程序：**计数排序**。计数排序是一种非比较排序算法，适用于待排序的键（key）是来自一个已知范围（我们称之为“字母表”，Alphabet）的整数。



#### 核心思想

计数排序的核心思想是“**以空间换时间**”。它不通过比较来决定顺序，而是通过计算每个元素出现的次数来直接确定其在最终排好序的数组中的位置。



#### 算法步骤

假设我们要对一组对象进行排序，这些对象的键是来自一个大小为 R 的有限字母表中的字符。

1. **计数 (Counts):** 创建一个大小为 R 的数组 `counts`，用来统计每个键出现的频率。遍历原始数组，对于每个元素，将其对应键的计数值加一。
2. **计算起始位置 (Starting Points):** 改造 `counts` 数组，使其存储每个键在排序后数组中的起始索引。这可以通过计算计数的累积和（cumulative sum）来实现。`starts[k]` 就表示键为 `k` 的第一个元素应该存放的位置。
3. **排序放置 (Placement):** 创建一个与原数组等大的新数组 `sorted`。再次遍历**原数组**（注意，为了保证稳定性，从头到尾遍历很重要），对于每个元素，根据 `starts` 数组找到它应该在 `sorted` 数组中的位置，将其放入，然后将该键对应的 `starts` 值加一，为下一个拥有相同键的元素准备位置。
4. **回填 (Copy Back):** 将 `sorted` 数组的内容复制回原数组。



#### 图解示例

让我们用讲义中对扑克牌花色排序的例子来走一遍这个流程。

字母表为：`{♣ (Club), ♠ (Spade), ♥ (Heart), ♦ (Diamond)}`，分别对应索引 0, 1, 2, 3。

**初始状态:**

**Step 1: 计数 (Counts)**  遍历原数组，统计每种花色的数量。

- `counts[0]` (♣): 3
- `counts[1]` (♠): 2
- `counts[2]` (♥): 4
- `counts[3]` (♦): 3

**Step 2: 计算起始位置 (Starting Points)**  计算累积和，确定每个分组的起始点。

- `starts[0]` (♣): 0
- `starts[1]` (♠): `starts[0]` + `counts[0]` = 0 + 3 = 3
- `starts[2]` (♥): `starts[1]` + `counts[1]` = 3 + 2 = 5
- `starts[3]` (♦): `starts[2]` + `counts[2]` = 5 + 4 = 9

**Step 3: 排序放置 (Placement)**  遍历原数组，将元素放入 sorted 数组。

1. 第一个元素是 "Lauren" (♠)，`starts[1]` 是 3。将 "Lauren" 放入 `sorted[3]`，`starts[1]` 更新为 4。
2. 第二个元素是 "Delbert" (♥)，`starts[2]` 是 5。将 "Delbert" 放入 `sorted[5]`，`starts[2]` 更新为 6。
3. ... 以此类推，直到所有元素都被放置。

<img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" style="zoom:50%;" />



**最终结果:**

<img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.png" style="zoom:50%;" />



#### 性能分析

- **时间复杂度**: Θ(N+R) 。其中 N 是待排序元素的数量，R 是字母表的大小。
  - 遍历原数组统计数量：Θ(N)
  - 创建和计算起始位置数组：Θ(R)
  - 遍历原数组进行放置：Θ(N)
- **空间复杂度**: Θ(N+R)。需要一个大小为 R 的 `counts` 数组和一个大小为 N 的 `sorted` 数组。



#### 局限性

计数排序非常快，但它的“命门”在于对 R 非常敏感。如果 R 远远大于 N，那么性能会急剧下降，并且会消耗大量内存。例如，用它来给100个大城市按人口排序，R 可能是最大的人口数（如东京的3700万），而 N 只有100，这显然是不可行的。



------

### 2. 核心思想：稳定排序与按位排序

我们无法直接用计数排序来排复杂的数据（比如很长的数字或字符串），但我们可以把它们**分解**成一个个独立的“数位”（digit）。例如，数字 `322` 可以看作 `3`、`2`、`2` 三个“数位”。每个数位的字母表都很小（比如十进制数，R=10），非常适合用计数排序。

这就引出了基数排序的核心操作：**按位排序 (Digit-by-digit Sorting)** 。

要让按位排序最终能得到正确的结果，我们使用的排序子程序（在这里就是计数排序）**必须是稳定的 (Stable)**。

**什么是稳定排序？**

一个排序算法是稳定的，指的是如果两个元素在排序前后的键值相同，那么它们在排序后的相对顺序保持不变。比如，`(Jana, 3)` 和 `(Jouni, 3)`，按数字排序后，如果 `Jana` 仍然在 `Jouni` 前面，这个排序就是稳定的。

**为什么稳定性至关重要？**

看下面这个例子。假设我们先按最低位排好序（使用稳定排序），结果如下：

`[41, 31, 22, 12, 32, 42, 53, 23, 34, 34]`

现在，我们再对这个结果按最高位进行一次稳定排序。

当处理所有最高位为 "3" 的数字 (`31, 32, 34, 34`) 时，因为排序是稳定的，它们会保持之前的相对顺序。而我们知道，之前的顺序是按最低位排好的 (`1 < 2 < 4`)。所以排序后它们会自然地变成 `31, 32, 34, 34`。

最终，整个数组就会完全有序。如果使用的排序不稳定，那么之前排好的低位顺序就会被打乱，最终结果也是错误的。



------

### 3. LSD Radix Sort (最低位优先基数排序)

这是最常见也最直观的一种基数排序。



#### 算法步骤

LSD (Least Significant Digit) Radix Sort 正如其名，从**最低有效位**（最右边）开始，逐位向**最高有效位**（最左边）进行排序。

1. 确定所有键的最大宽度 W。
2. 从第 `d = 0` 位（最低位）到第 `d = W-1` 位（最高位），重复以下操作：
   - 使用一个**稳定的排序算法**（通常是计数排序）根据当前第 `d` 位对所有元素进行排序。



#### 图解示例

<img src="https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%9C%80%E4%BD%8E%E4%BD%8D%E4%BC%98%E5%85%88%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" style="zoom:50%;" />

**初始数组:** `[322, 141, 112, 434, 341, 412, ...]`

**Pass 1: 按最低位 (个位) 排序**

- 对个位数 `2, 1, 2, 4, 1, 2, ...` 进行稳定排序。
- 结果: `[141, 341, 322, 112, 412, 223, ...]` (所有个位为1的在前，个位为2的次之...)

**Pass 2: 按中间位 (十位) 排序**

- 对上一步的结果，根据十位数 `4, 4, 2, 1, 1, 2, ...`进行稳定排序。
- 结果: `[112, 412, 322, 223, 331, 141, ...]` (十位为1的在前，十位为2的次之...)

**Pass 3: 按最高位 (百位) 排序**

- 对上一步的结果，根据百位数 `1, 4, 3, 2, 3, 1, ...` 进行稳定排序。
- 结果: `[112, 141, 223, 234, 322, 331, ...]` (百位为1的在前，百位为2的次之...)

经过三轮排序，整个数组已经完全有序。



#### 关于不等长键的处理

如果键的长度不同（如字符串 "cat" 和 "rhino"），我们可以将较短的键用一个比字母表中任何字符都小的特殊字符进行“填充”。例如，`"cat"` 可以看作 `".cat"`，`"rhino"` 可以看作 `"rhino"`，然后按最大长度对齐进行排序。



#### 性能分析

- **时间复杂度**: Θ(W(N+R))。

  - W: 键的最大宽度（位数）。
  - N: 元素数量。
  - R: 单个数位的字母表大小（如十进制是10，ASCII是256）。
  - 这个公式的含义是：我们需要执行 W 轮计数排序，每一轮的成本是 Θ(N+R)。

- **空间复杂度**: Θ(N+R)。主要开销来自计数排序内部的辅助数组。

  

------

### 4. MSD Radix Sort (最高位优先基数排序)

MSD (Most Significant Digit) Radix Sort 则是从**最高有效位**（最左边）开始排序。



#### 算法步骤

MSD 排序是一个**递归**过程：

1. 首先，根据**最高位**对整个数组进行一次稳定的计数排序。
2. 排序后，所有最高位相同的元素会聚集在一起，形成多个“桶”（bin）。例如，所有以'a'开头的单词在一个桶，以'b'开头的在另一个桶。
3. 对**每一个桶**内的元素，**递归地**调用 MSD 排序，但这次是根据**下一位**进行排序。
4. 递归的终止条件是：桶里只剩下一个元素，或者已经处理完所有数位。



#### 与 LSD 的关键区别

- **顺序**: LSD 从右到左，MSD 从左到右。
- **过程**: LSD 是迭代的，每一轮都对**整个数组**进行操作。MSD 是递归的，它将问题分解成**独立的子问题**（对每个桶进行排序）。
- **效率**: MSD 可能更有效率。如果最高几位已经能区分大部分元素，MSD 就不需要再检查所有元素的低位了。例如，排序 "Apple" 和 "Zebra"，仅看首字母就已经完成排序，MSD 不会再去看后面的字符。而 LSD 必须完整地处理完所有 W 位。



#### 性能分析

- **时间复杂度**:

  - **最佳情况**: Θ(N+R)。
    - 如果第一轮排序后所有元素都被分到不同的桶中（即首位各不相同），排序就完成了。
  - **最坏情况**: Θ(W(N+R))。
    - 如果所有键都非常相似（例如，所有键的前缀都相同），MSD 就需要深入到每一位，表现得和 LSD 一样。

- **空间复杂度**: Θ(N+WR) 。

  - 除了计数排序本身的空间开销，递归调用栈也会占用空间，最坏情况下可能需要 WR 的空间来管理这些桶。

  

------

### 5. 总结与对比

让我们来整理一下今天学习的排序算法以及之前学过的比较排序算法的特点。

| **排序算法**       | **空间复杂度**  | **最坏情况时间复杂度** | **是否稳定?** | **备注**                         |
| ------------------ | --------------- | ---------------------- | ------------- | -------------------------------- |
| Heapsort           | Θ(1)            | Θ(N log N)             | No            | 缓存性能较差                     |
| Mergesort          | Θ(N)            | Θ(N log N)             | Yes           | 稳定的比较排序中速度最快         |
| Quicksort          | Θ(log N) (期望) | Θ(N log N) (期望)      | No            | 通常是速度最快的比较排序         |
| **Counting Sort**  | Θ(N+R)          | Θ(N+R)                 | Yes           | 仅适用于键在小范围内的场景       |
| **LSD Radix Sort** | Θ(N+R)          | Θ(W(N+R))              | Yes           | 简单，迭代，对所有键一视同仁     |
| **MSD Radix Sort** | Θ(N+WR)         | Θ(W(N+R))              | Yes           | 递归，可能提前结束，但实现更复杂 |



#### Java 中的 `Arrays.sort()`

一个有趣的知识点是 Java 内置排序函数的选择：

- 对于**原始数据类型** (primitives like `int[]`)，它使用**快速排序 (Quicksort)**。因为对于 `int` 来说，一个 `5` 和另一个 `5` 是完全没有区别的，所以不需要稳定的排序，而不稳定的 Quicksort 通常更快。
- 对于**对象类型** (Objects like `String[]`)，它使用 **TimSort**，这是一种结合了归并排序和插入排序的**稳定**算法。因为对象可能包含多个属性，我们有时希望在按一个属性排序后，保持由另一属性决定的原始顺序，这时稳定性就非常重要。