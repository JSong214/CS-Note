## Lecture21 (新) “最短路径” (Shortest Paths) 



### 1. 问题的提出：为什么BFS不够用？

在我们之前的学习中，我们已经接触过两种图的遍历算法：深度优先搜索（DFS）和广度优先搜索（BFS） 。特别是BFS，它能够找到从源点`s`到所有可达顶点的**边数最少**的路径 。

这听起来很棒，但它符合现实世界中的“最短”吗？

想象一下你在用地图导航 。假设从起点 `s` 到终点 `t` 有两条路：

- **路线1**：`s -> A -> t`。经过2条路（2个edge）。
- **路线2**：`s -> B -> C -> D -> t`。经过4条路（4个edge）。

如果用BFS，它会告诉你路线1是“最短”的，因为它经过的边更少。但如果路线1是总长330米的乡间小路，而路线2是总长130米的高速公路呢？ 

图1：BFS在加权图中的选择。左图是BFS找到的路径（边数少，但总距离长），右图是真正的最短路径（边数多，但总距离短）。 

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.png)



这就引出了核心问题：现实世界中的路径通常带有**权重（weights）或成本（costs）**，例如距离、时间、费用等。BFS无法处理这些权重，它默认每条边的权重都为1 。因此，我们需要更强大的算法来解决**加权图（weighted graph）**中的最短路径问题 。





### 2. 我们的目标：最短路径树 (Shortest Paths Tree, SPT)

当我们讨论从一个源点（single source）出发的最短路径时，我们通常不仅仅是想知道到某一个点的最短路径，而是到**所有可达点**的最短路径 。这个问题的解，可以完美地用一个叫做**最短路径树 (Shortest Paths Tree, SPT)** 的结构来表示 。



**什么是SPT？** 给定一个图 `G` 和一个源点 `s`，`s` 的SPT是原图的一个子图，它满足：

1. 它是一棵树，且根节点是 `s`。
2. 它包含了从 `s` 到图中所有可达顶点的最短路径 。

可以把它想象成从源点 `s` 出发，所有最短路径的并集 。

图2：左侧是原始的加权图，右侧是从源点 A 出发构建的SPT。 

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/SPT.png)



**SPT的性质：**

- **边的数量**：如果一个图有 `V` 个顶点，且所有顶点都从源点可达，那么它的SPT将有 `V-1` 条边 。这是因为除了源点，每个顶点都只有一个指向它的父节点（前驱节点）的边 。

- **无环**：最短路径本身不会包含环（假设所有边的权重都是非负的），因为绕一圈再回来只会增加路径长度，不会让它变得更短 。

  

我们的主要任务，就是找到一个高效的算法来构建这棵SPT。



### 3. Dijkstra 算法：构建SPT的核心

Dijkstra（迪杰斯特拉）算法是解决单源最短路径问题最经典、最重要的算法之一。它的核心思想非常优雅：**一种贪心策略**。



#### 3.1 算法思想的演进

让我们跟随讲义的思路，看看如何一步步“发明”出Dijkstra算法。

1. **失败的尝试**：

   - **DFS/BFS直接应用**：行不通，因为它们忽略了权重 。

   - **引入“松弛”操作 (Edge Relaxation)**：这是一个至关重要的概念。对于一条边 `v -> w`，如果我们发现从源点 `s` 经由 `v` 到达 `w` 的路径比当前已知的到 `w` 的最短路径还要短，我们就更新到 `w` 的最短路径 。

     ```java
     // 松弛操作伪代码
     if (distTo[v] + weight(v, w) < distTo[w]) {
         distTo[w] = distTo[v] + weight(v, w);
         edgeTo[w] = v; // 记录w的前驱节点是v
     }
     ```

   - **最好的优先 (Best-First)**：我们直觉上会觉得，应该优先处理离源点最近的顶点 。我们可以用一个**优先队列（Priority Queue）**来存放待访问的顶点（我们称之为“Fringe”），并总是取出距离最小的那个顶点进行处理 。

2. **组合与完善**： 将“松弛操作”和“最好优先”结合起来，就诞生了Dijkstra算法。该算法保证了，每当我们从优先队列中取出一个顶点 `v` 时，我们已经找到了从源点 `s` 到 `v` 的最终最短路径 。



#### 3.2 Dijkstra 算法详解

**核心组件：**

- `distTo[v]`: 记录从源点 `s`到顶点 `v` 的当前已知的最短距离 。
- `edgeTo[v]`: 记录在最短路径上，`v` 的前一个顶点是什么 。`edgeTo` 数组最终会定义出SPT的结构。
- **优先队列 (PQ)**: 存放所有待访问的顶点，并根据 `distTo` 的值进行排序，`distTo` 最小的顶点优先级最高 。



算法步骤 ：

1. **初始化**：
   - 将 `distTo[s]` 设为 0，所有其他顶点的 `distTo` 设为无穷大 (∞) 。
   - 将所有顶点加入优先队列 `PQ`，优先级由 `distTo` 值决定 。
2. **循环处理**：
   - 当 `PQ` 不为空时，重复以下操作：
     - 从 `PQ` 中取出优先级最高（即 `distTo` 值最小）的顶点 `v` 。这个顶点现在被认为是“已访问”的。
     - 对从 `v` 出发的所有边 `v -> w`，进行**松弛**操作 。
     - 如果松弛成功（即 `distTo[w]` 被更新），则需要同步更新 `w` 在 `PQ` 中的优先级 。



#### 3.3 图解Dijkstra执行过程



让我们用讲义中的例子来完整地走一遍Dijkstra算法。源点是 A。

*图3：我们将在这个图上运行Dijkstra算法，源点为A。*

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/Dijkstra.png)

**初始化:**

- `distTo` = {A:0, B:∞, C:∞, D:∞, E:∞, F:∞, G:∞}
- `edgeTo` = {all null}
- `PQ` = [(A, 0), (B, ∞), (C, ∞), (D, ∞), (E, ∞), (F, ∞), (G, ∞)]

**Step 1:**

- 从 `PQ` 中取出 `A`。
- **松弛 A 的邻居**:
  - 边 A -> B (权重2): `distTo[A] + 2 = 2` < `distTo[B]` (∞)。更新 `distTo[B]=2`, `edgeTo[B]=A`。更新PQ。
  - 边 A -> C (权重1): `distTo[A] + 1 = 1` < `distTo[C]` (∞)。更新 `distTo[C]=1`, `edgeTo[C]=A`。更新PQ。
- `distTo` = {A:0, B:2, C:1, D:∞, E:∞, F:∞, G:∞}
- `PQ` = [(C, 1), (B, 2), (D, ∞), (E, ∞), (F, ∞), (G, ∞)] 

**Step 2:**

- 从 `PQ` 中取出 `C`。
- **松弛 C 的邻居**:
  - 边 C -> E (权重1): `distTo[C] + 1 = 2` < `distTo[E]` (∞)。**等一下，这个例子图里没有 C->E，是C->F。我们以讲义的图为准，应该是松弛 C->F 和 C->E (如果存在)。在讲义图11页中，C->E的权重是1。** `distTo[C] + 1 = 2` < `distTo[E]`。更新`distTo[E]=2`, `edgeTo[E]=C`。
  - 边 C -> F (权重15): `distTo[C] + 15 = 16` < `distTo[F]` (∞)。更新 `distTo[F]=16`, `edgeTo[F]=C`。
- `distTo` = {A:0, B:2, C:1, D:∞, E:2, F:16, G:∞}
- `PQ` = [(B, 2), (E, 2), (F, 16), (D, ∞), (G, ∞)]

... 以此类推，直到 `PQ` 为空。最终 `distTo` 和 `edgeTo` 数组就构建出了完整的SPT。



#### 3.4 正确性与局限性

- **为什么Dijkstra是正确的？** 其正确性依赖于一个关键属性：当一个顶点 `v` 被从优先队列中选出时，`distTo[v]` 已经是 `s`到`v` 的最终最短距离 。
  - **简要证明**：假设存在一条更短的路径到 `v`。这条更短的路径必然要经过某个还在 `PQ` 中的顶点 `p`。但因为 `p` 还在 `PQ` 中，意味着 `distTo[p] >= distTo[v]` (否则 `p` 会先被选出)。又因为所有边的权重都是非负的，所以从 `p` 再走到 `v` 的路径长度必然不小于 `distTo[p]`，也就更不可能小于 `distTo[v]`。这与假设矛盾 。
- **局限性：负权重边** 上面的证明完全建立在“边权重非负”这个前提上。如果图中存在**负权重边**，Dijkstra算法可能会给出错误的结果 。因为“先到达一个近的点，其距离就已经确定”这个贪心选择的前提被打破了。我们可能会先确定一个点的最短路，但之后却发现可以通过一个更远的点绕一条负权边回来，从而得到更短的路径 。



#### 3.5 运行时间分析

Dijkstra算法的效率主要取决于优先队列的操作效率。在一个有 `V` 个顶点和 `E` 条边的图中：

- `add` (或 `insert`) 操作：最多 `V` 次。
- `removeSmallest` (或 `deleteMin`) 操作：`V` 次。
- `changePriority` (或 `decreaseKey`) 操作：最多 `E` 次（每次成功的松弛）。

如果使用基于**二叉堆（Binary Heap）**的优先队列，每次操作的成本是 O(logV)。因此，总时间复杂度为： V×O(logV)+E×O(logV)=O((V+E)logV) 对于连通图，通常 E>V，所以我们简化为 O(ElogV) 。



### 4. A* 算法：更智能的寻路

Dijkstra算法非常强大，但它有一个“盲目”的缺点：它会以源点为中心，向所有方向平均地探索 。在地图导航这种“点对点”的应用中，我们从丹佛到纽约，真的有必要去探索开往洛杉矶方向的路径吗？ 

A* 算法就是为了解决这个问题而生的。它为Dijkstra的“贪心”策略增加了一个**方向感**。



#### 4.1 A* 的核心思想

A* 算法是Dijkstra算法的改进版。它在决定下一个要探索的顶点时，不仅考虑该顶点**距离起点的已知距离**，还会考虑一个**到终点的估计距离** 。

具体来说，Dijkstra的PQ中顶点的优先级由 `distTo[v]` (即 `d(source, v)`) 决定。而A* 的PQ中，顶点的优先级由 `d(source, v) + h(v, goal)` 决定 。

- `d(source, v)`: 从起点到顶点 `v` 的已知最短距离（和Dijkstra一样）。
- `h(v, goal)`: 从顶点 `v` 到终点 `goal` 的**估计距离**。这个函数被称为**启发式函数（heuristic function）** 。

这个启发式函数 `h` 指导着算法的搜索方向。如果一个顶点 `v` 离终点 `goal` 很近（`h(v, goal)` 值小），那么它在PQ中的优先级就会被提高，从而被更早地探索。



#### 4.2 启发式函数 (Heuristics)

启发式函数的选择至关重要，它直接影响A* 算法的效率和正确性。

- **好的启发式函数**：在地图应用中，一个绝佳的启发式函数就是两点间的**直线距离（“as-the-crow-flies” distance）** 。它计算简单，并且能很好地估计实际的驾驶距离。

- **对启发式函数的要求**： 为了保证A* 算法能找到真正的最短路径，启发式函数 `h` 必须是**可采纳的（Admissible）** 。

  - **Admissible Heuristic**: 对于任何顶点 `v`，`h(v, goal)` 的值必须**小于或等于**从 `v` 到 `goal` 的**实际最短路径**的长度 。换句话说，启发式函数**不能高估**到终点的距离。
  - 直线距离就是一个典型的可采纳启发式，因为两点之间直线最短。

- **启发式函数的影响**：

  - 如果 `h(v, goal) = 0`，A* 算法就退化成了Dijkstra算法 。

  - 如果 `h` 是可采纳的，A* 保证找到最短路径。

  - 如果 `h` 不是可采纳的（高估了距离），A* 可能会被误导，从而找到一条次优路径 。比如，如果我们错误地认为伊利诺伊州离纽约特别远（设置一个超大的 `h` 值），算法可能会绕开这个州，从而错过真正的最短路径 。

    

#### 4.3 A* vs. Dijkstra

- **相同点**：A* 的底层框架和Dijkstra几乎完全一样，都是基于优先队列和边松弛。
- **不同点**：唯一的区别在于计算优先队列中顶点的优先级的方式。Dijkstra只用 `d(s, v)`，而 A* 使用 `d(s, v) + h(v, goal)`。

A* 通过启发式函数，将搜索范围“拉向”终点，从而避免了大量无效的探索，在点对点寻路问题上通常比Dijkstra快得多 。



### 5. 总结

让我们来总结一下今天学习的几种最短路径算法。

| 问题类型                          | 算法                       | 权重要求                      | 时间复杂度 (邻接表)    | 空间复杂度 |
| --------------------------------- | -------------------------- | ----------------------------- | ---------------------- | ---------- |
| **单源最短路径 (Unweighted)**     | Breadth-First Search (BFS) | 所有边权重为1                 | O(V+E)                 | Θ(V)       |
| **单源最短路径 (Weighted)**       | Dijkstra's Algorithm       | 非负权重                      | O(ElogV)               | Θ(V)       |
| **单源单目标最短路径 (Weighted)** | A* Search Algorithm        | 非负权重 & 可采纳的启发式函数 | 取决于启发式函数的好坏 | Θ(V)       |