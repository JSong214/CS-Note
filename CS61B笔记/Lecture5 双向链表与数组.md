## Lecture5 双向链表与数组



### **第一部分：双向链表 (Doubly Linked Lists - DLLists)**

双向链表（DLList）是对我们已经熟悉的单向链表（SLList）的一种重要升级。



#### **1. 核心定义与结构**

- **单向链表 (SLList) 节点**: 只包含 `item`（数据）和 `next`（指向下一个节点的指针）。
- **双向链表 (DLList) 节点**: 包含三个部分：
  1. **`item`**: 存储的数据。
  2. **`next`**: 指向下一个节点的指针。
  3. **`prev`**: 指向前一个节点的指针。

这个 `prev` 指针是 DLList 的精髓，它让链表中的导航变得双向。你可以从任意一个节点出发，向前或向后遍历整个链表。



#### **2.【重要】哨兵节点 (Sentinel Node)**

这是 CS61B 中一个非常核心且优雅的设计思想，用于简化链表操作。

- **为什么需要哨兵节点？**
  - 如果没有哨兵节点，在对链表进行操作时，你需要写很多 `if` 语句来处理特殊情况，比如：
    - 链表为空时添加第一个元素。
    - 在链表头部添加元素。
    - 删除链表最后一个元素导致链表变空。
  - 这些边界情况会让代码变得复杂且容易出错。
- **哨兵节点如何解决问题？**
  - 哨兵节点是一个**不存储实际数据**的特殊节点。它永远存在，即使在“空”链表中。
  - CS61B 教材中推荐使用 **单个循环哨兵节点 (Circular Sentinel)** 的结构，这是最简洁优雅的实现方式。
- **循环哨兵结构详解：**
  - 我们只创建一个哨兵节点 `sentinel`。
  - 一个“空”的 DLList 并不是 `sentinel == null`，而是 `sentinel.next` 和 `sentinel.prev` 都指向 `sentinel` 自己，形成一个微小的闭环。
  - **第一个真实节点** `A` 被添加时，它会被插入到 `sentinel` 和 `sentinel` 之间。此时：
    - `sentinel.next` 指向 `A`
    - `A.prev` 指向 `sentinel`
    - `A.next` 指向 `sentinel`
    - `sentinel.prev` 指向 `A`
  - 这样，**链表的头部永远是 `sentinel.next`，尾部永远是 `sentinel.prev`**。
- **哨兵节点的巨大优势：**
  - **统一操作逻辑**: 无论是向链表头部、中间还是尾部添加或删除节点，操作都变成了在两个已有节点之间进行插入或删除。你不再需要为头部和尾部的操作写特殊的 `if` 判断。
  - **永不为空**: 你的链表实例（`DLList`对象）永远不会是 `null`，它的 `sentinel` 节点永远存在，从而避免了大量的空指针检查 (`NullPointerException`)。



#### **3. 与单向链表 (SLList) 的对比**

| 特性             | 单向链表 (SLList)                                     | 双向链表 (DLList)                                        |
| ---------------- | ----------------------------------------------------- | -------------------------------------------------------- |
| **指针**         | 每个节点只有一个 `next` 指针                          | 每个节点有 `next` 和 `prev` 两个指针                     |
| **内存占用**     | 较小                                                  | 较大（因为多了 `prev` 指针）                             |
| **实现复杂度**   | 相对简单                                              | 相对复杂（需要维护两个指针）                             |
| **`addLast`**    | 高效                                                  | 高效                                                     |
| **`removeLast`** | **非常慢** (O(N))，需要遍历整个链表找到倒数第二个节点 | **非常快** (O(1))，通过 `sentinel.prev` 直接定位到尾节点 |

**核心权衡 (Trade-off):** DLList 使用了更多的内存和更复杂的代码，换来了在链表尾部操作（尤其是 `removeLast`）的巨大效率提升和双向遍历的灵活性。



#### **4. 泛型 (Generics)**

为了让你的 DLList 能够存储任何类型的数据（如 `String`, `Double` 等），而不仅仅是 `int`，我们使用泛型。

- **实现**: 在类定义时使用一个占位符，如 `public class DLList<T>`。
- **使用**: 创建实例时，指定具体类型，如 `DLList<String> list = new DLList<>();`。
- **注意**: 泛型不能使用基本数据类型（如 `int`, `double`），必须使用它们的包装类（`Integer`, `Double`）。

------



### **第二部分：数组 (Arrays)**

数组是编程中最基本、最重要的数据结构之一。



#### **1. 核心定义与特性**

- **本质**: 数组是一块**连续的、固定大小的**内存空间，用于存储**相同类型**的一系列数据。
- **三大特性**:
  1. **固定长度 (Fixed Length)**: 一旦创建，数组的长度就不能改变。
  2. **相同类型 (Same Type)**: 数组中的所有元素必须是同一种数据类型。
  3. **索引访问 (Indexed Access)**: 通过从 0 开始的整数索引（如 `myArray[0]`）来访问元素，访问速度极快 (O(1))。



#### **2. 数组的创建与初始化**

Java 提供了几种创建数组的方式：

1. **指定长度创建 (常用)**:

   ```java
   // 创建一个长度为 5 的 int 数组，所有元素默认初始化为 0
   int[] a = new int[5];
   ```

2. **直接提供初始值创建**:

   ```java
   // 创建一个包含 1, 2, 3 的数组，长度自动设为 3
   int[] b = new int[]{1, 2, 3};
   ```

3. **声明时初始化的简写形式**:

   ```java
   // 只能在声明变量的同一行使用
   int[] c = {1, 2, 3};
   ```



#### **3.【了解】`System.arraycopy`**

因为数组长度不可变，如果你想“扩容”或“收缩”数组，本质上是创建一个新数组，然后把旧数组的内容复制过去。`System.arraycopy` 是一个**native**（底层实现）方法，用于高效地进行数组复制，通常比自己写 `for` 循环快得多。

- **方法签名**: `System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`
  - `src`: 源数组 (从哪里复制)
  - `srcPos`: 源数组的起始索引
  - `dest`: 目标数组 (复制到哪里)
  - `destPos`: 目标数组的起始索引
  - `length`: 要复制的元素数量

**示例：向数组 `x` 的末尾添加一个数字 `20`**

```java
int[] x = {5, 10, 15};
int[] y = new int[x.length + 1]; // 创建一个更大的新数组
System.arraycopy(x, 0, y, 0, x.length); // 将 x 的内容复制到 y
y[x.length] = 20; // 在新数组的末尾添加新元素
x = y; // 让 x 指向这个新数组
```



#### **4. 二维数组 (2D Arrays)**

- **核心概念**: Java 中没有真正的二维数组，而是 **“数组的数组” (Array of Arrays)**。
- **理解方式**: 一个二维数组 `int[][] matrix`，实际上是一个数组，它的每个元素都是一个一维数组 (`int[]`)。
- **重要推论**: 因为是“数组的数组”，所以二维数组的每一“行”可以有不同的长度。

**示例：创建一个不规则的二维数组 (锯齿数组)**

```java
int[][] triangle = new int[3][]; // 只指定了有 3 行，但没指定每行多长
triangle[0] = new int[]{1};       // 第 0 行是一个长度为 1 的数组
triangle[1] = new int[]{2, 3};    // 第 1 行是一个长度为 2 的数组
triangle[2] = new int[]{4, 5, 6}; // 第 2 行是一个长度为 3 的数组
```



#### **5. 数组与类的对比**

| 特性         | 数组 (Arrays)                               | 类 (Classes)                             |
| ------------ | ------------------------------------------- | ---------------------------------------- |
| **访问方式** | 通过**数字索引**和 `[]` (e.g., `arr[i]`)    | 通过**字段名**和 `.` (e.g., `obj.field`) |
| **数据类型** | **同构**: 所有元素类型必须相同              | **异构**: 字段可以是不同类型             |
| **动态访问** | 索引可以是变量，运行时确定 (e.g., `arr[i]`) | 字段名必须在编译时确定，不能是变量       |



### **总结与建议**

- **DLList**: 关键在于理解**循环哨兵节点**如何简化代码、统一操作逻辑。它通过增加一点点复杂性，换来了代码的健壮性和优雅性。要重点掌握它相比 SLList 在尾部操作上的巨大优势。
- **Arrays**: 核心是理解其**三大特性**（固定长度、相同类型、索引访问）。对于Java，要特别理解二维数组是“数组的数组”这一概念，以及在需要调整大小时，必须通过创建新数组和使用 `System.arraycopy` 来完成。