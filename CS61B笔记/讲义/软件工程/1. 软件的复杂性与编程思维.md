# 1. 软件的复杂性与编程思维

在软件工程中，我们面临的最大挑战不是计算机的物理限制，而是我们**理解和管理我们所构建的系统的能力** 。随着软件功能的增加，其复杂性也随之增长，这使得后续的修改和维护变得越来越困难 。



我们的终极目标是：**保持软件尽可能的简单 (Keep it simple)** 。

------

### 知识点一：什么是软件复杂性 (Complexity Defined)

首先，我们需要理解“复杂性”到底是什么。

**定义**： “**复杂性是与软件系统结构相关的任何东西，它使得理解和修改系统变得困难**” 。

换句话说，如果一个系统很难懂、很难改，那它就是复杂的；反之，如果它很容易懂、很容易改，那它就是简单的 。

**复杂性的具体表现**：

- 你需要花费很长时间才能理解代码的工作原理 。
- 做一个小小的功能改进，却需要花费大量时间 。
- 很难找到为了实现一个功能到底需要修改哪些地方 。
- 修复一个Bug，却引入了另一个甚至更多的新Bug（牵一发而动全身） 。



**重要提示**：这里说的“复杂”不等于“功能强大”或“代码量大” 。一个很小的程序也可能写得极其复杂，难以理解 。



------

### 知识点二：复杂性的两大根源 (Causes of Complexity)

讲义指出了导致软件复杂的两个主要原因 ：



1. **依赖性 (Dependencies)** 
   - **定义**：当一段代码无法被独立地阅读、理解和修改时，就产生了依赖 。
   - **讲解**：想象一下，为了理解A模块，你必须先去读懂B模块和C模块的代码，而修改A模块，又可能会影响到D模块和E模块的功能。这种盘根错节的联系，就是依赖性。它大大增加了你修改代码时的“认知负荷”，因为你需要把所有相关部分都装进脑子里。
2. **模糊性 (Obscurity)** 
   - **定义**：当重要的信息不明显、不直观时，就产生了模糊性 。
   - **讲解**：这通常体现在糟糕的命名、缺乏注释、设计不清晰等方面。比如，一个变量名叫`data`，一个函数名叫`process()`，你完全不知道它们具体是干什么的，这就是模糊性。好的代码应该像一篇清晰的文章，让人能轻松理解其意图。使用命名良好、功能单一的辅助方法 (helper methods) 是一个避免模糊性的好例子 。



------

### 知识点三：复杂性的三大症状 (Symptoms of Complexity)

当一个系统变得复杂时，通常会表现出以下三种“症状” ：

1. **变更放大 (Change Amplification)** 
   - **定义**：一个看似简单的变更，却需要在代码的多个不同地方进行修改 。
   - **讲解**：例如，你想给系统增加一种新的用户类型。在一个设计糟糕的系统里，你可能需要修改用户管理模块、权限验证模块、数据展示模块、日志记录模块……等等。而在一个设计良好的系统里，可能只需要在一个地方添加新类型的定义即可。
2. **认知负荷 (Cognitive Load)** 
   - **定义**：为了完成一项任务，一个开发者需要了解多少信息 。
   - **讲解**：认知负荷越高，犯错的可能性就越大，开发效率也越低。一个常见的误区是认为代码行数越少越好。实际上，有时候**更多的代码行数（例如，把复杂的逻辑拆分成几个更小、更清晰的辅助函数）反而能降低认知负荷**，因为代码的“叙事性”更强了 。
3. **未知的未知 (Unknown Unknowns)** 
   - **定义**：你甚至不清楚为了完成一个修改，需要去了解哪些信息 。
   - **讲解**：这是最糟糕的一种情况。你以为你已经把所有需要改动的地方都找到了，但实际上，还有一个你完全不知道的模块也依赖了这部分逻辑。当你信心满满地提交代码后，那个你不知道的模块就出错了。这在大型、历史悠久的代码库中非常常见 。



------

### 知识点四：两种编程思维模式：战术编程 vs. 战略编程

这是本节课最重要的概念之一，它描述了两种截然不同的编程心态。



#### 1. 战术编程 (Tactical Programming)

- **核心心态**：“**我的主要目标就是让功能尽快工作起来！**” 。
- **行为特征**：
  - 以最快的方式修复Bug或完成一个新功能。
  - 不太考虑长期的设计和代码结构 。
  - 倾向于走捷径，比如复制粘贴一段相似的代码，而不是花时间将其抽象成一个可重用的函数 。
  - 这种方式会不断地引入小的复杂性，日积月累，最终导致系统“腐烂”，难以维护 。



#### 2. 战略编程 (Strategic Programming)

- **核心心态**：“**能工作的代码只是最低要求，最重要的是系统长期的健康结构。**” 。

- **行为特征**：

  - 将优秀的设计看得比短期目标更重要。**绝不接受为了节省一点时间而引入新的复杂性** 。

  - 愿意投入额外的时间去寻找更简洁、更清晰的设计方案。例如，在动手实现前，会构思几种不同的设计，并评估优劣 。

  - 持续进行代码重构，一旦发现设计中的瑕疵，会立即修复它，而不是绕过去 。比如，通过增加哨兵节点 (sentinel nodes) 来消除链表操作中的特殊情况处理，就是一个典型的战略思维范例 。

  - 会为未来的变化做规划。比如在Project 3中，增加任何新功能时，都要思考它对“保存和加载游戏状态”这个功能会产生什么影响 。

    

**案例分析**：

- **Facebook (早期)**：典型的战术编程，“Move fast and break things” 。这帮助他们快速发展，但也导致了代码库混乱不堪 。最终他们也不得不转向“Move fast with stable infra” (在稳定的基础设施上快速前进) 。

- **Google / VMware**：典型的高度战略性组织 。他们极其重视代码质量和优秀的设计 ，这帮助他们构建了非常复杂但又可靠的系统，并吸引了顶尖的技术人才 。

  

### 总结与学习建议

1. **警惕复杂性**：当你感觉代码越来越难懂、越来越难改的时候，停下来想一想，是不是复杂性正在悄悄累积。
2. **拥抱战略思维**：不要满足于“代码能跑就行”。多花一点时间去思考设计，去重构你的代码，让它变得更“简单”、更“清晰”。