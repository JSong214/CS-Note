## 3. 如何管理软件的复杂性（Complexity）

### 核心知识点 1：软件复杂性的根源 (The Roots of Complexity)

首先，我们需要理解我们的“敌人”是什么。讲义引用了 John Ousterhout 在《A Philosophy of Software Design》中的定义 ：

> **复杂性 (Complexity)** 是指与软件系统结构相关的、任何使系统难以理解和修改的因素 。

复杂性的两大主要来源 ：

1. **依赖性 (Dependencies)** 
   - **定义**：当一段代码无法被独立地阅读、理解和修改时，就产生了依赖性 。
   - **解读**：这意味着，为了修改模块 A，你必须去理解甚至修改模块 B、C、D。模块之间耦合度太高，牵一发而动全身。这会让修复一个简单的 bug 或增加一个小功能变得异常困难和危险。
2. **隐晦性 (Obscurity)** 
   - **定义**：当一些重要的信息不明显、不直观时，就产生了隐晦性 。
   - **解读**：比如，一段代码的用途是什么？一个变量代表什么意义？为什么这里要进行如此复杂的计算？如果这些问题的答案不能直接从代码中看出来（需要看长篇的文档，或者去问原作者），那么代码就具有隐晦性。这会大大增加理解代码所需的时间成本。



### 核心知识点 2：两种编程思想的对决：战术型 vs. 战略型

为了对抗复杂性，我们需要树立正确的编程思想。讲义对比了两种截然不同的编程风格。



#### 1. 战术型编程 (Tactical Programming)

- **核心思想**：“你的主要目标就是让某个东西跑起来，比如一个新功能或一个 bug 修复。” 
- **特点**：
  - 只顾眼前，追求短期目标。
  - 倾向于走“最快”的路径，使用“取巧”的办法来完成功能。
  - 不会花额外的时间去思考设计、代码结构和未来的可维护性。
- **后果**：这种编程方式会不断地累积“技术债”，导致系统的复杂性迅速增长，最终变得难以维护 。



#### 2. 战略型编程 (Strategic Programming)

- **核心思想**：这不是“怎样最快完成功能”，而是“怎样构建一个长期来看最优的系统”。你需要进行投资，花一些额外的时间来产出更整洁、设计更好的代码 。
- **特点**：
  - 着眼于未来，把软件的长期健康度放在首位。
  - 愿意投入时间进行代码**重构 (Refactoring)** ，以简化代码、改善设计。
  - 不断思考如何降低系统的整体复杂性。
- **目标**：构建一个清晰、易于维护、能够轻松应对未来变化的系统。



**关键 takeaway**：在你的 BYOW 项目中，一定要时刻提醒自己，要做一个**战略型程序员** 。



### 核心知识点 3：对抗复杂性的核心武器：深度模块 (Deep Modules)

战略型编程是一个宏观思想，而“深度模块”则是实现这一思想的具体战术和武器。



#### 什么是模块化设计 (Modular Design)？

理想情况下，一个系统应该被分解成多个完全独立的**模块 (Modules)** 。一个模块可以是一个类、一个包或其他代码单元 。模块化设计的核心目标是**最小化模块间的依赖** 。



#### 接口 (Interface) vs. 实现 (Implementation)

这是理解模块化的基础。

- **接口**：定义了模块能做什么。它包含两部分：
  - **正式部分**：方法签名，由编译器强制执行 。
  - **非正式部分**：一些必须遵守但编译器无法强制的规则，例如 `iterator` 的 `next()` 方法前必须调用 `hasNext()` ，或者某个方法不接受 `null` 参数 。这些只能通过注释来说明 。
- **实现**：定义了模块是如何完成这些功能的 。比如 `Map` 是接口，而 `HashMap` 和 `TreeMap` 是它的不同实现 。



#### 深度模块 (Deep Modules) 的定义

Ousterhout 教授给出了一个非常精彩的定义：

> **最好的模块是那些提供强大功能，同时又拥有简单接口的模块。我称之为“深度模块”** 。

- **简单接口 (Simple Interface)**：
  - 接口提供的功能清晰、易于理解。
  - 它隐藏了实现的复杂性，使用者无需了解内部细节 。例如，使用红黑树时，我们只需要调用 `add`, `contains` 等方法，完全不需要关心哪个节点是红色或黑色 。
  - 简单的接口使得更换模块的实现变得容易，而不影响系统的其他部分 。
- **强大功能 (Powerful Functionality)**：
  - 模块内部通过可能很复杂的逻辑，解决了一个重要的问题 。例如，红黑树通过复杂的平衡规则，保证了操作的高效性 。



**目标**：在你的项目中，要努力创建深度模块 。例如，可以创建一个 `DrawUtils` 类，它有一个简单的接口（比如 `drawRoom(position, width, height)`），但内部封装了绘制房间墙壁和地板的复杂逻辑。



### 核心知识点 4：构建深度模块的关键技术

那么，如何才能设计出深度模块呢？讲义介绍了两个非常重要的概念。



#### 1. 信息隐藏 (Information Hiding)

- **定义**：这是构建深度模块最重要的手段 。它的核心思想是将知识和设计决策**封装在模块内部，而不暴露给外部世界** 。
- **好处**：
  1. **简化接口**：因为外部世界不需要知道这些内部细节 。
  2. **易于修改**：当内部设计决策改变时（比如，你决定用另一种方式存储地图数据），你只需要修改这一个模块，而不会影响到系统的其他部分 。



#### 2. 警惕信息泄露 (Information Leakage)

- **定义**：信息隐藏的反面是信息泄露 。当一个设计决策被反映到多个模块中时，就发生了信息泄露 。
- **后果**：一旦这个设计决策需要改变，所有相关的模块都必须跟着修改 。Ousterhout 强调，**信息泄露是软件设计中最重要的“危险信号”之一** 。
- **例子**：讲义中的 `Avatar` 类就是一个例子 。`moveLeft` 方法直接判断目标瓦片是否为 `Tileset.FLOOR` 或 `Tileset.COIN` 。这意味着 `Avatar` 类**泄露**了关于“世界由哪些瓦片组成以及哪些瓦片可以行走”的信息。更理想的设计是，`Avatar` 只请求移动，由 `World` 模块来判断移动是否合法。



#### 3. 避免时序分解 (Temporal Decomposition)

- **定义**：这是导致信息泄露的一大原因 。它是指你的系统结构是按照**事件发生的顺序**来组织的 。
- **例子**：在实现保存/加载功能时，一个典型的时序分解思路是 ：
  1. 程序启动。
  2. 用户输入种子。
  3. 用户用 WASD 移动。
  4. 用户保存并退出。
  5. ... 这种分解方式很容易让你把处理输入的代码、处理移动的代码、处理保存的代码混杂在一起，导致信息泄露。
- **更好的方法**：创建一个深度模块（例如叫 `GameStateEngine`），它的接口很简单：接收一个输入字符串（如 `"N239874SDDDD"`，代表 new game with seed 239874, then move south, then move east four times），然后直接生成最终的世界状态 。这个模块将“如何解析输入”和“如何根据输入改变世界”这些信息**隐藏**了起来。无论是从键盘实时输入、从文件加载，还是实现游戏回放功能，都可以复用这个强大的模块 。



### 项目的实践建议

1. **要有策略地编程**：时刻思考你的设计，如果发现代码变得复杂，花时间去**重构**它 。善用 Git，这样即使重构搞砸了也能轻松回退 。
2. **创建深度模块**：识别项目中可以被封装的功能，为它们创建接口简单但功能强大的类 。
3. **信息隐藏**：这是你的首要原则。在写任何一个类或方法时，都问问自己：“我是否暴露了不必要的细节？” 。
4. **避免时序分解**：不要让你的代码结构仅仅是用户操作流程的翻版。思考如何将功能抽象成更通用的模块 。
5. **绝对不要创建可变的静态变量 (Mutable Static Variables)** ：比如 `public static Position playerLocation` 。这是一个“极其糟糕”的做法，因为它在全局引入了状态，使得代码极难推理和测试 