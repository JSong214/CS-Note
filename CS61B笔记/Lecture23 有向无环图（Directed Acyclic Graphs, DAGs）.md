## Lecture23 有向无环图（Directed Acyclic Graphs, DAGs）



### 1. 有向无环图 (DAGs) 与拓扑排序

首先，我们需要明确什么是DAG。一个**有向无环图**是一个不存在任何有向环路的有向图。这意味着从任何一个顶点出发，沿着边的方向走，你永远无法回到起点。

这个“无环”的特性非常关键，它保证了图中存在一种线性的先后次序。这引出了我们的第一个核心概念——**拓扑排序**。



#### 什么是拓扑排序？

拓扑排序是对一个DAG的所有顶点进行线性排序，使得对于图中任意一条有向边 (u,v)，顶点 u 在排序中都出现在顶点 v 之前 。

你可以把这想象成一个处理任务依赖关系的过程。例如，下图中的每个节点代表一个任务，箭头 (v,w) 代表任务 v 必须在任务 w 之前完成 。拓扑排序就是给出一个所有任务都能够按顺序完成的有效序列 。

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.png)



对于上图，一个有效的拓扑排序可以是 `[C, F, G, A, D, B, E, H]` ，但也可以是 `[A, C, B, D, F, E, H, G]` 。排序结果通常不唯一，但都必须满足边的约束。



#### 如何进行拓扑排序？

一个经典且高效的算法是基于**深度优先搜索 (Depth-First Search, DFS)** 的。

**算法步骤：**

1. 对图进行DFS遍历。你可以从任意一个未被访问过的顶点开始，当一次DFS结束后，如果图中还有未被访问的顶点，就再任选一个开始新的DFS，直到所有顶点都被访问过 。

2. 在DFS过程中，记录每个顶点的**后序遍历 (Postorder)** 顺序。一个顶点只有在它的所有邻接点都被访问完毕后，才会被加入到后序遍历列表中 。

3. 当所有顶点都完成遍历后，将得到的后序遍历列表**反转 (Reverse)** 。这个反转后的列表就是一个有效的拓扑序 。

   

**代码逻辑解析 (伪代码):**

```python
# visited: 记录已访问的节点
# post_order_list: 存储后序遍历结果

function topological_sort(graph):
    visited = set()
    post_order_list = []

    for vertex in graph.all_vertices():
        if vertex not in visited:
            dfs(vertex, visited, post_order_list)

    return post_order_list.reverse() # 反转后序列表

function dfs(vertex, visited, post_order_list):
    visited.add(vertex)

    for neighbor in vertex.neighbors():
        if neighbor not in visited:
            dfs(neighbor, visited, post_order_list)

    # 只有当一个节点的所有邻居都访问完毕后，才将其加入后序列表
    post_order_list.append(vertex)
```

**图例演示：** 让我们以上图为例，追踪DFS的过程：

1. 从 `A` 开始DFS：A→B→E→H。`H`没有出度，访问结束，加入后序列表。退回`E`，`E`也没有其他邻居，加入后序列表。退回`B`，加入后序列表。退回`A`，访问另一条路径 A→D。`D`没有其他未访问邻居，加入后序列表。最后`A`加入后序列表。

   - 当前后序列表: `[H, E, B, D, A]` 

2. 图中还有未访问节点，比如 `C`。从 `C` 开始DFS：C→F→G。`G`没有出度，加入后序列表。退回`F`，加入后序列表。退回`C`，它还有邻居`D`，但`D`已经被访问过了。所以`C`加入后序列表。

   - 最终后序列表: `[H, E, B, D, A, G, F, C]` 

3. **反转**后序列表得到拓扑排序：

   - `[C, F, G, A, D, B, E, H]` 

     

**重要特性：**

- 只有DAG才能进行拓扑排序。如果图中存在环路，DFS将永远无法结束，也就无法产生一个合法的排序 。

- **时间复杂度**: 遍历每个顶点和每条边一次，为 O(V+E) 。

- **空间复杂度**: 存储访问状态和递归栈，为 Θ(V) 。

  

### 2. DAG中的最短路径

在带权重的图中寻找最短路径是一个经典问题。我们熟知的Dijkstra算法非常有效，但它有一个前提：**边的权重不能为负**。如果存在负权边，Dijkstra可能会得出错误的结果 。

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/Dijkstra%E7%AE%97%E6%B3%95%E5%9C%A8%E8%B4%9F%E6%9D%83%E8%BE%B9%E4%B8%8B%E7%9A%84%E5%A4%B1%E8%B4%A5%E6%A1%88%E4%BE%8B.png)



然而，对于DAG，即使存在负权边，我们也能高效地找到最短路径。这得益于拓扑排序。



#### 算法步骤

核心思想是：**按照拓扑排序的顺序来“放松” (Relax) 每一个顶点的出边** 。



1. **计算拓扑序**: 首先，对DAG进行拓扑排序 。
2. **初始化**:
   - 创建一个 `distTo` 数组，将起点的距离 `distTo[s]` 初始化为0，其他所有顶点的距离初始化为无穷大 (∞)。
   - 创建一个 `edgeTo` 数组，用于记录最短路径上的前驱节点。
3. **遍历与放松**:
   - 按照拓扑排序的顶点顺序，依次访问每个顶点 `v`。
   - 对于每个顶点 `v`，遍历它的所有出边 (v,w)。
   - 对每条边进行**放松**操作：如果 `distTo[v] + weight(v, w)` 小于 `distTo[w]`，则更新 `distTo[w]` 为这个更小的值，并设置 `edgeTo[w] = v`。



#### 为什么这个算法是正确的？

因为我们是按照拓扑顺序处理顶点的。当你处理顶点 `v` 时，所有可能到达 `v` 的顶点（即 `v` 的所有前驱节点）都**已经被处理过了** 。这意味着 `distTo[v]` 在此时已经确定为从起点 `s` 到 `v` 的最短路径长度。因此，基于这个已确定的最短距离去更新 `v` 的邻居节点 `w`，可以确保我们总是在用正确的最短路径信息来探索后续路径。



**图例演示：** 以下图为例，其拓扑序之一是 `[A, D, B, C, E, F]` 。

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/DAG%E4%B8%8A%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%EF%BC%88%E5%90%AB%E8%B4%9F%E6%9D%83%E8%BE%B9%EF%BC%89.png)



1. **初始化**: `distTo[A]=0`, 其他为 ∞。
2. **访问 `A`**: 放松 A-B (权重1) 和 A-D (权重1)。
   - `distTo` 更新为: `A:0, B:1, D:1`, 其他 ∞。
3. **访问 `D`** (拓扑序下一位): 放松 D-E (权重1)。
   - `distTo` 更新为: `A:0, B:1, D:1, E:2`, 其他 ∞。
4. **访问 `B`**: 放松 B-C (权重6)。
   - `distTo` 更新为: `A:0, B:1, D:1, E:2, C:7`, 其他 ∞。
5. **访问 `C`**: 放松 C-E (权重-20) 和 C-F (权重1)。
   - `distTo[C] + weight(C,E) = 7 + (-20) = -13`，这比当前的 `distTo[E]=2` 要小。
   - `distTo` 更新为: `A:0, B:1, D:1, E:-13, C:7, F:8` 。
6. **访问 `E`**: 放松 E-F (权重1)。
   - `distTo[E] + weight(E,F) = -13 + 1 = -12`，这比当前的 `distTo[F]=8` 要小。
   - `distTo` 更新为: `A:0, B:1, D:1, E:-13, C:7, F:-12` 。
7. **访问 `F`**: 没有出边。

算法结束，我们得到了从A到所有节点的最短路径。

**复杂度分析：**

- 拓扑排序: O(V+E)。

- 遍历与放松: 每个顶点和每条边只访问一次，也是 O(V+E)。

- 总时间复杂度: O(V+E) ，这比Dijkstra的 O(ElogV) 更快。

  

### 3. DAG中的最长路径

寻找图中的最长路径（Longest Path）问题通常比最短路径要复杂得多。在**任意**一个带权图中，寻找最长简单路径（不重复经过顶点）是一个著名的NP-Hard问题，目前没有已知的多项式时间解法 。

但是，在**DAG**中，这个问题同样可以被高效地解决。解决它的方法非常巧妙，完美地展示了**归约 (Reduction)** 的思想。



#### 算法步骤 (通过归约)

我们可以将“在DAG中寻找最长路径”这个问题，**归约**成“在DAG中寻找最短路径”的问题 。

1. **创建新图 G'**: 复制原始DAG `G`，将 `G` 中**所有边的权重取反**（乘以-1），得到一个新图 `G'` 。
2. **运行最短路径算法**: 在新图 `G'` 上，以相同的起点 `s` 运行我们刚才学习的DAG最短路径算法 。
3. **转换结果**:
   - `G'` 上的最短路径树（由 `edgeTo` 数组定义）就是 `G` 上的最长路径树 。
   - 将 `G'` 中计算出的每个顶点的 `distTo` 值**再次取反**，就得到了 `G` 中从 `s` 到每个顶点的最长路径长度 。

*注：上图为最长路径问题，图是其归约后的最短路径问题* 

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/DAG%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84(%E5%B7%A6).png)

![](https://pic-go-image-1363881366.cos.ap-chengdu.myqcloud.com/Image/DAG%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84(%E5%8F%B3).png)



#### 为什么这个方法可行？

这个方法的正确性基于一个简单的数学原理：最大化一个路径的权重和 ∑wi 等价于最小化这个路径所有边权重取反后的和 ∑(−wi) 。

因为原始图是DAG，所以边权取反后的新图仍然是DAG，并且我们的DAG最短路径算法能够正确处理负权边。因此，这个归约是完全有效的。

**复杂度分析：** 该算法的复杂度完全等同于DAG最短路径算法的复杂度，即 O(V+E) 。



### 4. 归约与分解

我们在解决DAG最长路径问题时所用的方法——将一个问题（LPT）转换为另一个我们已经知道如何解决的问题（SPT）——就是**归约 (Reduction)** 。

**定义 (非正式)**: 如果任何一个用于解决任务Q的子程序，都可以被用来解决任务P，我们就说“问题P可以归约到问题Q” 。在我们的例子中，就是“DAG最长路径问题”可以归约到“DAG最短路径问题” 。

归约是计算机科学和算法设计中一个极其强大的思想。它背后更广泛的概念是**分解 (Decomposition)**，即将一个复杂的大问题分解成若干个更小、更易于管理的子问题 。通过使用合适的**抽象 (Abstractions)**，比如将DAG最短路径算法视为一个“黑盒”工具，我们可以更轻松地解决新问题，而无需重新发明轮子 。



### 总结

今天我们深入学习了有向无环图（DAG），要点回顾：

- **DAG** 的核心是“无环”，这使得**拓扑排序**成为可能，为顶点提供了一个线性顺序。
- 拓扑排序可以通过 **DFS + 反转后序遍历** 的方式在 O(V+E) 时间内完成。
- 利用拓扑排序，我们可以在 O(V+E) 时间内解决DAG上的**最短路径**问题，即使存在**负权边**。
- 通过**归约**的思想，将边权取反，我们同样可以在 O(V+E) 时间内高效解决DAG上的**最长路径**问题，这是一个在普通图中非常困难的问题。