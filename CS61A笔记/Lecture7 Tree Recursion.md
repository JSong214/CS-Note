## Lecture7 Tree Recursion



#### 1. 核心思想：什么是树形递归？

树形递归是递归的一种特殊形式。与我们先学习的**线性递归（Linear Recursion）不同，线性递归函数在一次调用中最多只会再调用自身一次。而树形递归函数（Tree Recursive Function）则会在一次调用中，调用自身多次**。

- **线性递归**：函数调用链是一条直线。例如，计算阶乘的函数。

  ```python
  def factorial(n):
      if n == 0:
          return 1
      else:
          return n * factorial(n - 1) # 只调用自身一次
  ```

  调用路径：`factorial(4) -> factorial(3) -> factorial(2) -> ...`

- **树形递归**：函数调用过程会像树一样展开，形成多个分支。这是解决那些可以被分解为多个相似的、规模更小的子问题的关键。

  > **最重要的思想**：相信**递归的信念飞跃 (Recursive Leap of Faith)**。假设你的函数对于更小规模的输入已经能够正确工作，然后利用这些“已经解决”的子问题来构建当前问题的解。



#### 2. 树形递归函数的关键组成部分

一个典型的树形递归函数通常包含以下部分：

1. **基础情况 (Base Case)**：
   - 这是递归的终止条件，一个或多个。
   - 它定义了问题的最简单形式，可以直接给出答案，而无需进一步递归。
   - 如果缺少基础情况或设计不当，会导致无限递归。
2. **递归步骤 (Recursive Step)**：
   - 将当前问题分解为几个规模更小的、结构相同的子问题。
   - **多次调用自身**来解决这些子问题。
   - 将子问题的解合并起来，形成当前问题的解。

------



### 3. 经典案例一：斐波那契数列 (Fibonacci Sequence)

这是学习树形递归的第一个，也是最重要的例子。

**问题定义**： $Fib(n) = \\begin{cases} 0 & \\text{if } n = 0 \\ 1 & \\text{if } n = 1 \\ Fib(n-1) + Fib(n-2) & \\text{if } n \> 1 \\end{cases}$

**代码实现**：

```python
def fib(n):
    """Computes the nth Fibonacci number."""
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        # 递归步骤：调用自身两次
        return fib(n - 1) + fib(n - 2)
```

**知识点详解**：

- **基础情况**：`n == 0` 和 `n == 1` 是最简单的情况，直接返回值。
- **递归步骤**：对于任何大于1的 `n`，`fib(n)` 的计算都依赖于两个更小的子问题：`fib(n-1)` 和 `fib(n-2)`。函数在这里调用了自身两次，形成了两个分支。

**可视化：递归调用树** 理解树形递归的关键在于**可视化其调用过程**。我们以 `fib(4)` 为例，它的调用树如下：

```
                 fib(4)
                /      \
        fib(3)      +      fib(2)
       /      \           /      \
    fib(2) + fib(1)     fib(1) + fib(0)
   /      \
fib(1) + fib(0)
```

- 从上图可以看出，函数的调用过程像一棵倒置的树。
- 叶子节点是基础情况（`fib(1)` 和 `fib(0)`）。
- 非叶子节点是递归步骤，它的值是其子节点值的和。

**重要警示：重复计算 (Redundant Computations)** 观察上面的调用树，你会发现一个严重的问题：`fib(2)` 被计算了两次，`fib(1)` 被计算了三次... 当 `n` 增大时，这种重复计算会呈指数级增长，导致效率极低。这是树形递归一个常见的陷阱。

------



### 4. 经典案例二：整数分区 (Counting Partitions)

这是CS61A中另一个经典的、也更复杂的树形递归例子。

**问题定义**：计算一个正整数 `n` 有多少种不同的方法，可以使用不超过 `m` 的正整数相加来表示。 例如，分区 `6` 使用不超过 `4` 的部分：

- `2 + 4 = 6` (使用 `4`)
- `3 + 3 = 6`
- `1 + 1 + 4 = 6` (使用 `4`)
- `1 + 2 + 3 = 6`
- `1 + 1 + 1 + 3 = 6`
- ...等等

**核心分解思想**： 对于将 `n` 用最大不超过 `m` 的部分来分区，我们可以分为两种情况：

1. **使用至少一个 `m`**：如果我们用了 `m`，那么剩下的问题就是对 `n-m` 进行分区，最大部分仍然不超过 `m`。
2. **完全不使用 `m`**：如果我们不用 `m`，那么问题就变成了对 `n` 进行分区，但最大部分只能是不超过 `m-1`。

这两种情况互斥且穷尽，所以总方法数是这两种情况的和。

**代码实现**：

```python
def count_partitions(n, m):
    """Count the partitions of n using parts up to size m."""
    if n == 0:
        # 成功找到一个分区方案
        return 1
    elif n < 0:
        # 这个分区路径是无效的
        return 0
    elif m == 0:
        # 没有可用的部分来分区一个正数n
        return 0
    else:
        # 情况1: 使用最大部分 m
        with_m = count_partitions(n - m, m)
        # 情况2: 不使用最大部分 m
        without_m = count_partitions(n, m - 1)
        return with_m + without_m
```

**知识点详解**：

- **基础情况**：
  - `n == 0`: 表示我们成功地将原数减到了0，这是一个有效的划分方法，所以返回1。
  - `n < 0`: 表示我们减多了，这个路径是无效的，返回0。
  - `m == 0`: 当 `n` 还是正数时，我们已经没有可用的部分了 (`m=0`)，无法完成划分，返回0。
- **递归步骤**：
  - `count_partitions(n - m, m)` 对应于“使用 `m`”的情况。
  - `count_partitions(n, m - 1)` 对应于“不使用 `m`”的情况。
  - 将两个分支的结果相加，就是最终的答案。

这个例子完美地展示了如何通过将问题分解为几个互斥的子集来设计树形递归。

------



### 5. 树形递归的性能问题与优化：记忆化 (Memoization)

我们已经看到 `fib` 函数中存在大量的重复计算。为了解决这个问题，我们可以使用一种叫做**记忆化 (Memoization)** 的技术。

**核心思想**： 将函数计算过一次的结果存储起来（通常用字典或哈希表）。在下一次以相同的参数调用该函数时，直接从存储中返回结果，而不是重新计算。这是一种用空间换时间的典型策略。

**记忆化版本的 `fib` 函数**：

```python
# 创建一个缓存来存储已经计算过的结果
cache = {}

def fib_memo(n):
    # 如果结果已经在缓存中，直接返回
    if n in cache:
        return cache[n]
    
    # 否则，按正常方式计算
    if n == 0:
        result = 0
    elif n == 1:
        result = 1
    else:
        result = fib_memo(n - 1) + fib_memo(n - 2)
    
    # 在返回结果之前，将其存入缓存
    cache[n] = result
    return result
```

**效果**： 通过记忆化，`fib_memo(n)` 的计算复杂度从指数级（O(2n)）降低到了线性级（O(n)），因为每个 `fib(k)` (其中 `k <= n`) 都只被实际计算一次。

这是动态规划 (Dynamic Programming) 思想的初步体现，是CS61A后续课程的一个重要概念。

------



### **总结**

1. **定义**：树形递归函数是在其函数体中多次调用自身的函数。
2. **结构**：由基础情况和递归步骤组成，递归步骤包含多个递归调用。
3. **可视化**：理解树形递归的关键是画出**调用树**，看清问题是如何被分解和解决的。
4. **适用场景**：适合解决那些可以分解为多个独立的、更小的、同类子问题的问题。
5. **主要缺点**：可能会导致严重的**重复计算**问题。
6. **优化方法**：**记忆化 (Memoization)** 是解决重复计算的有效手段，通过缓存结果避免重复劳动。