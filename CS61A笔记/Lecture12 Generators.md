## Lecture12 Generators



### 1. 核心思想：惰性计算 (Lazy Evaluation)

这是理解生成器最核心、最重要的思想。

想象一下，你需要一个从 1 到 100 万的数字列表。

- **传统方法 (Eager Evaluation)**： `my_list = list(range(1, 1000001))`
  - 这行代码会立即在内存中创建包含 **一百万个** 整数的列表。如果这个列表更大，可能会消耗大量内存，甚至导致程序崩溃。它会一次性把所有工作都做完。
- **生成器方法 (Lazy Evaluation)**： `my_generator = range(1, 1000001)` (在Python 3中，`range`本身就是一个类似生成器的对象)
  - 这行代码几乎不占用内存。它不会立即创建所有数字，而是返回一个“生成器”对象。
  - 这个对象知道如何 *在被需要时* 生成下一个数字。只有当你向它请求（比如在 `for` 循环中），它才会计算并吐出下一个值，然后就地等待下一次请求。
  - **“惰性”** 指的就是：除非你开口要，否则我绝不多做一个。



### 2. 前置知识：可迭代对象 (Iterables) vs. 迭代器 (Iterators)

在深入生成器之前，必须分清这两个概念。

- **可迭代对象 (Iterable)**
  - **定义**：任何可以被 `for` 循环遍历的对象。从技术上讲，是任何实现了 `__iter__` 方法的对象。
  - **例子**：列表 (`list`)、元组 (`tuple`)、字符串 (`str`)、字典 (`dict`)。
  - **特点**：它们是数据的“容器”，你可以多次遍历它们。
- **迭代器 (Iterator)**
  - **定义**：一个代表数据流的对象。它实现了 `__next__` 方法，该方法返回数据流中的下一个元素。
  - **特点**：
    1. **有状态**：它必须记住当前在数据流中的位置。
    2. **一次性**：一旦遍历完成，就不能重新开始。就像读一本书，读完就结束了。
    3. 通过调用 `iter()` 函数在一个可迭代对象上获得。

**关系**：`for` 循环的幕后工作原理是：

1. 调用可迭代对象的 `iter()` 方法，获得一个迭代器。
2. 不断调用这个迭代器的 `next()` 方法，获取下一个值。
3. 直到 `next()` 方法抛出 `StopIteration` 异常，循环结束。

**生成器是一种特殊的、更方便创建的迭代器。**



### 3. 生成器函数 (Generator Functions) - ⭐ 重点 ⭐

这是创建生成器的主要方式。

- **定义**：任何包含 `yield` 关键字的 Python 函数都自动成为一个 **生成器函数**。
- **关键区别**：调用一个普通函数会立即执行函数体并返回一个值 (`return`)。调用一个 **生成器函数** 不会执行任何代码，而是立即返回一个 **生成器对象** (它本身是一个迭代器)。



### 4. `yield` 关键字的魔力 - ⭐ 核心重点 ⭐

`yield` 是整个生成器机制的核心，它的行为与 `return` 完全不同。

| 特性         | `return`                       | `yield`                            |
| ------------ | ------------------------------ | ---------------------------------- |
| **功能**     | 结束函数                       | **暂停** 函数                      |
| **返回值**   | 返回一个确切的值               | 返回一个值，并“冻结”函数的当前状态 |
| **函数状态** | 销毁所有局部变量，函数彻底结束 | **保存** 所有局部变量和执行位置    |
| **再次调用** | 无法再次进入函数               | 可以从上次暂停的地方 **恢复** 执行 |



#### **`yield` 的详细执行流程**

让我们用一个简单的倒计时生成器来解释：

```python
def countdown(n):
    print("开始倒计时!")
    while n > 0:
        yield n
        n -= 1
    print("倒计时结束!")

# 1. 创建生成器对象
c = countdown(3) 
# >> (什么都不会打印, 因为函数体根本没有执行)
# c 现在是一个生成器对象

# 2. 第一次请求值
print(next(c))
# >> 开始倒计时!  (代码从函数开头执行)
# >> 3            (遇到 yield 3, 返回 3, 然后函数在此处暂停)

# 3. 第二次请求值
print(next(c))
# >> (没有打印 "开始倒计时!", 因为函数从上次暂停的地方恢复)
# >> 2            (n 的值是上次暂停时的 2, 执行 yield 2, 返回 2, 再次暂停)

# 4. 第三次请求值
print(next(c))
# >> 1            (n 的值是 1, 执行 yield 1, 返回 1, 再次暂停)

# 5. 第四次请求值
print(next(c))
# >> 倒计时结束!  (n 的值是 0, 循环结束, 函数执行完毕)
# >> StopIteration (因为函数结束了，没有更多的 yield, 迭代器抛出 StopIteration 异常)
```

**总结一下 `yield` 的行为**:

1. **暂停**：`yield` 像一个暂停按钮。它返回值给调用者，然后暂停函数执行。
2. **保存状态**：函数暂停时，它当前的所有状态（包括局部变量、指令指针等）都被完整地保存下来。
3. **恢复**：当 `next()` 再次被调用时，函数从它上次暂停的地方无缝恢复，所有局部变量都保持着上次的值。



### 5. 生成器表达式 (Generator Expressions)

这是创建简单生成器的简洁语法，类似于列表推导式 (List Comprehension)。

- **列表推导式**：`[x * x for x in range(10)]`
  - 立即创建一个包含 10 个元素的 **列表**，占用内存。
  - 语法：`[` ... `]`
- **生成器表达式**：`(x * x for x in range(10))`
  - 立即创建一个 **生成器对象**，几乎不占用内存。
  - 语法：`(` ... `)`

当你想对一个序列做一些操作，然后逐个处理结果时，生成器表达式是最高效的选择。

```python
# 计算 100 万以内所有偶数的平方和，但不想创建中间列表
sum_of_squares = sum(x * x for x in range(1000000) if x % 2 == 0) 
# 这个过程极其节省内存，因为它一边生成一个平方，一边就把它加到总和里，从不存储所有平方值。
```



### 6. 生成器的优势总结

1. **极高的内存效率**：这是最主要的优点。因为值是按需生成的，所以可以处理非常大甚至无限的数据集，而不会耗尽内存。
2. **代码更简洁优雅**：对于需要维护状态的迭代（比如 Fibonacci 序列），使用生成器可以避免手动编写一个带有 `__iter__` 和 `__next__` 方法的类，代码更直观。
3. **可以表示无限序列**：你无法用列表存储所有自然数，但可以轻松编写一个生成器来产生无限的自然数流。



### 7. 经典示例：斐波那契数列 (Fibonacci Sequence)

这是一个完美的例子，展示了生成器如何利用其内部状态。

```python
def fib_gen():
    """一个生成无限斐波那契数列的生成器"""
    a, b = 0, 1
    while True: # 无限循环
        yield a
        a, b = b, a + b

# 使用
fib = fib_gen()
print(next(fib)) # 0
print(next(fib)) # 1
print(next(fib)) # 1
print(next(fib)) # 2
print(next(fib)) # 3
# ... 可以无限进行下去
```

在这个例子里，`a` 和 `b` 就是被 `yield` “冻结”和“恢复”的状态。每次调用 `next(fib)`，函数都会从 `a, b = b, a + b` 这行恢复，用更新后的 `a` 和 `b` 计算下一个 `yield` 值。