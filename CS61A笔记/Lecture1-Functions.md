## Lecture2-Functions

#### 1. 函数基础 (Function Basics)

这是你需要掌握的最基本概念。

- **什么是函数？**

  - 函数是一段可重复使用的代码块，用于执行特定的任务。
  - 在 CS61A 的思想里，函数是创建**抽象**的基本工具。它隐藏了复杂的实现细节，只暴露一个简单的接口（函数名和参数）。例如，你使用 `abs(x)` 时，你不需要知道它内部是如何处理正数和负数的，你只需要知道它能返回一个数的绝对值。

- **定义函数 (Defining a Function)**

  - **语法**:

    ```python
    def <函数名>(<参数列表>):
        """Docstring: 函数的说明文档."""
        <函数体>
        return <返回值>
    ```

  - **`def` 关键字**: 表明你正在定义一个函数。

  - **函数签名 (Signature)**: 包括函数名和括号里的参数列表。

  - **Docstring**: 一个可选的字符串，用于解释函数的功能、参数和返回值。写 Docstring 是一个非常好的编程习惯。

  - **`return` 语句**: 用于指定函数的返回值。

    - 如果函数执行到 `return`，它会立即退出并将结果返回。
    - 如果函数没有 `return` 语句，或者 `return` 后面没有值，它会默认返回 `None`。

- **调用函数 (Calling a Function)**

  - 使用函数名加上括号，并传入所需的**实际参数 (arguments)**。
  - 例如: `max(3, 4)`，这里的 `3` 和 `4` 就是实际参数。



#### 2. **【核心重点】环境模型 (Environment Diagrams)**

这是 CS61A 的第一个核心工具，也是理解后续所有复杂概念（如高阶函数、闭包、递归）的关键。**必须彻底搞懂！**

- **为什么重要？** 环境模型是一种可视化的方式，用于追踪代码执行过程中变量名和其对应值的绑定关系。它能帮你精确理解：

  1. 变量的作用域（Scope）。
  2. 变量的生命周期（Lifetime）。
  3. 函数调用时内存中发生的变化。

- **核心组件**:

  1. **帧 (Frame)**: 一个盒子，代表一个作用域。最重要的有两个：
     - **Global Frame**: 全局帧，代码开始执行时创建，包含所有全局变量。
     - **Function Frame**: 每当一个函数被**调用**时，就会为这次调用创建一个新的帧。
  2. **绑定 (Binding)**: 在帧内部，变量名（name）和它所指向的值（value）的关联。
  3. **父指针 (Parent Pointer)**: **这是理解嵌套函数和高阶函数的关键！** 每个函数帧都有一个父指针，指向该函数被**定义时**所在的环境帧。

- **执行流程的简化版**:

  1. **定义函数时**: 在当前帧中，将函数名绑定到一个**函数对象**。这个函数对象包含两部分：函数的代码（参数和函数体）和指向**当前环境**的指针（这就是父指针的来源）。
  2. **调用函数时**: a. 创建一个新的帧。 b. 这个新帧的**父指针**指向函数对象所记录的那个环境帧。 c. 将调用时传入的参数值绑定到函数定义中的形式参数名上，放在这个新帧里。 d. 执行函数体。
  3. **查找变量**: 当代码需要使用一个变量时，Python 会： a. 先在**当前帧**里查找。 b. 如果找不到，就通过父指针去**父帧**里查找。 c. 再找不到，就继续往上，直到找到**全局帧**。 d. 如果全局帧也找不到，就会报错 (`NameError`)。

- **示例**:

  ```python
  def square(x):
      return x * x
  
  y = 5
  result = square(y)
  ```

  环境模型会是这样：

  1. **Global Frame**: `square` 指向一个函数对象，`y` 绑定到 `5`。`square` 的函数对象的父指针指向 Global Frame。
  2. 当 `square(y)` 被调用时，创建一个新帧 `f1: square`。
  3. `f1` 的父指针指向 Global Frame。
  4. 在 `f1` 内部，参数 `x` 绑定到传入的值 `5`。
  5. 执行 `x * x`，在 `f1` 中找到 `x` 是 `5`，计算结果为 `25`。
  6. 函数返回 `25`。
  7. 回到 Global Frame，`result` 被绑定到 `25`。



#### 3. 纯函数 (Pure Functions) vs. 非纯函数 (Non-Pure Functions)

- **纯函数**:
  - **定义**: 满足以下两个条件的函数。
    1. 对于相同的输入，永远返回相同的输出。
    2. 没有**副作用 (Side Effects)**。副作用是指修改了函数外部的状态，例如：修改全局变量、打印输出到屏幕、读写文件等。
  - **例子**: `abs()`, `pow()`, 数学计算函数。
  - **优点**: 可靠、易于测试和调试。
- **非纯函数**:
  - **定义**: 不满足纯函数条件的函数。
  - **例子**: `print()` (副作用是向控制台输出)，`random.random()` (相同输入——无输入，返回不同输出)。



#### 4. **【核心重点】高阶函数 (Higher-Order Functions, HOF)**

这是 CS61A 的灵魂概念，是函数式编程思想的体现。

- **定义**: 一个函数，如果它满足以下**至少一个**条件，就是高阶函数：

  1. 接受一个或多个函数作为**参数**。
  2. **返回**一个函数作为结果。

- **Case 1: 函数作为参数**

  - **目的**: 抽象出通用的计算**模式**。

  - **例子**: 创建一个函数，它能将某个操作应用到一个值上两次。

    ```python
    def apply_twice(f, x):
        """将函数 f 应用到 x 上两次"""
        return f(f(x))
    
    def square(x):
        return x * x
    
    # 调用：将 square 函数作为参数传入
    result = apply_twice(square, 2) # 计算过程: square(square(2)) -> square(4) -> 16
    print(result)
    ```

  - 这里 `apply_twice` 就是一个高阶函数，因为它接受了函数 `square` 作为参数。

- **Case 2: 函数作为返回值**

  - **目的**: 创建**可以定制的、专门化的函数**。这是理解闭包（Closure）的入门。

  - **例子**: 创建一个 "加法器制造机"。

    ```python
    def make_adder(n):
        """返回一个新的函数，这个新函数的功能是给它的输入加上 n"""
        def adder(k):
            return k + n # 这里的 n 是来自外部 make_adder 函数的
        return adder
    
    # 使用 HOF
    add_five = make_adder(5) # add_five 现在是一个函数，等价于 adder
    add_ten = make_adder(10) # add_ten 也是一个函数
    
    print(add_five(3)) # 输出 8 (3 + 5)
    print(add_ten(3))  # 输出 13 (3 + 10)
    ```

  - **详细解释 (结合环境模型)**:

    1. 当 `make_adder(5)` 被调用时，创建一个 `f1: make_adder` 帧，`n` 在此帧中被绑定为 `5`。
    2. 在 `f1` 帧中，定义了内部函数 `adder`。`adder` 函数对象被创建，它的父指针指向 `f1`。
    3. `make_adder` 返回了这个 `adder` 函数对象，并将其赋值给 `add_five`。
    4. `f1` 帧虽然执行完毕，但因为它被 `add_five`（即 `adder` 函数）的父指针引用着，所以**它不会被销毁**。
    5. 当 `add_five(3)` 被调用时，创建新帧 `f2: adder`，其父指针指向 `f1`。
    6. 在 `f2` 中，`k` 绑定为 `3`。
    7. 执行 `k + n`。在 `f2` 中找到 `k` 是 `3`。在 `f2` 中找不到 `n`，于是通过父指针去 `f1` 中找，找到了 `n` 是 `5`。
    8. 计算结果为 `8` 并返回。

- **匿名函数 (Lambda Expressions)**

  - **语法**: `lambda <参数>: <表达式>`

  - **作用**: 一种快速、简洁地创建**单行小函数**的方式，通常用在高阶函数中，避免为其单独写一个 `def`。

  - **例子**:

    ```python
    # 使用 lambda 替代 square 函数
    result = apply_twice(lambda x: x * x, 2)
    print(result) # 同样输出 16
    ```



#### 5. 作用域 (Scope)

作用域规定了在代码的哪些区域可以访问哪些变量。

- **词法作用域 (Lexical Scoping)**: Python 使用的是词法作用域。这意味着变量的作用域是由它在代码中被**定义的位置**决定的，而不是被**调用的位置**。环境模型的父指针机制完美地诠释了这一点。
- **局部作用域 (Local Scope)**: 函数内部定义的变量。
- **非局部作用域 (Nonlocal Scope)**: 嵌套函数中，对于内层函数而言，外层（但非全局）函数中的变量。`make_adder` 例子中的 `n` 对于 `adder` 函数来说就是非局部变量。
- **全局作用域 (Global Scope)**: 在所有函数之外定义的变量。