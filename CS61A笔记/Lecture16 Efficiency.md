## Lecture15 Efficiency



#### **1. 核心目标：衡量算法的增长阶数 (Orders of Growth)**

我们衡量效率，不是看它在你的电脑上具体跑了多少秒，因为这受硬件、操作系统、编程语言等多种因素影响。我们真正关心的是一个抽象的概念：**算法消耗的资源（主要是时间和空间）随输入规模 `n` 增大的趋势**。这个趋势就被称为**增长阶数 (Orders of Growth)**。

- **输入规模 (n):** 指的是算法处理的数据量大小。例如，对一个列表排序，`n` 就是列表的长度；计算一个数的阶乘，`n` 就是这个数本身。
- **为什么关心趋势？** 因为当 `n` 很小的时候（比如 `n=10`），一个设计很差的算法可能和一个高效算法一样快。但当 `n` 变得巨大时（比如 `n=1,000,000`），两者之间的差距会变得天壤之别。



#### **2. 渐进分析 (Asymptotic Analysis) 与 Big-O 表示法**

为了形式化地描述增长阶数，我们使用**渐进分析**，它专注于当 `n` 趋向于无穷大时的算法行为。在 CS61A 中，主要使用 **Theta (Theta)** 和 **Big-O (O)** 符号。

- **Theta (Theta) 符号 (紧确界):** Theta(f(n)) 表示算法的增长阶数与 f(n) **完全相同**。例如，Theta(n) 表示算法的执行时间与输入规模 `n` 成严格的线性关系。
- **O (Big-O) 符号 (上界):** O(f(n)) 表示算法的增长阶数**不会超过** f(n)。这是业界最常用的表示法，因为它提供了一个“最坏情况”的保证。例如，一个算法是 Theta(n) 的，那它也一定是 O(n) 和 O(n2) 的，但我们通常会用最紧凑的那个上界，即 O(n)。

**记忆要点：**

- **忽略常数系数：** O(2n) 和 O(100n) 都被简化为 O(n)。因为当 `n` 足够大时，常数 `2` 或 `100` 带来的影响远不如 `n` 本身。
- **忽略低阶项：** O(n2+n+100) 被简化为 O(n2)。因为当 `n` 足够大时，n2 的增长速度会完全主导整个表达式。

------



### **重要知识点详解**



#### **3. 常见的时间复杂度 (Time Complexity) 增长阶数**

这里按照从“最快”（最高效）到“最慢”（最低效）的顺序排列，这是你必须掌握的重点。

| 增长阶数     | 名称                                 | 解释与举例                                                   |
| ------------ | ------------------------------------ | ------------------------------------------------------------ |
| **O(1)**     | **常数时间 (Constant Time)**         | **极为高效。** 算法的执行时间不随输入规模 `n` 的变化而变化。<br>**例子:** 从一个数组中取出第一个元素 `arr[0]`；哈希表的查找（平均情况）。 |
| **O(logn)**  | **对数时间 (Logarithmic Time)**      | **非常高效。** 当 `n` 翻倍时，执行时间只增加一个常数单位。通常发生在将问题规模减半的操作中。<br>**例子:** **二分查找 (Binary Search)**。每次都在一个有序列表中查找，都将搜索范围缩小一半。 |
| **O(n)**     | **线性时间 (Linear Time)**           | **高效。** 执行时间与输入规模 `n` 成正比。需要“触摸”每个输入元素一次。<br>**例子:** 遍历一个列表并找到最大值；简单的 `for` 循环。 |
| **O(nlogn)** | **线性对数时间 (Linearithmic Time)** | **相当高效。** 常见于高效的排序算法。<br>**例子:** **归并排序 (Merge Sort)**、快速排序 (Quick Sort) 的平均情况。可以理解为对 `n` 个元素，每个元素都进行了类似 logn 的操作。 |
| **O(n2)**    | **平方时间 (Quadratic Time)**        | **效率开始变差。** 当 `n` 翻倍时，执行时间变成原来的四倍。通常涉及嵌套循环。<br>**例子:** **选择排序 (Selection Sort)**、**插入排序 (Insertion Sort)**；遍历一个 `n x n` 的二维数组。 |
| **O(2n)**    | **指数时间 (Exponential Time)**      | **非常低效。** `n` 每增加一点点，执行时间就会翻倍。通常出现在未经优化的递归中。<br>**例子:** **朴素的斐波那契数列递归实现**。 |
| **O(n)**     | **阶乘时间 (Factorial Time)**        | **极端低效。** 几乎无法用于解决实际问题，除非 `n` 非常小。<br>**例子:** 旅行商问题的暴力枚举解法。 |





#### **4. 如何分析代码的时间复杂度**

- **基本操作：** 赋值、算术运算、访问数组成员等，都看作是 O(1)。

- **顺序结构：** 将多个部分代码的时间复杂度相加，然后取最高阶。例如，一个 O(n) 的循环后面跟着一个 O(n2) 的循环，总复杂度是 O(n+n2)=O(n2)。

- **循环结构：** 循环的次数乘以循环体内部的复杂度。

  - `for i in range(n): print('hello')` -> 循环 `n` 次，内部是 O(1)，总共是 O(ntimes1)=O(n)。

- **嵌套循环结构：** 将内外层循环的复杂度相乘。

  ```python
  # 外层循环 n 次
  for i in range(n):
      # 内层循环也 n 次
      for j in range(n):
          print(i, j) # O(1) 操作
  ```

  总复杂度是 O(ntimesn)=O(n2)。

- **递归结构 (Recursive Functions):** 这是难点，也是重点。

  - **关键：** 找到**递归调用次数**和**每次调用中的工作量**。

  - **例子1：阶乘**

    ```python
    def factorial(n):
        if n == 0:
            return 1
        return n * factorial(n - 1)
    ```

    `factorial(n)` 会调用 `factorial(n-1)` ... 直到 `factorial(0)`，总共调用了 `n+1` 次。每次调用内部只有一次乘法（O(1) 的工作）。所以总复杂度是 O(n)。

  - **例子2：朴素斐波那契 (Tree Recursion)**

    ```python
    def fib(n):
        if n <= 1:
            return n
        return fib(n - 1) + fib(n - 2)
    ```

    `fib(n)` 会产生两个新的调用 `fib(n-1)` 和 `fib(n-2)`。这会形成一个巨大的、重复计算的递归树。例如，`fib(5)` 会计算 `fib(3)` 两次，`fib(2)` 三次。这棵树的节点数大致是 2n 级别的，所以时间复杂度是 O(2n)。



#### **5. 【核心案例】通过记忆化 (Memoization) 优化斐波那契**

这是 CS61A 效率部分最经典的例子，展示了如何将一个低效的指数级算法优化成高效的线性级算法。

- **问题：** 朴素的 `fib` 函数有大量的重复计算。
- **解决方案：** **记忆化 (Memoization)**。用一个缓存（比如字典或列表）来存储已经计算过的结果。在计算前，先检查缓存里是否已有结果。
  - 如果有，直接返回缓存中的值。
  - 如果没有，才进行计算，并将结果存入缓存后再返回。

```python
def fib_memo(n, memo={}):
    if n in memo: # O(1) 的字典查找
        return memo[n]
    if n <= 1:
        return n
    
    # 计算结果并存入 memo
    result = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)
    memo[n] = result
    return result
```

- **优化后的复杂度分析：**
  - `fib_memo(k)` 这个函数体本身，只会在 `k` 第一次被请求时执行计算部分。之后所有对 `fib_memo(k)` 的调用都会直接从 `memo` 字典中返回。
  - 因此，`fib_memo(1), fib_memo(2), ..., fib_memo(n)` 都只会被真正计算一次。
  - **时间复杂度：** 我们需要计算 `n` 个不同的值，每次计算是 O(1)（加法和字典操作），所以总时间复杂度从 O(2n) 降到了 O(n)。这是一个巨大的飞跃！



#### **6. 空间复杂度 (Space Complexity)**

除了时间，我们还关心算法占用的内存空间。

- **定义：** 算法在执行过程中需要的额外存储空间随输入 `n` 变化的趋势。
- **迭代 (Iteration) vs 递归 (Recursion):**
  - 一个简单的 `for` 循环通常只需要固定的几个变量，空间复杂度是 O(1)。
  - 递归函数需要占用**调用栈 (call stack)** 的空间。递归的深度决定了空间复杂度。
    - `factorial(n)` 的递归深度是 `n`，所以它的空间复杂度是 O(n)。
    - `fib_memo(n)` 也是线性递归深度，所以空间复杂度是 O(n)（同时 `memo` 字典也需要 O(n) 的空间）。

------



### **总结与笔记建议**

1. **理解核心思想：** 效率衡量的是**增长趋势**，而非具体时间。Big-O 是描述这种趋势的语言。
2. **熟记常见阶数：** 必须能立刻反应出 O(1),O(logn),O(n),O(nlogn),O(n2),O(2n) 的优劣顺序和典型例子。
3. **掌握分析技巧：**
   - 循环 -> 乘法
   - 顺序 -> 加法（取大头）
   - 递归 -> 分析递归树的节点数和每节点工作量。
4. **吃透经典案例：**
   - **二分查找** -> O(logn) 的典范。
   - **朴素斐波那契** -> O(2n) 指数爆炸的警示。
   - **记忆化斐波那契** -> O(n) 展示动态规划/记忆化的威力。
5. **区分时空：** 不仅要考虑时间，也要思考算法占用了多少额外内存（空间复杂度）。