## Lecture8 Data Abstraction

### **CS61A 数据抽象 (Data Abstraction) 知识点整理**



#### **1. 核心思想：抽象屏障 (The Abstraction Barrier)**

数据抽象的核心思想是**将数据的使用方式与其具体的实现方式分离开来**。

想象一下在你（程序的使用者）和数据的具体存储方式（如用元组、列表还是其他方式实现）之间建立一道“墙”或“屏障”。

- **墙的一边（使用者）**：你只关心这个数据“能做什么”。例如，对于一个有理数，你关心的是可以获取它的分子、分母，或者将两个有理数相加。你通过调用指定的函数来完成这些操作。
- **墙的另一边（实现者）**：你决定这个数据“如何构成”。例如，你决定用一个包含两个元素的元组 `(n, d)` 来表示一个有理数。

这道“墙”就是**抽象屏障**。它的基本原则是：**使用者不应该知道，也不需要关心数据在底层是如何被表示（存储）的。**

------



#### **2. 【重要】实现数据抽象的关键：构造函数与选择函数**

为了维护这道屏障，我们定义了一组特定的函数来作为“墙”上的“官方通道”。

- **构造函数 (Constructor)**: 用于“构建”抽象数据的函数。它接收一些部分，然后将它们组合成一个完整的数据结构。
  - **例子**: `make_rat(n, d)` 就是一个构造函数。它接收分子 `n` 和分母 `d`，然后返回一个完整的“有理数”数据。
- **选择函数 (Selector)**: 用于从抽象数据中“提取”部分信息的函数。它接收一个完整的抽象数据，然后返回它的某个部分。
  - **例子**: `numer(rat)` 和 `denom(rat)` 就是选择函数。它们都接收一个“有理数” `rat`，`numer` 返回其分子，`denom` 返回其分母。

**详细解释：**

构造函数和选择函数共同定义了一个**抽象数据类型 (Abstract Data Type, ADT)**。它们就像一个“契约”：

- 构造函数承诺：“你给我这些零件，我保证造出一个符合规格的成品。”
- 选择函数承诺：“你给我一个成品，我保证能取出你想要的那个零件。”

只要这个“契约”被遵守，无论内部实现如何变化，使用者的代码都无需更改。

**代码示例：有理数的实现**

假设我们决定用**元组 (tuple)** 来表示有理数。

```python
# --- 实现层 (Implementation Layer) ---
# 只有这部分代码知道有理数是用元组表示的

def make_rat(n, d):
    """构造一个有理数 (n/d)"""
    # 这里的 (n, d) 就是底层的具体实现
    return (n, d)

def numer(rat):
    """从有理数 rat 中选择分子"""
    # 这里的 rat[0] 依赖于元组的实现
    return rat[0]

def denom(rat):
    """从有理数 rat 中选择分母"""
    # 这里的 rat[1] 依赖于元组的实现
    return rat[1]

# --- 使用层 (Usage Layer) ---
# 这部分代码完全不知道有理数是用元odule实现的
# 它只通过调用构造函数和选择函数来操作数据

def add_rat(x, y):
    """将两个有理数 x 和 y 相加"""
    nx, dx = numer(x), denom(x)
    ny, dy = numer(y), denom(y)
    # 使用构造函数和选择函数，完全不关心底层细节
    return make_rat(nx * dy + ny * dx, dx * dy)

def print_rat(x):
    """打印有理数"""
    print(f"{numer(x)}/{denom(x)}")

# --- 程序执行 ---
rat1 = make_rat(1, 2)
rat2 = make_rat(1, 3)
result = add_rat(rat1, rat2)

print_rat(result)  # 输出: 5/6
```

------



#### **3. 【重要】尊重与违反抽象屏障**

这是数据抽象中最需要遵守的规则。

- **尊重屏障 (Respecting the Barrier)** 在上面的 `add_rat` 函数中，我们严格地只使用了 `numer` 和 `denom` 来获取分子分母，用 `make_rat` 来创建新的有理数。我们**假装**不知道 `rat1` 其实是一个元组 `(1, 2)`。这就是尊重抽象屏障。

- **违反屏障 (Violating the Barrier)** 如果我们图方便，在 `add_rat` 函数中写出下面这样的代码，就叫作**违反抽象屏障**。

  ```python
  # 这是一个【错误】的示范，它违反了抽象屏障！
  def add_rat_bad(x, y):
      # 直接访问元组的索引，而不是使用选择函数
      nx, dx = x[0], x[1]
      ny, dy = y[0], y[1]
      # 直接返回元组，而不是使用构造函数
      return (nx * dy + ny * dx, dx * dy)
  ```

  **为什么违反屏障是极其糟糕的？** 因为这使得你的代码变得脆弱和僵化。假设有一天，你决定优化有理数的实现，比如为了约分，你决定用一个**列表 `[n, d]`** 来表示有理数，因为元组是不可变的。

  ```python
  # --- 新的实现方式 ---
  def make_rat(n, d):
      # 假设我们在这里加入约分逻辑...
      # ...
      return [n, d] # 改用列表
  
  def numer(rat):
      return rat[0]
  
  def denom(rat):
      return rat[1]
  ```

  - 原先**尊重屏障**的 `add_rat` 函数**仍然可以完美工作**，无需任何修改！因为它不关心返回的是元组还是列表。
  - 而那个**违反屏障**的 `add_rat_bad` 函数现在可能就会出错（或者产生意想不到的行为），因为它依赖于一个已经不存在的“元组”实现。

------



#### **4. 数据抽象的优势**

1. **灵活性和可维护性 (Flexibility & Maintainability)** 这是最大的优势。你可以随时更改底层的数据表示（例如，从元组换成列表、字典，或者一个更复杂的对象），只要你相应地更新构造函数和选择函数，所有使用这个抽象数据类型的上层代码都无需改动。这极大地降低了维护成本。
2. **简化复杂性 (Reduces Complexity)** 上层代码的编写者无需关心底层实现的细节。这使得他们可以专注于解决更高层次的问题，而不必陷入细节的泥潭。
3. **模块化 (Modularity)** 代码被清晰地划分成不同的层次和模块。与数据类型相关的所有逻辑（创建、访问）都被封装在构造函数和选择函数中，使代码结构更清晰，更容易团队协作。



#### **5. 总结笔记要点**

- **是什么 (What):** 数据抽象是分离“做什么”和“如何做”的编程思想。
- **为什么 (Why):** 为了让代码更灵活、简单和模块化，能够适应未来的变化。
- **怎么做 (How):** 通过定义 `构造函数 (Constructors)` 来创建数据，和 `选择函数 (Selectors)` 来访问数据。
- **核心规则 (The Rule):** **永远不要跨越抽象屏障**。上层代码只能通过构造/选择函数与数据交互，绝不能依赖其具体的底层实现（如 `x[0]`）。