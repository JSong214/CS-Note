## Lecture4 Environments

这部分内容的核心是理解：**当程序执行时，Python 是如何追踪和查找变量（名字）所对应的值的。** 环境模型（Environment Model）就是我们用来可视化这一过程的工具。



#### **一、核心概念 (Core Concepts)**

1. **环境 (Environment):**
   - **是什么：** 环境是程序执行过程中的一个“账本”，记录了所有当前可访问的变量名及其绑定的值。
   - **结构：** 它不是单一的，而是由一系列的“帧 (Frame)”通过父子关系链接起来的序列。整个链式结构就是环境。
2. **帧 (Frame):**
   - **是什么：** 帧是环境的基本组成单位，可以想象成一个“盒子”或“表格”。
   - **包含什么：** 每个帧内部包含了一系列的“绑定 (Bindings)”。
   - **特殊帧：**
     - **全局帧 (Global Frame):** 程序开始执行时创建的第一个也是最顶层的帧。它包含了所有在顶层代码中定义的变量和函数。它没有父帧。
     - **局部帧 (Local Frame):** 每一次调用函数时，都会创建一个新的局部帧。这个帧用于存放该函数内部定义的变量（包括参数）。
3. **绑定 (Binding):**
   - **是什么：** 一个“名字 (Name)”和一个“值 (Value)”之间的关联。例如，`x = 5` 就是在当前帧里创建了一个将名字 `x` 绑定到值 `5` 的绑定。



#### **二、最重要的规则：函数调用与名字查找 (The Rules of the Game)**

这是整个环境模型最核心、最需要掌握的部分。

------



### **重要知识点详解 (Detailed Explanations)**



#### **⭐ 规则一：函数调用 (Function Calls)**

**一句话总结：每一次函数调用，都会创建一个全新的、独立的局部帧。**

**详细解释：**

1. **创建新帧：** 当你调用一个函数时，例如 `my_func(10)`，一个新的局部帧会被创建出来。我们通常称之为 `f1`, `f2`, ... 以便区分。
2. **绑定参数：** 函数的参数会作为这个新局部帧的第一批绑定。形如 `def my_func(x):`，在调用 `my_func(10)` 时，这个新的局部帧里会立即包含一个绑定：`x` 绑定到值 `10`。
3. **设置父帧 (Parent Pointer)：** 这是最关键的一步！**新创建的局部帧的“父帧”，是定义这个被调用函数的那个帧。** 这就是所谓的 **词法作用域 (Lexical Scoping)** 或 **静态作用域 (Static Scoping)**。
   - **词法作用域意味着：** 函数的“出身”决定了它的作用域链，而不是它被“调用”的地方。一个函数“记住”了它被创建时的环境。

------



#### **⭐ 规则二：名字查找 (Name Resolution)**

**一句话总结：从当前帧开始，沿着父帧链向上查找，直到找到名字为止。**

**详细解释：**

当代码需要使用一个变量的值时（例如 `print(x)`），Python 会执行以下查找步骤：

1. **从当前帧开始：** 首先，在当前的局部帧中查找是否存在名为 `x` 的绑定。
2. **如果找到：** 立即使用该绑定对应的值，查找结束。
3. **如果没找到：** **通过父帧指针，移动到父帧中去查找**。
4. **重复过程：** 在父帧中重复第 2 步和第 3 步。如果找到了就停下；如果还没找到，就继续跳到父帧的父帧...
5. **直到全局帧：** 这个过程会一直持续，直到抵达全局帧。
6. **最终结果：**
   - 如果在全局帧中找到了 `x`，就使用它的值。
   - 如果连全局帧里都找不到这个名字，Python 就会抛出一个 `NameError`。

------



#### **三、实战演练：`make_adder` 闭包示例**

这个例子是 CS61A 中解释环境模型的经典案例，完美地展示了上述两条规则。

**代码：**

```python
def make_adder(n):
    def adder(k):
        return n + k
    return adder

add_five = make_adder(5)
result = add_five(3)
```

让我们用环境模型一步步分解它的执行过程：

**Step 1: 执行 `def make_adder(n): ...`**

- **全局帧 (Global Frame)** 被创建。
- 一个名为 `make_adder` 的名字被绑定到一个函数对象上。这个函数对象的代码是 `def adder(k): ...`。

**环境图示:**

```
Global Frame
  make_adder -> [func make_adder(n)]
```

**Step 2: 执行 `add_five = make_adder(5)`**

1. **调用 `make_adder` 函数**。根据**规则一**，创建一个新的局部帧 `f1`。
2. **绑定参数**：在 `f1` 中，将参数 `n` 绑定到值 `5`。
3. **设置父帧**：`make_adder` 是在全局帧中定义的，所以 `f1` 的父帧是全局帧。
4. **函数体执行**：在 `make_adder` 内部，又定义了另一个函数 `adder`。因此，在 `f1` 帧内，创建了一个名为 `adder` 的绑定，它指向一个新的函数对象。
   - **关键点**：这个新创建的 `adder` 函数对象，它“记住”了自己是在 `f1` 帧里被创建的。它的环境指针指向 `f1`。
5. **返回**：`make_adder` 函数返回了这个 `adder` 函数对象。
6. **全局绑定**：在全局帧中，名字 `add_five` 被绑定到 `make_adder(5)` 的返回值，也就是那个“记住”了 `f1` 的 `adder` 函数对象。

**环境图示:**

```
Global Frame
  make_adder -> [func make_adder(n)]
  add_five   -> [func adder(k), parent=f1]  <-- 注意这个 parent 指针

f1: make_adder [parent=Global]
  n -> 5
  adder -> [func adder(k), parent=f1]
```

**Step 3: 执行 `result = add_five(3)`**

1. **调用 `add_five` 函数**。`add_five` 本质上就是那个内部的 `adder` 函数。根据**规则一**，创建又一个全新的局部帧 `f2`。
2. **绑定参数**：在 `f2` 中，将参数 `k` 绑定到值 `3`。
3. **设置父帧 (最关键的一步！)**：`add_five` (也就是`adder`) 的环境指针指向 `f1`，所以新帧 `f2` 的父帧是 `f1`，**而不是全局帧**！
4. **函数体执行**：`add_five` 的函数体是 `return n + k`。现在需要计算 `n + k` 的值。
5. **名字查找 (规则二)**：
   - **查找 `k`**：首先在当前帧 `f2` 中查找。找到了！`k` 绑定到 `3`。
   - **查找 `n`**：首先在当前帧 `f2` 中查找。没找到。于是，**顺着父帧指针，到 `f1` 中去查找**。在 `f1` 中找到了！`n` 绑定到 `5`。
6. **计算与返回**：计算 `5 + 3`，得到 `8`。函数返回 `8`。
7. **全局绑定**：在全局帧中，名字 `result` 被绑定到值 `8`。

**最终环境图示:**

```
Global Frame
  make_adder -> [func make_adder(n)]
  add_five   -> [func adder(k), parent=f1]
  result     -> 8

f1: make_adder [parent=Global]
  n -> 5
  adder -> [func adder(k), parent=f1]

f2: adder [parent=f1]  <-- 注意父帧是 f1
  k -> 3
  return value -> 8
```

这个 `add_five` 函数就是一个 **闭包 (Closure)**：一个函数和它所“捕获”的自由变量（在它的环境中但不在它的局部作用域中的变量，比如 `n`）的组合。

------



### **四、总结与笔记要点**

- **环境模型的核心目的**：追踪变量名与值的关系。
- **两大组件**：环境由**帧 (Frames)** 链接而成，帧包含**绑定 (Bindings)**。
- **黄金法则 1 (创建)**：每次函数调用 = 1 个新局部帧。
- **黄金法则 2 (链接)**：新帧的父帧 = 定义该函数的帧。 (词法作用域)
- **黄金法则 3 (查找)**：查找名字时，从当前帧开始，沿着父帧链一路向上，直到找到或报错。
- **闭包 (Closure)**：一个函数和它被创建时所在的环境的组合。这个函数“记住”了它诞生时的环境，即使创建它的函数已经返回。`make_adder` 的例子就是典型的闭包。